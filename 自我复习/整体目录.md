# 整体目录



# JVM

## JVM内存区域(运行时数据区)

## 线程共享:

### 堆

放对象实例的一个内存区域，，**几乎所有**（存在栈上分配） 对象实例和数组都在这里分配内存



#### 堆的划分

新生代和老年代，新生代又分为Eden区，From Survivor区 和 To Survivor区



**<u>为什么要进一步划分呢</u>**？

为了更好的回收内存，或者说更快的分配内存



#### 对象如何从新生代到老年代的

首先一个对象（这里排除大对象）会在Eden区分配内存，经过一次新生代垃圾回收（Minor GC)后，如果对象还存活，对象年龄加1，当其年龄增加到15（默认为15），就会被晋升到老年代

Eden区里存活的对象复制到From Survivor里边，此时to Survivor时空的，在下一次minor GC的时候，将Eden区存活的对象复制到To Survivor区，From区的存活对象要么进入到老年代，要么复制到To Survivor区，然后From（此时是空的） 和 To角色对换 ，并且

### 方法区（待补充）

1.6是永久代,存在于堆中,其大小受JVM限制（JVM本身设置固定大小上限，无法进行调整），在大量使用字符串的情况下会OutOfMemoryError。而在1.8中变成了元空间，移到了直接内存中，其大小受本机可用内存限制



### 常量池（1.6补充）

1.6两个常量池：运行时常量池和字符串常量池都在方法区中；

1.8：运行时常量池（存放类的原信息）放到了直接内存中，而字符串常量池和静态变量放在了堆中



1. class常量池

   编译成class文件产生，class文件种除了包含类的版本，字段，方法，接口等描述信息外，还包含常量池，用于存放编译器生成的各种**字面量（就是常量，String || final）和符号引用**（一组符号来描述所引用的目标）

2. 字符串常量池

   在类加载完成后，经过验证，准备阶段之后在 **堆中生成的字符串对象实例** ，然后将该字符串对象实例的引用值存到string pool**（string pool存的是引用值而不是具体的实例对象，具体的实例在堆中）**，HotSpot VM里实现的string pool功能就是一个StrngTable类，它是一个哈希表，里面存的是驻留字符串的引用，也就是说一旦堆中的某些字符串实例被这个StringTable引用后就等同于被赋予了驻留字符串的身份，这个String Table在每个HotSpot VM的实例只有一份，被所有的类共享

3. 运行时常量池

   当类加载到内存之后，jvm就会将class常量池种的内容存放到运行时常量池中，所以 **每个类都有一个运行时常量池**，class常量池中的符号引用经过解析，将符号引用替换为直接引用，解析过程会去查询字符串常量池，以保证运行时常量池所引用的字符串与字符串常量池所引用的是一致



## 线程单独拥有的:

### 虚拟机栈

每个Java方法执行的时候都会创建一个栈帧来存储**局部变量表，操作数栈，动态链接，方法出口**等信息。方法的从执行到完成对应JVM虚拟机栈的栈帧的入栈和出栈

OOM:

1. StackOverflowError

   > 线程请求的栈的深度大于JVM所允许的最大深度，物理内存仍有足够的空间

2. OutOfMemoryError

   > 无法向操作系统申请到足够的内存空间来拓展栈，操作系统管理的物理内存已没有足够的可用内存分给JVM的栈使用

### 本地方法栈

与虚拟机栈所发挥的作用非常相似，区别就是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务

在Hotspot虚拟机中和Java虚拟机栈合二为1

### 程序计数器

作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候能够知道上次线程运行的位置

是唯一一个不会出现OOM的内存区域，生命周期是和线程一样





### JVM类的成员变量位置

基础类型变量也在堆里，引用指向的对象放在堆里边。静态变量，常量放在方法区里面，jdk1.7以前的情况，1.7及以后放在了堆里面

方法里面的基本数据类型放在栈里面，引用也是，引用指向的对象在堆里





## JVM内存管理

### 多少种GC方式

3中，Minor，Major，full GC



### 老年代空间不足

大对象（需要大量连续内存的Java对象）直接进入老年代，长期存活的对象进入老年代

解决方法：应尽量避免创建大的对象以及数组，还可以通过-Xmn虚拟机参数设置新生代的大小，让对象尽可能在新生代被回收掉，还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄



大对象直接进入老年代，避免在两个Survivor之间的大量内存复制



### 为什么要分代

新生代 & 老年代 ：在年轻代增加Surviver区，有助于减轻老年代的负担，尽可能让大部分对象在年轻代通过较高效的Minor GC回收掉，不至于老年代里存放对象过多导致内存不足频繁进行Major GC



新生代：Eden区&Surviver区 8：1：1 ：利用复制算法，减少内存碎片的产生，也防止Survivor区虽然有足够空间但因为内存碎片导致大对象不能进入survivor区



### 空间分配担保（Minor GC的安全与否）

在发生Minor GC之前， 虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则可以确认Minor GC是安全的

如果不成立那么虚拟机会查看 HandlePromotionFailure的值是否允许担保失败，如果允许那就检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor  GC，如果小于或者HandlePromotionFailure的值为不允许冒险，那么就要进行一次Full GC



### 虚拟机垃圾收集算法

1. 标记-清除算法

   标记阶段，对可回收对象进行标记；清除阶段，对标记的对象进行清除，并取消标记，还会判断回收后的分块与前一个空闲分块是否连续，若连续则合并这两个分块（感觉有点像OS的分页方面的）。

   回收流程：回收对象就是把对象作为分块，连接到被称为“空闲列表”的单向链表，之后对新对象进行分配时只需要遍历这个空闲链表，就可以找到分块

   缺点：标记和清除过程效率不高，产生大量内存碎片，导致无法给大对象分配内存空间

2. 复制算法

   将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上，然后再把使用过的内存空间进行一次清理

   缺点：只是用了一半内存

3. 标记-整理算法

   标记阶段：标记要回收的对象。整理阶段：将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

   优点：不会产生内存碎片

   缺点：需要移动大量对象，处理效率较低

4. 分代收集算法

   根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

   一般将堆分为新生代和老年代，新生代使用 复制算法   老年代使用：标记-清除 或 标记-整理算法





### 判断一个对象是否可以被回收(可达性分析讲啥啊)

1. 引用计数法

2. 可达性分析算法

   以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收

   GC Roots一般包含以下内容：

   > 虚拟机栈帧中局部变量表中引用的对象，即方法里面的局部变量
   >
   > 本地方法栈JNI（一般指Native）引用的对象
   >
   > 方法区中类静态属性引用的对象，即 类的静态变量
   >
   > 方法区中常量引用的对象，即类的常量

   成员变量不能作为GC Roots



### 引用类型(得扩展下)

1. 强引用

   

2. 软引用

3. 弱引用

4. 虚引用





## 垃圾收集器



名词解释：

Mutator：Java应用线程。Mutator的含义是可变的，在这里的含义是因为线程运行，导致了内存的变化。

### 卡表（Card Table）

[JVM-卡表（Card Table） - hongdada - 博客园 (cnblogs.com)](https://www.cnblogs.com/hongdada/p/12016020.html)

出现背景：

现代JVM，堆空间通常被划分为新生代和老年代。由于新生代的垃圾收集通常很频繁，如果**老年代对象引用了新生代的对象，那么，需要跟踪从老年代到新生代的所有引用**，从而避免每次YGC时扫描整个老年代，减少开销。

对于HotSpot JVM，使用了卡标记（Card Marking）技术来解决老年代到新生代的引用问题。**具体是，使用卡表（Card Table）和写屏障（Write Barrier）来进行标记并加快对GC Roots的扫描。也用于CMS GC：**

CMS在并发标记阶段，应用线程和GC线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：

- 新生代的对象晋升到老年代；
- 直接在老年代分配对象；
- 老年代对象的引用关系发生变更；
- 等等。

对于这些对象，需要重新标记以防止被遗漏。为了提高重新标记的效率，并发标记阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续阶段就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。



卡表介绍：

基于卡表（Card Table）的设计，通常将堆空间划分为一系列2次幂大小的卡页（Card Page）。

卡表（Card Table），用于标记卡页的状态，每个卡表项对应一个卡页。

HotSpot JVM的卡页（Card Page）大小为512字节，卡表（Card Table）被实现为一个简单的字节数组，即卡表的每个标记项为1个字节。

当对一个对象引用进行写操作时（对象引用改变），写屏障逻辑将会标记对象所在的卡页为dirty。



OpenJDK/Oracle 1.6/1.7/1.8 JVM默认的卡标记简化逻辑如下：

首先，计算对象引用所在卡页的卡表索引号。将地址右移9位，相当于用地址除以512（2的9次方）。可以这么理解，假设卡表卡页的起始地址为0，那么卡表项0、1、2对应的卡页起始地址分别为0、512、1024（卡表项索引号乘以卡页512字节）。

其次，通过卡表索引号，设置对应卡标识为dirty。



**<u>带来的2个问题</u>**：

1.无条件写屏障带来的性能开销

每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，与YGC时扫描整个老年代相比较，这个开销就低得多了。

不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题。



2.高并发下虚共享带来的性能开销

在高并发情况下，频繁的写屏障很容易发生虚共享（false sharing），从而带来性能开销。

假设CPU缓存行大小为64字节，由于一个卡表项占1个字节，这意味着，64个卡表项将共享同一个缓存行。

HotSpot每个卡页为512字节，那么一个缓存行将对应64个卡页一共64*512=32KB。

如果不同线程对对象引用的更新操作，恰好位于同一个32KB区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。

一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为dirty。

这就是JDK 7中引入的解决方法，引入了一个新的JVM参数-XX:+UseCondCardMark，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。

简单理解如下：

与原来的实现相比，只是简单的增加了一个判断操作。

虽然开启-XX:+UseCondCardMark之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现虚共享问题（false sharing）。





### 1. CMS收集器（Concurrent Mark Sweep）

   [再谈HotSpot JVM GC机制中的写屏障 - 简书 (jianshu.com)](https://www.jianshu.com/p/0d7a6fcc8f9e)

   标记-清除算法

   主要分为4个流程：

   

   初始标记：仅标记GC Roots 能直接关联到的对象，速度快，需要停顿（STW)

   

   并发标记：进行GC Roots Tracing的过程，整个回收过程中耗时最长，不需要停顿， **<u>并发标记过程中，把赋值的这种新增的引用放到集合中</u>**

   

   重新标记：修正标记期间因用户程序继续运作而导致一些对象的标记产生变动，然后需要更新这些标记，需要停顿， **<u>CMS用的是增量更新的办法</u>**

   > 如何解决漏标问题？比如 A 引用B，B入栈，A变黑，弹出栈，与此同时，A引用C，B取消对C的引用，就产生漏标问题
   >
   > 出现漏标的充要条件是以下两个情况同时发生：
   >
   > 1. mutator使黑色对象直接引用了白色对象；
   > 2. mutator删除了从灰色对象到白色对象之间的所有引用路径。

   > 解决办法：破坏上面两个条件，引入了
   >
   > 强三色不变式：保证永远不会存在黑色对象到白色对象的引用
   >
   > 弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态，<u>即直接或间接从灰色对象可达</u>
   >
   > 强/弱三色不变式都可以通过屏障技术来实现，并且在不同环境下有多种不同的屏障技术。CMS收集器采用增量更新（incremental update）写屏障实现强三色不变式（具体来讲，是Dijkstra等人提出的Dijkstra写屏障）其逻辑是：
   >
   > **拦截使黑色对象引用指向白色对象的mutate操作，强制被引用指向的白色对象置为灰色状态，并将其压入标记栈。**
   >
   > 但是，增量更新写屏障无法探知堆外（如栈上）GC Roots的引用变化，所以CMS收集器在并发标记和预清理完成后，还得做一次重新标记，即再做一次根搜索。

   

   并发清除：不需要停顿

   > 并发清理时，用户线程产生的引用关系变化不会影响其清除吗？比如黑色对象在并发清理过程中指向了白色对象，但白色对象被清除掉了

   > 先来了解三色标记：
   >
   > 白色：表示对象尚未被垃圾收集器访问过。在可达性开始阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，说明该对象不可达。
   > 黑色：表示对象已经被垃圾收集器访问过，且这个对象的指向其他对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，代表它是安全存活的。黑			色对象不可能直接（不经过灰色对象）指向某个白色对象。
   > 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个指向其他对象的引用还没有被扫描过。
   >
   > 所以并发清理时和用户线程并发执行是如何保证安全清理的？
   >
   > 首先，并发清理时，标记过程（初始标记、并发标记、重新标记）已经结束，此时大家想象一下在老年代的所有对象中，现在只有黑色和白色的对象，然后就是：黑色对象不可能直接（不过经过灰色对象）指向某个白色对象，即标记结束时这些白色对象是不可达的。由于没有灰色对象，黑色对象也无法改变对象引用到白色对象上，那就可以说此时清理白色对象是安全的。



缺点：

1. 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致CPU利用率不高
2. 无法处理浮动垃圾，可能出现Concurrent Mode Failure。（浮动垃圾是指在并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾这能留到下次GC再回收。所以得预留出一部分内存，避免预留内存不够放，出现Concurrent Mode Failure,虚拟机将启用Serial Old来替代CMS
3. 利用标记-清除算法，导致出现内存碎片，可能存在大对象找不到足够大的连续空间来存放，而老年代里面的内存是足够存放的情况，提前出发Major GC

### 2.G1收集器







## 类的生命周期

### 加载

[Java 类加载机制(阿里)-何时初始化类 - aspirant - 博客园 (cnblogs.com)](https://www.cnblogs.com/aspirant/p/7200523.html)

分三步走：

1. 通过类的完全限定名获取定义该类的二进制字节流
2. 将该字节流表示的静态存储结构转换为方法区的运行时存储结构
3. 在方法区生成一个代表该类的java.lang.Class对象（JVM并没有规定在堆还是在方法区，HotSpot选择方法区），作为方法区中该类各种数据的访问入口

### 链接

也分三步：

1. 验证

   确保Class文件的字节流包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身安全，验证阶段会完成以下4个阶段的动作：

   文件格式验证（such 魔数） --> 元数据验证（该类是否继承了不能继承的类） --> 字节码验证（保证跳转指令不会跳到方法体以外的字节码指令上）--> 符号引用验证（通过类的全限定名能否找到对应的类）

2. 准备

   **jdk1.6 在方法区** 为类变量分配内存并设置初始值，jdk1.7及以后都是在堆分配内存

   如果类变量是常量，那么将初始化为表达式所定义的值（在编译时就被放到了class常量池）

3. 解析

   将常量池的符号引用替换为直接引用的过程

   该阶段可在初始化之后再开始，由于支持Java的动态绑定

   直接引用（对象引用）：指向目标的指针，相对偏移量或间接定位到目标的句柄

### 初始化

执行类中定义的Java程序代码。初始化阶段是虚拟机执行类构造器\<clinit>()方法（由编译器按语句在源文件出现顺序自动收集类变量的赋值动作和静态代码块中的语句合并产生的）的过程

接口中不可以使用静态代码块，但可由类变量初始化的赋值操作，所以接口和类都有\<clinit>()方法，但执行接口的\<clinit>()方法不需要执行父接口的\<clinit>，只有当父接口中定义的变量使用时，父接口才会初始化。接口的实现类在初始化也不会执行接口的\<clinit>方法



悉尼及会保证一个类的\<clinit>方法在多线程环境下被正确的加锁和同步，多个线程执行\<clinit> 只会有一个能执行，其他阻塞，直到方法执行完毕

### 使用，卸载



## 如何实现类的加载

继承ClassLoader，重写findClass方法，根据类的全名找到对应的字节码文件，读取该文件内容，在通过defineClass方法把字节码转换成Java.lang.Class类的实例

loadClass方法实现的是双亲委派模型的逻辑





## Java对象的创建过程

1. 检查类是否已经被加载

   当程序遇到 new 关键字时，首先会去运行时常量池中查找该引用指向的类有没有被虚拟机加载，如果没加载，那么进行类的加载过程。如果已经被加载，那么进行下一步。

2. 为对象分配内存空间

   类被加载后，需要在堆中为该对象分配一定的空间，该空间大小在类加载完成时就已经确定下来。

   分配空间方式有两种：

   * 指针碰撞

     JVM将堆区抽象为两块区域，一块是已经被其他对象占用的区域，另一块是空白区域，中间通过一个指针进行标注，只需要将指针向空白区域移动相应大小空间，就完成内存的分配。 **这种划分方式要求虚拟机的内存是地址连续的，且虚拟机带有内存压缩机制，可以在内存分配完成时压缩内存，形成连续地址空间**，但存在的问题就是多线程创建对象，可能出现指针划分不一致的问题，对于这个问题虚拟机采用循环CAS操作来保证内存的正确划分

   * 空闲列表

     虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录

   * TLAB（不算分配方式）

     为了提高多线程创建对象的效率，，虚拟机为每个线程分配不同的空间，这样每个线程在分配内存时只是在自己的空间中操作，避免了同步的开销

     > JVM设置了最大浪费空间:
     >  ① 当剩余的空间小于最大浪费空间，那该TLAB属于的线程在重新向Eden区申请一个TLAB空间，进行对象创建，如果还是空间不够，那你这个对象就是太大了，需要去Eden区直接创建；
     >  ② 当剩余的空间大于最大浪费空间，那这个大对象请你直接去Eden区创建，我TLAB放不下没有使用完的空间；
     >
     >
     > 链接：https://www.jianshu.com/p/3684869af4cc

3. 为对象字段设置零值

   为对象的字段设置0或null

4. 设置对象头

   虚拟机对将要创建出来的对象进行信息标记，包括存储在新/老生代，对象的哈希码，元数据信息

5. 执行构造方法

   执行对象的构造方法







## java编译器做的优化

1. 如果没有写构造器，默认送一个无参构造器

2. 自动拆装箱

   >Integer x = 1; 	会自动装箱：Integer x = Integer.valueOf(1)
   >
   >int y = x;		自动拆箱：int y = x.intValue();

3. 泛型集合取值

   泛型擦除，即编译为字节码后泛型的信息就丢失了，实际类型都当作Object类型来处理

4. foreach循环





# 操作系统

## 进程 和 线程

[深入理解进程和线程 - 天空101 - 博客园 (cnblogs.com)](https://www.cnblogs.com/tiankong101/p/4229584.html)

直接看虚拟地址空间，分成两部分，上面部分是所有进程共享内核，下面一部分是应用程序，每个应用程序分别独立，互不干扰。 **每个进程的虚拟地址空间是相同的，但他们的物理地址不同**，由于CPU执行指令时采用了虚拟地址，对应一个特定的变量来说，它对应着一个特定的虚拟地址。这样带来的问题就是两个进程不能通过简单的共享变量的方式来进行进程间通信，也就是说进程不能通过直接共享内存的方式来进行进程间通信，只能采用信号，管道等方式来进行进程间通信。这样的效率肯定比直接共享内存的方式差



每个进程拥有的内存为 2的x次方，x等于操作系统的位数（32|64）





[浅谈Linux线程模型 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/57349087#:~:text=在Linux内核中，其实是没有线程的概念的，它把所有的线程当做标准的进程来实现，也就是说Linux内核，并没有为线程提供任何特殊的调度语义，也没有为线程实现特定的数据结构。. 取而代之的是，线程只是一个与其他进程共享某些资源的进程。. 每一个线程拥有一个唯一的task_struct结构，Linux内核它仅仅把线程当做一个正常的进程，或者说是轻量级进程，LWP,(Lightweight processes)。. 对于其他的操作系统而言，比如windows，线程相对于进程，只是一个提供了更加轻量、快速执行单元的抽象概念。. 对于Linux而言，线程只是进程间共享资源的一种方式，非常轻量。.)

线程上线文切换时，虚拟地址空间是不变的，但是进程上下文切换时，是需要重新映射虚拟地址空间。进程切换上下文时，进出OS内核&寄存器切换，是最大的时间支出。更模糊的代价是上下文切换时，会干扰处理器的缓存机制。当上下文切换时，处理器需要重新cache一些内存。

这里更大的一个区别时，当更改虚拟地址空间时，CPU 的 TLB 等也会被刷新，导致接下来的内存访问更加耗时，所以相对线程切换来说，进程的切换耗时更大。







# 面向对象思想

从用户的角度思考问题

我们写的代码只往外界提供功能，内部的实现细节由我们自己处理，外界不用管内部的实现细节。同时我们还要为后来接管或修改我们代码的人考虑，变量的命名等都要具有意义，该功能的参数要注意添加注释解释





# JAVA

类的实例有this，类没有this，所以类没办法引用成员变量，函数



## 抽象类和接口区别

实现角度:

抽象类可以有成员变量,部分实现

抽象类不可以有多重继承,接口可以

接口相比较抽象类更能强调某个功能的实现,而抽象类虽然某种程度上也可以模拟接口,但调用的人并不知道这个抽象类是模拟接口还是提供一些基础的实现(公共的实现)





# MySQL

## 存储引擎

### MyISAM

#### 索引

MyISAM引擎使用B+Tree作为索引结构，叶结点的data域存放的是数据记录的地址





# 智力题

1.两个人轮流抛硬币，正面获胜，先抛的人获胜的概率

```java
A先，B后

P(A) = 1/2 +      //A直接取胜 
	   1/2 * 1/2 * 1/2 +      // A1失败B1失败A2取胜
	   1/2 * 1/2 * 1/2 * 1/2 *1/2  +    //A1失败B1失败A2失败B2失败A3取胜
	   ...

p = 1/2 + (1/2)^3 + (1/2)^5 + (1/2)^7 + ...
等比数列求和
p = 1/2 * (1 - (1/4)^n) / (1 - 1/4) = 2/3




P(B） = 1/2 * 1/2 +     // A1失败B1取胜
        1/2 * 1/2 * 1/2 * 1/2 +     // A1失败B1失败A2失败B2取胜
        1/2 * 1/2 * 1/2 * 1/2 * 1/2 * 1/2 +  //A1失败B1失败A2失败B2失败A3失败B3取胜、
        ...    
p = (1/2)^2 + (1/2)^4 + (1/2)^6 + ..

p = 1/4 * (1 - (1/4)^n) / (1 - 1/4)
————————————————
版权声明：本文为CSDN博主「宇智波爱编程」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_39590058/article/details/108410064
```

