# 整体目录



## JVM内存区域(运行时数据区)

## 线程共享:

### 堆

放对象实例的一个内存区域，，**几乎所有**（存在栈上分配） 对象实例和数组都在这里分配内存



#### 堆的划分

新生代和老年代，新生代又分为Eden区，From Survivor区 和 To Survivor区



**<u>为什么要进一步划分呢</u>**？

为了更好的回收内存，或者说更快的分配内存



#### 对象如何从新生代到老年代的

首先一个对象（这里排除大对象）会在Eden区分配内存，经过一次新生代垃圾回收（Minor GC)后，如果对象还存活，对象年龄加1，当其年龄增加到15（默认为15），就会被晋升到老年代

Eden区里存活的对象复制到From Survivor里边，此时to Survivor时空的，在下一次minor GC的时候，将Eden区存活的对象复制到To Survivor区，From区的存活对象要么进入到老年代，要么复制到To Survivor区，然后From（此时是空的） 和 To角色对换 ，并且

### 方法区（待补充）

1.6是永久代,存在于堆中,其大小受JVM限制（JVM本身设置固定大小上限，无法进行调整），在大量使用字符串的情况下会OutOfMemoryError。而在1.8中变成了元空间，移到了直接内存中，其大小受本机可用内存限制



### 常量池（1.6补充）

1.6两个常量池：运行时常量池和字符串常量池都在方法区中；

1.8：运行时常量池（存放类的原信息）放到了直接内存中，而字符串常量池和静态变量放在了堆中





## 线程单独拥有的:

### 虚拟机栈

每个Java方法执行的时候都会创建一个栈帧来存储**局部变量表，操作数栈，动态链接，方法出口**等信息。方法的从执行到完成对应JVM虚拟机栈的栈帧的入栈和出栈

OOM:

1. StackOverflowError

   > 线程请求的栈的深度大于JVM所允许的最大深度，物理内存仍有足够的空间

2. OutOfMemoryError

   > 无法向操作系统申请到足够的内存空间来拓展栈，操作系统管理的物理内存已没有足够的可用内存分给JVM的栈使用

### 本地方法栈

与虚拟机栈所发挥的作用非常相似，区别就是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务

在Hotspot虚拟机中和Java虚拟机栈合二为1

### 程序计数器

作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制
2. 多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程切换回来的时候能够知道上次线程运行的位置

是唯一一个不会出现OOM的内存区域，生命周期是和线程一样





### JVM类的成员变量位置

基础类型变量也在堆里，引用指向的对象放在堆里边。静态变量，常量放在方法区里面，jdk1.7以前的情况，1.7及以后放在了堆里面

方法里面的基本数据类型放在栈里面，引用也是，引用指向的对象在堆里





## JVM内存管理

### 多少种GC方式

3中，Minor，Major，full GC



### 老年代空间不足

大对象（需要大量连续内存的Java对象）直接进入老年代，长期存活的对象进入老年代

解决方法：应尽量避免创建大的对象以及数组，还可以通过-Xmn虚拟机参数设置新生代的大小，让对象尽可能在新生代被回收掉，还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄



大对象直接进入老年代，避免在两个Survivor之间的大量内存复制



### 为什么要分代

新生代 & 老年代 ：在年轻代增加Surviver区，有助于减轻老年代的负担，尽可能让大部分对象在年轻代通过较高效的Minor GC回收掉，不至于老年代里存放对象过多导致内存不足频繁进行Major GC



新生代：Eden区&Surviver区 8：1：1 ：利用复制算法，减少内存碎片的产生，也防止Survivor区虽然有足够空间但因为内存碎片导致大对象不能进入survivor区



### 空间分配担保（Minor GC的安全与否）

在发生Minor GC之前， 虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立，则可以确认Minor GC是安全的

如果不成立那么虚拟机会查看 HandlePromotionFailure的值是否允许担保失败，如果允许那就检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor  GC，如果小于或者HandlePromotionFailure的值为不允许冒险，那么就要进行一次Full GC



### 虚拟机垃圾收集算法

1. 标记-清除算法

   标记阶段，对可回收对象进行标记；清除阶段，对标记的对象进行清除，并取消标记，还会判断回收后的分块与前一个空闲分块是否连续，若连续则合并这两个分块（感觉有点像OS的分页方面的）。

   回收流程：回收对象就是把对象作为分块，连接到被称为“空闲列表”的单向链表，之后对新对象进行分配时只需要遍历这个空闲链表，就可以找到分块

   缺点：标记和清除过程效率不高，产生大量内存碎片，导致无法给大对象分配内存空间

2. 复制算法

   将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上，然后再把使用过的内存空间进行一次清理

   缺点：只是用了一半内存

3. 标记-整理算法

   标记阶段：标记要回收的对象。整理阶段：将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

   优点：不会产生内存碎片

   缺点：需要移动大量对象，处理效率较低

4. 分代收集算法

   根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

   一般将堆分为新生代和老年代，新生代使用 复制算法   老年代使用：标记-清除 或 标记-整理算法





### 判断一个对象是否可以被回收(可达性分析讲啥啊)

1. 引用计数法

2. 可达性分析算法

   以GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收

   GC Roots一般包含以下内容：

   > 虚拟机栈帧中局部变量表中引用的对象，即方法里面的局部变量
   >
   > 本地方法栈JNI（一般指Native）引用的对象
   >
   > 方法区中类静态属性引用的对象，即 类的静态变量
   >
   > 方法区中常量引用的对象，即类的常量

   成员变量不能作为GC Roots



### 引用类型(得扩展下)

1. 强引用

   

2. 软引用

3. 弱引用

4. 虚引用





## 垃圾收集器

名词解释：

Mutator：Java应用线程。Mutator的含义是可变的，在这里的含义是因为线程运行，导致了内存的变化。

### 卡表（Card Table）

[JVM-卡表（Card Table） - hongdada - 博客园 (cnblogs.com)](https://www.cnblogs.com/hongdada/p/12016020.html)

出现背景：

现代JVM，堆空间通常被划分为新生代和老年代。由于新生代的垃圾收集通常很频繁，如果**老年代对象引用了新生代的对象，那么，需要跟踪从老年代到新生代的所有引用**，从而避免每次YGC时扫描整个老年代，减少开销。

对于HotSpot JVM，使用了卡标记（Card Marking）技术来解决老年代到新生代的引用问题。**具体是，使用卡表（Card Table）和写屏障（Write Barrier）来进行标记并加快对GC Roots的扫描。也用于CMS GC：**

CMS在并发标记阶段，应用线程和GC线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：

- 新生代的对象晋升到老年代；
- 直接在老年代分配对象；
- 老年代对象的引用关系发生变更；
- 等等。

对于这些对象，需要重新标记以防止被遗漏。为了提高重新标记的效率，并发标记阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续阶段就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。



卡表介绍：

基于卡表（Card Table）的设计，通常将堆空间划分为一系列2次幂大小的卡页（Card Page）。

卡表（Card Table），用于标记卡页的状态，每个卡表项对应一个卡页。

HotSpot JVM的卡页（Card Page）大小为512字节，卡表（Card Table）被实现为一个简单的字节数组，即卡表的每个标记项为1个字节。

当对一个对象引用进行写操作时（对象引用改变），写屏障逻辑将会标记对象所在的卡页为dirty。



OpenJDK/Oracle 1.6/1.7/1.8 JVM默认的卡标记简化逻辑如下：

首先，计算对象引用所在卡页的卡表索引号。将地址右移9位，相当于用地址除以512（2的9次方）。可以这么理解，假设卡表卡页的起始地址为0，那么卡表项0、1、2对应的卡页起始地址分别为0、512、1024（卡表项索引号乘以卡页512字节）。

其次，通过卡表索引号，设置对应卡标识为dirty。



**<u>带来的2个问题</u>**：

1.无条件写屏障带来的性能开销

每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，与YGC时扫描整个老年代相比较，这个开销就低得多了。

不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题。



2.高并发下虚共享带来的性能开销

在高并发情况下，频繁的写屏障很容易发生虚共享（false sharing），从而带来性能开销。

假设CPU缓存行大小为64字节，由于一个卡表项占1个字节，这意味着，64个卡表项将共享同一个缓存行。

HotSpot每个卡页为512字节，那么一个缓存行将对应64个卡页一共64*512=32KB。

如果不同线程对对象引用的更新操作，恰好位于同一个32KB区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。

一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为dirty。

这就是JDK 7中引入的解决方法，引入了一个新的JVM参数-XX:+UseCondCardMark，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。

简单理解如下：

与原来的实现相比，只是简单的增加了一个判断操作。

虽然开启-XX:+UseCondCardMark之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现虚共享问题（false sharing）。





1. CMS收集器（Concurrent Mark Sweep）

   [再谈HotSpot JVM GC机制中的写屏障 - 简书 (jianshu.com)](https://www.jianshu.com/p/0d7a6fcc8f9e)

   标记-清除算法

   主要分为4个流程：

   

   初始标记：仅标记GC Roots 能直接关联到的对象，速度快，需要停顿（STW)

   

   并发标记：进行GC Roots Tracing的过程，整个回收过程中耗时最长，不需要停顿， **<u>并发标记过程中，把赋值的这种新增的引用放到集合中</u>**

   

   重新标记：修正标记期间因用户程序继续运作而导致一些对象的标记产生变动，然后需要更新这些标记，需要停顿， **<u>CMS用的是增量更新的办法</u>**

   > 如何解决漏标问题？比如 A 引用B，B入栈，A变黑，弹出栈，与此同时，A引用C，B取消对C的引用，就产生漏标问题
   >
   > 出现漏标的充要条件是以下两个情况同时发生：
   >
   > 1. mutator使黑色对象直接引用了白色对象；
   > 2. mutator删除了从灰色对象到白色对象之间的所有引用路径。

   > 解决办法：破坏上面两个条件，引入了
   >
   > 强三色不变式：保证永远不会存在黑色对象到白色对象的引用
   >
   > 弱三色不变式：所有被黑色对象引用的白色对象都处于灰色保护状态，<u>即直接或间接从灰色对象可达</u>
   >
   > 强/弱三色不变式都可以通过屏障技术来实现，并且在不同环境下有多种不同的屏障技术。CMS收集器采用增量更新（incremental update）写屏障实现强三色不变式（具体来讲，是Dijkstra等人提出的Dijkstra写屏障）其逻辑是：
   >
   > **拦截使黑色对象引用指向白色对象的mutate操作，强制被引用指向的白色对象置为灰色状态，并将其压入标记栈。**
   >
   > 但是，增量更新写屏障无法探知堆外（如栈上）GC Roots的引用变化，所以CMS收集器在并发标记和预清理完成后，还得做一次重新标记，即再做一次根搜索。

   

   并发清除：不需要停顿

   > 并发清理时，用户线程产生的引用关系变化不会影响其清除吗？比如黑色对象在并发清理过程中指向了白色对象，但白色对象被清除掉了

   > 先来了解三色标记：
   >
   > 白色：表示对象尚未被垃圾收集器访问过。在可达性开始阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，说明该对象不可达。
   > 黑色：表示对象已经被垃圾收集器访问过，且这个对象的指向其他对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，代表它是安全存活的。黑			色对象不可能直接（不经过灰色对象）指向某个白色对象。
   > 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个指向其他对象的引用还没有被扫描过。
   >
   > 所以并发清理时和用户线程并发执行是如何保证安全清理的？
   >
   > 首先，并发清理时，标记过程（初始标记、并发标记、重新标记）已经结束，此时大家想象一下在老年代的所有对象中，现在只有黑色和白色的对象，然后就是：黑色对象不可能直接（不过经过灰色对象）指向某个白色对象，即标记结束时这些白色对象是不可达的。由于没有灰色对象，黑色对象也无法改变对象引用到白色对象上，那就可以说此时清理白色对象是安全的。

