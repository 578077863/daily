# Mysql

## 1. MVCC

[MVCC实现机制 - 路常有 - 博客园 (cnblogs.com)](https://www.cnblogs.com/luchangyou/p/11321607.html)

[(28条消息) MVCC 机制的原理及实现_时间领跑者的博客-CSDN博客_mvcc机制](https://blog.csdn.net/qq_41361506/article/details/108538702)

首先 了解 mvcc 是啥?mvcc中文名叫多版本并发控制机制

有什么用?或者说是为了解决什么问题?

> 解决并发访问数据库的读写冲突问题,通过保存数据在某个时间点的快照使得读取到的记录值符合事务所处的隔离级别
>
> 因为存储引擎使用InnoDB, InnoDB相比 MyISAM ,支持事务和行级锁,但带来的问题是: 脏读,不可重复读,幻读



使用 MVCC的前提: 隔离级别为 读已提交 或 可重复读

即然引入了事务,那么介绍下面内容:

事务的定义 : 

数据库的事务是一个操作序列,包含了一组数据库操作命令,事务把所有的命令作为一个整体一起向系统提交或撤销操作请求,即这一组数据库命令要么都执行,要么都不执行.因此事务是一个不可分割的工作逻辑单元



事务具有哪几个特性:

1. 原子性
2. 一致性
3. 隔离性
4. 持久性



事务有哪几个隔离级别:

[数据库的4种隔离级别 - myseries - 博客园 (cnblogs.com)](https://www.cnblogs.com/myseries/p/10748912.html#:~:text=数据库事务的隔离级别有4种，由低到高分别为Read uncommitted 、Read committed,、Repeatable read 、Serializable 。 而且，在事务的并发操作中可能会出现脏读，不可重复读，幻读。)

1. 读未提交
2. 读已提交
3. 可重复读
4. 可序列化



事务并发带来的问题:

1. 脏读

2. 不可重复读

3. 幻读

4. 丢失更新

   * 第一类丢失更新

     事务A 回滚 , 覆盖了事务B所做的更新

   * 第二类丢失更新

     事务A 提交 , 覆盖了事务B所做的更新





## innoDB和myLSAM









## 为什么Mysql用B+树做索引而不用B-树或红黑树



**B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。**所以从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。



**那么Mysql如何衡量查询效率呢？– 磁盘IO次数。** B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。**这是优点之一。**

**另一个优点是：** B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是**将所有的叶子节点用指针串起来**。这样**遍历**叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。



B树相对于红黑树的区别

**AVL 数和红黑树基本都是存储在内存中才会使用的数据结构**。在大规模数据存储的时候，红黑树往往出现由于**树的深度过大**而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据**磁盘查找存取的次数往往由树的高度所决定**，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。

**数据库系统的设计者巧妙利用了磁盘预读原理**，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证**一个节点物理上也存储在一个页里**，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。







## MySQL是如何实现事务ACID的？

[MySQL是如何实现事务的ACID - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1683618)

1. 原子性

   通过 undo log实现的，undo log能够保证在事务回滚时，能够撤销所有已经执行成功的SQL。 undo属于逻辑日志,记录的是SQL执行相关的信息，当事务对数据库进行修改时，InnoDB会生成与之对应的 undo log，如果事务执行失败或者调用 rollback，导致事务回滚，就会执行undo log中的记录，将数据回滚到之前的样子

   讲人话就是 记录了与执行语句逻辑相反的语句，要回滚就执行

2. 一致性

3. 隔离性

   **事务间的写操作其实是靠MySQL的锁机制来实现隔离的，而事务间的写和读操作是靠MVCC机制来实现的。**

   讲讲MySQL中的锁：

   [(39条消息) Mysql锁详解（行锁、表锁、意向锁、Gap锁、插入意向锁）_Java程序员的进阶之路-CSDN博客_意向锁](https://blog.csdn.net/u010841296/article/details/84204701)

   按功能分：读锁（共享锁，Shared Locks） 和 写锁（排他锁，Exclusive Locks）

   按范围分：表级锁，页面锁，行级锁

   表级锁：意向锁（Intention Locks）

   行级锁：记录锁（Record Locks），间隙锁（Gap Locks），临键锁（Next-Key Locks）

   **讲讲MVCC机制:**

   

4. 持久性

   事务一旦提交，对数据库的改变就是永久性的

   MySQL的数据都是最终都是存放到磁盘中，如果MySQL的操作都是通过读写磁盘来进行的话，磁盘I/O效率低，所以InnoDB为MySQL提供了缓冲池（Buffer Pool），Buffer Pool中包含了磁盘中部分数据页的映射

   当从数据库读取数据时，会先检查缓冲池中有没有，如果有，则读取，没有就从磁盘中读取后放入缓冲池中。 

   当向数据库中写数据时，会先写到缓冲池中，缓冲池更新的数据会定期刷新到磁盘中（这个过程称为刷脏页）

   虽然引入缓冲池 提高了 读写数据的效率，但如果缓冲池中的脏页还没来得及刷新到磁盘中，MySQL就宕机，这就导致数据丢失，为了解决这个缓存的一致性问题，又引入了 redo log，通过两阶段提交解决了数据完整性问题

   那你讲讲两阶段提交：）

   对缓冲池中的数据进行修改的时候，通过redo log记录本次操作，此使redo log 处于prepare状态，接着将这个操作的binlog写入磁盘，再提交事务，提交事务时会通过fsync接口对redo log 进行刷盘。

   （ redo log 采用的预写的方式记录日志，即先记录日志，再更新Buffer Pool，这样就强行的保证了，数据只要保存在了redo log中就一定会存储到磁盘中了。）

   这里有个问题：redo log 和刷脏页都是写磁盘，为什么不直接刷脏页？

   主要原因就是redo log比刷脏快很多。

   第一点是，redo log是追加操作日志，是顺序IO；而刷脏是随机IO，因为每次更新的数据不一定是挨着的，也就是随机的。 

   第二点是，刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，对一个页上的修改，都要整个页都刷到磁盘中；而redo log只包含真正的需要写入磁盘的操作日志。

   

   MySQL还有一个记录操作的日志，叫binlog ，那么redo log和binlog又有什么区别呢？

   * **第一点作用上的区别**： redo log是用来记录更新缓存的，为了保证MySQL就算宕机也不会影响事务的持久性；binlog是用来记录什么时间操作了什么，主要有时间点，可以保证将数据恢复到某个时间点，也有用于主从同步数据的。
   * **第二点层次上的区别**： redo log是存储引擎InnoDB实现的（MyISAM就没有redo log），而binlog是在MySQL服务器层面存在的任何其他存储引擎也有binlog。 存储内容上，redo log是物理日志，基于磁盘的数据页，binlog是逻辑日志，存储的一条执行SQL。
   * **第三点写入时机的区别**： redo log 在默认情况下是在事务提交时，进行刷盘的；可以通过参数：`innodb_flush_log_at_trx_commit` 来改变策略，可以不用等到事务提交时才进行刷盘。 如：可以设置成每秒提交一次。 binlog是在事务提交时写入。



SQL 标准定义了四个隔离级别,对应这是否能解决 脏读,不可重复读,幻读

1. 读未提交
2. 读已提交
3. 可重复读
4. 可串行化

Mysql InnoDB存储引擎默认支持的隔离级别是 可重复读,与SQL标准不同的是InnoDB存储引擎在 可重复读这一事务隔离级别下使用 Next-Key Lock 锁算法,避免了幻读的产生

InnoDB存储引擎在分布式事务的情况下一般用 可串行化 隔离级别





## 锁



* 共享锁(读锁)：其他事务可读，但不能写
* 排他锁（写锁）：其他事务不能读，也不能写

- 对于UPDATE、DELETE、INSERT语句，InnoDB会自动将涉及的数据集添加排他锁(X锁)(也就是行锁,如果不碰到该行锁,比如锁第10行,我查1-9 ,11-14都没问题)







### 两阶段锁协议

InnoDB中,事务持有记录的行锁都是在 commit的时候才是释放的,也就是说行锁是需要的时候加上,不需要的时候并不能立即释放,而是要等到事务结束才释放







聚簇索引和非聚簇索引的区别？

MyISAM: 索引文件和数据文件是分离的(索引按照B+树存储），B+树叶节点的data域存放的是 **数据记录的地址**。 在使用B+树算法搜索索引的时候，如果指定的key存在，就取出data域中存储的数据地址，根据数据地址去数据文件读取相应的数据记录



非聚簇索引简单讲就是 数据文件与索引文件分开，索引结构的叶子节点data域存放了数据文件对应的地址



聚簇索引就是 数据文件本身就是索引文件，索引结构的叶子节点的data域保存了完整的数据记录





## 覆盖索引

说说覆盖索引

查询字段被建立的索引覆盖，所需的数据可直接从索引中取得，不必回表（只要有一个字段没有建立索引就会做全表扫描）。

所以我们须尽可能在 select后只写必要的查询字段，增加索引覆盖的几率



如果查询的是普通索引，即辅助索引，叶子节点存储的是主键+某一字段值，那最终还是要回表，

说说什么是回表？回表就是通过辅助索引拿到对应主键的值，然后再去主索引的B+树再查找一次



