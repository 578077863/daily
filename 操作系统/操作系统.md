# 操作系统

## 1. 进程与线程的区别

1. 拥有资源

   > 进程是资源分配的基本单位, 但是线程不拥有资源,线程可以访问进程的资源

2. 调度

   > 线程是独立调度的基本单位,在同一个进程中,线程的切换不会引起进程切换,但从一个进程的线程切换到另一个进程的线程会引起进程切换

3. 系统开销

   > 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

   >线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。



### 线程的状态

1. 新建状态
2. 就绪状态
3. 运行状态
4. 阻塞状态
5. 死亡状态

[(33条消息) 线程的5种状态详解_老猫的博客-CSDN博客_线程状态](https://blog.csdn.net/xingjing1226/article/details/81977129)





## 进程

### 进程五态

created  ready running waiting terminated

java 则是 new, Runnable ,Timed Waiting, Waiting, Blocked 	terminated



### 调度算法

#### 批处理系统

追求吞吐量和周转时间(从提交到终止的时间)

FCFS

SJF

SRTN



#### 交互式系统

追求快速响应

时间片轮转

优先级调度

多级反馈队列



### 同步与互斥

同步: 多个进程访问同一个资源有一定的先后执行顺序

互斥: 多个进程在同一时刻只有一个进程能进入临界区







### 进程通信

管道

匿名管道

ps -ef |grep redis  中的 | 就是管道的意思,把前一条命令的输出作为后一条命令的输入



命名管道(FIFO)

> mkfifo test 创建一个名为test的命名管道
>
> echo "this is a pipe">test //写数据
>
> cat<test //读数据



管道的通知机制类似缓存,就像一个进程把数据放在**某个缓存区域**,然后等着另一个进程去拿,并且管道是单向传输的



优缺点:效率低下,发送消息的进程只能等到数据被取走后才能返回,所有管道不适用于通信频繁地进程

能保证我们的数据已经被其他进程拿走了





消息队列

A进程把数据放到某个内存中,然后就返回,B进程需要的时候就去对应内存取

缺点: A进程发送的数据占的内存比较大,并且两进程通信较频繁,就不太合适,因为发送消息(拷贝)这个过程需要花很多时间来读内存



共享内存

解决了发送/拷贝消息所耗的时间开销

让两进程各拿出一块虚拟地址空间,映射到相同的物理内存



信号量

信号量是一个整型变量, 可以对其执行 down 和 up操作(两个都是原语,屏蔽操作), 也就是常量的P和V操作.

down : 如果信号量大于0,执行 -1操作,如果信号量等于0,进程睡眠,等待信号			量大于0

up : 对信号量执行+1操作,唤醒睡眠进程让其完成down操作



socket

解决不同主机上的进程



## 内存管理

### 虚拟内存

### 页面置换算法

程序在运行过程中,如果要访问的页面不在内存,就会发生 **缺页中断**从而将该页调入内存中,若此时内存已无空闲空间,系统必须从内存中调出一个页面到磁盘对换区中腾出空间

该算法目标是使得页面置换率(缺页率)最低



1. OPT

2. FIFO

3. LRU

   一个页面被访问,就将其移到链表头,这样保证链表尾是最近最少使用的

4. 第二次机会页面置换算法

   FIFO变种,检查链表头的页面的R位,如果为1,就将R位清0,放到链表的尾端并修改其装入时间,然后再继续检查链表头,如果全部页面都访问过,就退化成FIFO.

5. NRU

   页面有两个状态位R和M,被访问R = 1, 被修改 M = 1,其中 R会定时清零,页面会被分为4类

   清除优先级: 

   R = 0, M = 0

   R = 0. M = 1

   R = 1 M = 0

   R = 1 M = 1

6. 时钟页面置换算法

   第二次机会页面置换算法需要在链表中移动页面,降低效率,我们可以采用环形链表将页面连接起来,用一个指针指向最老的页面

   R = 0,替换

   R = 1 将R设为0,并将指针前进



### 

## 死锁

### 概念

两个及以上的进程,在程序执行过程中,因争夺资源而造成的一种互相等待现象,若不外力作用,他们将无法推进下去



### 造成死锁的原因

1. 系统资源不足或分配不当
2. 进程推进顺序不合适



### 必要条件

1. 互斥条件
2. 占有和等待条件
3. 不剥夺条件
4. 循环等待条件



### 解决方法

1. 鸵鸟策略

   不管,因为解决死锁的代价高

2. 死锁检测与恢复

   检测:

   不阻止死锁发生

   * 深度搜索-进程资源图
   * 标记法

   恢复:

   * 资源剥夺法
   * 进程回滚法
   * 杀死进程

3. 死锁预防

   * 破坏互斥条件
   * 破坏占有并等待条件
   * 破坏不剥夺条件
   * 破坏循环等待条件

4. 死锁避免

   * 银行家算法

     

   
