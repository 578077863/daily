
## 回文题
#### 647. 回文子串
给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。

回文字符串 是正着读和倒过来读一样的字符串。

子字符串 是字符串中的由连续字符组成的一个序列。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

```java

class Solution {
    public int countSubstrings(String s) {

        int res = 0;

        for(int i = 0; i < s.length(); i++){

            int s1 = extend(s, i, i);
            int s2 = extend(s, i, i + 1);

            res = res + s1 + s2;
        }

        return res;
    }


    private int extend(String s, int left, int right){
        
        int num = 0;
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){
            num++;
            left--;right++;
        }

        return num;
    }
}
```



## 归并
#### 剑指 Offer 51. 数组中的逆序对
```java
class Solution {

    int res = 0;

    public int reversePairs(int[] nums) {

        sort(nums, 0, nums.length - 1);

        return res;
    }


    private void sort(int[] nums, int left, int right){

        if(left >= right) return;

        int mid = left + (right - left) / 2;

        sort(nums, left, mid);
        sort(nums, mid + 1, right);

        mergeSort(nums, left, mid, right);
    }

    private void mergeSort(int[] nums, int left, int mid, int right){

        int[] temp = new int[right - left + 1];

        int index = 0;

        int temp1 = left, temp2 = mid + 1;

        while(temp1 <= mid && temp2 <= right){
            if(nums[temp1] <= nums[temp2]){
                temp[index++] = nums[temp1++];
            }else{

                res += (mid - temp1 + 1);
                temp[index++] = nums[temp2++];
            }
        }

        while(temp1 <= mid) temp[index++] = nums[temp1++];

        while(temp2 <= right) temp[index++] = nums[temp2++];

        for(int k = 0; k < temp.length; k++){
            nums[k + left] = temp[k];
        }

        return;
    }
}
```


## 二分法
#### 34. 在排序数组中查找元素的第一个和最后一个位置
```java

class Solution {
    public int[] searchRange(int[] nums, int target) {

        // [,)
        int a = binaryLeft(nums, target);
        int b = binaryRight(nums, target);

        return new int[]{a,b};
    }

    private int binaryLeft(int[] nums, int target){

        int left = 0, right = nums.length;

        while(left < right){

            int mid = left + (right - left) / 2;

            if(nums[mid] > target) right = mid;
            else if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }

        if(left == nums.length) return -1;

        return nums[left] == target? left : -1;
    }

    private int binaryRight(int[] nums, int target){

        int left = 0, right = nums.length;

        while(left < right){

            int mid = left + (right - left) / 2;

            if(nums[mid] < target) left = mid + 1;
            else if(nums[mid] > target) right = mid;
            else left = mid + 1;
        }

        if(left == 0) return -1;   // left == 0 意味着 nums[0] 都 > target, 因为如果 == 就会右移
        return nums[left - 1] == target? left - 1 : -1;
    }
}
```


#### 392. 判断子序列

```java
class Solution {
    public boolean isSubsequence(String s, String t) {

        int s_index = 0, t_index = 0;

        while(s_index < s.length() && t_index < t.length()){
            if(s.charAt(s_index) == t.charAt(t_index)) s_index++;

            t_index++;
        }

        return s_index == s.length();
    }
}

class Solution {
    public boolean isSubsequence(String s, String t) {

        int len1 = s.length(), len2 = t.length();

        int[][] dp = new int[len1 + 1][len2 + 1];

        for(int i = 1; i <= len1; i++){
            for(int j = 1; j <= len2; j++){

                if(s.charAt(i - 1) == t.charAt(j - 1)) dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = dp[i][j - 1];
            }
        }

        if(dp[len1][len2] == len1) return true;

        return false;
    }
}

```




## dp
#### 62. 不同路径
```java

class Solution {
    public int uniquePaths(int m, int n) {

        int[][] dp = new int[m][n];

        for(int i = 0; i < m; i++){
            dp[i][0] = 1;
        }

        for(int i = 0; i < n; i++){
            dp[0][i] = 1;
        }

        for(int i = 1; i < m; i++){
            for(int j = 1; j < n; j++){

                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
}
```

#### 64. 最小路径和

## 二叉树
#### 114. 二叉树展开为链表


#### 96. 不同的二叉搜索树



## 其他
#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)