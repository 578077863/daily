# 字节
[字节后端日常实习一面_笔经面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/821404?source_id=profile_create_nctrack&channel=-1)
1. JVM内存区域，垃圾回收过程，怎么查看垃圾回收过程
```markdown
内存区域以线程共享和独占来入手

垃圾回收过程以垃圾回收算法入手,再介绍CMS垃圾回收过程

查看垃圾回收算法:java  -XX:+PrintCommandLineFlags  -version, 最后一个 -XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old
```

2. 线程池参数，拒绝策略，工作流程
```markdown


```


3. 线程同步方法，创建线程方法，Runable和Callable区别

```markdown
同步方法:(得补补)
1.synchronized
2.volatile
3.ThreadLocal


创建线程方法:
1.继承Thread类
2.实现Runnable接口
3.实现Callable接口,通过Future拿到返回值

区别:
从使用角度来看: 后者能返回值,前者不能
从构造角度来看: Runnable方法的执行可以看做是Thread来执行的,而Callable的call方法的执行是FutureTask来执行的,中间加了一层,使得我们能通过一系列方法改 
             进原本run方法不能返回值的问题
```

4. volatile作用
```markdown
从java关键字使用的层面看,volatile关键字保证了内存可见性,这点synchronized也同样具备

从JMM层面看, java内存模型是共享内存模型,对变量的处理都是对工作内存中的变量进行处理,若变量不在工作内存,则去主内存读取.这使得一个变量可能存在多个线程的工作内存中,volatile就是使得一个线程对该变量的修改可以使得其他线程工作内存中该变量的副本失效,若需要读取该变量就只能重新去主内存读取

再往下看,volatile做了什么操作来实现这个功能:答案就是volatile,volatile修饰的变量赋值后汇编层面的指令加上了lock前缀,使得其他处理器若存在该变量则对应的block失效.

再往下看,MESI缓存一致性协议如果严格执行的话缓存一致性是没问题的,但效率太低了,每次修改变量时总得通知其他cpu当前要对某个变量修改,然后等待其他cpu回应ack,这期间要修改的cpu是空闲的,而其他cpu得判断自己高速缓存是否存在该变量,有就将该block失效,再返回ack.为了提高效率映入了写存储区和失效队列.这就导致了一个线程对一个变量的修改结果其他线程并不能马上看到,出现线程安全问题
```


5. MySQL索引结构，联合索引，隔离级别(RC和RR区别），mvcc原理
```markdown

MySQL索引分为聚合索引和非聚合索引,



隔离级别: 1.读未提交 2.读已提交 3.可重复读 4.串行化

RC 和 RR 的区别就是 关于读视图是每一次 select 生成 还是 第一次select 生成

对于快照读 都是 用 MVCC + undo log 链来完成
对于当前读, RC 用 行锁 , RR使用 next-key lock

MVCC原理就是每一次select 创建一个读视图
```

6. Redis 基本数据结构，怎么存储对象
```markdown
基本数据结构:
	1.SDS
	2.字典
	3.压缩列表
	4.quickList
	5.skipList


```


7. Spring IOC 和 AOP


8. LRU