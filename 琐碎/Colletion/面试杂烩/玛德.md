# 字节
[字节后端日常实习一面_笔经面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/821404?source_id=profile_create_nctrack&channel=-1)
1. JVM内存区域，垃圾回收过程，怎么查看垃圾回收过程
```markdown
内存区域以线程共享和独占来入手

垃圾回收过程以垃圾回收算法入手,再介绍CMS垃圾回收过程

查看垃圾回收算法:java  -XX:+PrintCommandLineFlags  -version, 最后一个 -XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old
```

2. 线程池参数，拒绝策略，工作流程
```markdown


```


3. 线程同步方法，创建线程方法，Runable和Callable区别

```markdown
同步方法:(得补补)
1.synchronized
2.volatile
3.ThreadLocal


创建线程方法:
1.继承Thread类
2.实现Runnable接口
3.实现Callable接口,通过Future拿到返回值

区别:
从使用角度来看: 后者能返回值,前者不能
从构造角度来看: Runnable方法的执行可以看做是Thread来执行的,而Callable的call方法的执行是FutureTask来执行的,中间加了一层,使得我们能通过一系列方法改 
             进原本run方法不能返回值的问题
```

4. volatile作用
```markdown
从java关键字使用的层面看,volatile关键字保证了内存可见性,这点synchronized也同样具备

从JMM层面看, java内存模型是共享内存模型,对变量的处理都是对工作内存中的变量进行处理,若变量不在工作内存,则去主内存读取.这使得一个变量可能存在多个线程的工作内存中,volatile就是使得一个线程对该变量的修改可以使得其他线程工作内存中该变量的副本失效,若需要读取该变量就只能重新去主内存读取

再往下看,volatile做了什么操作来实现这个功能:答案就是volatile,volatile修饰的变量赋值后汇编层面的指令加上了lock前缀,使得其他处理器若存在该变量则对应的block失效.

再往下看,MESI缓存一致性协议如果严格执行的话缓存一致性是没问题的,但效率太低了,每次修改变量时总得通知其他cpu当前要对某个变量修改,然后等待其他cpu回应ack,这期间要修改的cpu是空闲的,而其他cpu得判断自己高速缓存是否存在该变量,有就将该block失效,再返回ack.为了提高效率映入了写存储区和失效队列.这就导致了一个线程对一个变量的修改结果其他线程并不能马上看到,出现线程安全问题
```


5. MySQL索引结构，联合索引，隔离级别(RC和RR区别），mvcc原理
```markdown

MySQL索引分为聚合索引和非聚合索引,



隔离级别: 1.读未提交 2.读已提交 3.可重复读 4.串行化

RC 和 RR 的区别就是 关于读视图是每一次 select 生成 还是 第一次select 生成

对于快照读 都是 用 MVCC + undo log 链来完成
对于当前读, RC 用 行锁 , RR使用 next-key lock

MVCC原理就是每一次select 创建一个读视图
```

6. Redis 基本数据结构，怎么存储对象
```markdown
基本数据结构:
	1.SDS
	2.字典
	3.压缩列表
	4.quickList
	5.skipList


```


7. Spring IOC 和 AOP


8. LRU





```MARKDOWN

字节大数据基础架构部门的实习生

字节面经 一面 2.17 
1. 自我介绍
2. 接口和抽象类的区别
3. 了解过啥设计模式
4. 单例模式是啥
5. 工厂模式的作用，为什么要用工厂模式？
	解耦, 把对象的创建和使用的过程分开(就是Class A 想调用Class B,那么只是调用B的方法，而至于B的实例化，就交给工厂类)
6. 建造者模式的实现方式
7. 在设计模式中你使用抽象类还是接口比较多
8. 了解哪些Java锁
9. 死锁的必要条件
10. Mysql索引了解吗(那时候不会就直接说不会了)
11. MySql事务隔离级别
12. 说一下你用过的Java框架
	(说了Spring 的 ioc/aop 还没说aop就下一问了)
13. 项目中如何使用git和maven的
代码题:
 	1. 写一个快排
 	 	1. 快排是否稳定
 	 	2. 什么情况下会退化
 	 	3. 如何优化
 	 	4. 时间复杂度
 	2. 写一个二分查找
 	 	1. 复杂度
代码题写的太快了, 然后他说时间还没到在问几个问题
14. 了解分布式吗(NO)
15. 说一下Java基础类型
16. 为什么int是2的31次方
17. 了解Docker吗(NO)
13. 什么是Java同步和异步

反问:
	1. 部门的业务
	2. 对我的评价
	
字节跳动二面 2.18
1. 进程之间的通信
 1. 管道通信
 2. 命名管道通信
 3. 消息队列
 4. 共享内存
 5. 信号量
 6. 套接字
 7. 信号
 3. 说一下你了解的锁
2. 说一下synchronized 和 reentranlock
3. 介绍一下Reentrantlock
4. 单例模式中变量前加的关键字(volatile)
5. 单例模式并发下实现方式
 1. 双重检查锁(DCL)
 2. 内部类
 3. 枚举类
6. volatile的作用是什么
 1. 防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性
 2. 会主动刷新存储 
7. 聚集索引和非聚集索引的区别
  1.聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。**
  2.非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引**
8. mysql三大范式说一个你了解的
9. mysql的ACID是什么
10. Maven包冲突怎么解决
11. 介绍一下HashMap
12. HashMap扩容了解吗?说一下扩容因子(loadFactor)
13. 红黑树的特点, 为啥红黑树比较二叉树快
  - 每条路上黑节点的数量是固定的, 高度限制搜索快
  - 红黑树特点 :
   1. 每个节点非红即黑；
   2. 根节点总是黑色的；
   3. 每个叶子节点都是黑色的空节点（NIL节点）；
   4. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；
   5. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。
14. Redis为什么快?
	直接操作内存 单线程没有多线程创建销毁的开销 IO多路复用
15. Redis缓存机制(我觉得应该是处理流程)
算法题:
	LeetCode 25 困难
	K个一组反转链表改版(最后n个不足也反转)
	
字节面经 三面Leader面 - 2.21(挂)

1. Object类里有什么方法
2. 有用过Object类中相关锁的方法吗
  1. wait
  2. notify
  3. notifyAll
3. Java垃圾回收的方法新生代和老年代的不同的算法
4. 设计模式中有用到锁的模式
5. 如果没有使用两个锁单例会有什么问题
6. MySQL使用还是对他的原理有什么了解
7. 使用JavaEE开发过一些项目吗
8. 在开发项目中有什么问题吗, 然后最后解决了的
算法题:
LeetCode 101简单
​	1. 对称二叉树
还是题刷的不够多,没写到这题也没多写二叉树,我居然用BFS写的
```



https://www.nowcoder.com/discuss/840270





## 操作系统
#### 产生死锁的条件
	互斥，占有并保持，不可剥夺，循环等待
#### 进程通信
	管道：匿名管道，有名管道
	信号量
	信号
	消息队列
	内存映射
	套接字

#### 线程通信
	线程间的通信目的主要是用于线程同步。所以线程没有像进程通信中的用于数据交换的通信机制。
	锁机制，信号量机制，信号机制
#### 进程同步
	进程同步的基础是通信，从通信中找到能设置状态变化并且其他进程能感知到。只要都共享的读取某个东西，就可以通过修改这个东西的状态实现同步。临界区，信号量，事件对象
	临界区，信号量，事件对象


#### 页面调度算法
	先进先出，最佳置换，最近最久未使用，Clock，改进Clock




## redis
#### 内存淘汰策略
	8种：1种不淘汰 7种淘汰 4种在设置了过期时间的数据中进行淘汰，3种在所有数据范围内进行淘汰

#### 过期建删除策略
	惰性删除，定期删除

#### 数据结构
##### SDS
	主要成员：一个是字符串长度，一个char[]数组，一个字符数组中未使用的字节数

##### 字典
	两个哈希表，渐进式rehash

##### 跳表（他妈的太难了这个）


##### 整数集合
	不会出现重复元素，是redis用于保存整数值的集合抽象数据结构，可以保存16，32，64位的整数值


##### 压缩列表
	当一个列表只包含少量列表项，并且都是小的整数值和短字符串，那么它便适合使用压缩列表进行实现，因此其特点是节省内存
	组成：整个列表占用的字节数，表尾节点到起始地点的偏移量，节点数量，各个节点，用于标识末尾的标志符号
	节点组成：前一个节点的长度，节点编码，节点值
	若前一个节点小于254，则prelen为1字节，否则5字节


#### 数据类型
	字符串对象：int，embstr，row(sds)
	列表对象：quicklist（多个ziplist通过前后节点的指针连接起来）
	哈希对象：ziplist或dict
	集合对象：intset或dict
	有序集合对象：ziplist，skiplist&dict(O1获取成员的分值，Olongn进行范围排序操作)


