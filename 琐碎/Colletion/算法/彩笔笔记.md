
## 贪心法

#### 179. 最大数
[179. 最大数](https://leetcode-cn.com/problems/largest-number/)

```java
给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] ss = new String[n];
        for (int i = 0; i < n; i++) ss[i] = "" + nums[i];
        Arrays.sort(ss, (a, b) -> {
            String sa = a + b, sb = b + a ;
            return sb.compareTo(sa);
        });
        
        StringBuilder sb = new StringBuilder();
        for (String s : ss) sb.append(s);
        int len = sb.length();
        int k = 0;
        while (k < len - 1 && sb.charAt(k) == '0') k++;
        return sb.substring(k);
    }
}
```


## 滑动窗口

#### 3. 无重复字符的最长子串
[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```java
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

class Solution {
    public int lengthOfLongestSubstring(String s) {

        int left = 0, right = 0;

        Map<Character, Integer> map = new HashMap<>();

        int maxLen = 0;

        char[] chars = s.toCharArray();

        while(right < s.length()){
            
            if(map.containsKey(chars[right])){

                // abcba  再遇到最后一个a的时候,left指向c,但从map中取到a的位置却在0.所以要跟现在比较一下
              left = Math.max(left, map.get(chars[right]) + 1);
            }
            map.put(chars[right], right);

            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    }
}
```



## 链表

#### 2. 两数相加
[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 在两条链表上的指针
        ListNode p1 = l1, p2 = l2;
        // 虚拟头结点（构建新链表时的常用技巧）
        ListNode dummy = new ListNode(-1);
        // 指针 p 负责构建新链表
        ListNode p = dummy;
        // 记录进位
        int carry = 0;
        // 开始执行加法，两条链表走完且没有进位时才能结束循环
        while (p1 != null || p2 != null || carry > 0) {
            // 先加上上次的进位
            int val = carry;
            if (p1 != null) {
                val += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                val += p2.val;
                p2 = p2.next;
            }
            // 处理进位情况
            carry = val / 10;
            val = val % 10;
            // 构建新节点
            p.next = new ListNode(val);
            p = p.next;
        }
        // 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next;
    }
}


```




## 字符串


### 5. 最长回文子串(中心扩散法和dp)
[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java

给你一个字符串 `s`，找到 `s` 中最长的回文子串。`s` 仅由数字和英文字母组成

class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            String s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            String s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

    String palindrome(String s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.length()
                && s.charAt(l) == s.charAt(r)) {
            // 向两边展开
            l--;
            r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r);
    }
}


```



## 二叉树

[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val > q.val) { // 保证 p.val < q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        }
        while(root != null) {
            if(root.val < p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val > q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        }
        return root;
    }
}

```


## 前缀和
#### 剑指 Offer 66. 构建乘积数组
[剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

```java
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。




class Solution {
    public int[] constructArr(int[] a) {

        /**
            两个数组 A[i]: a[0] ~ a[i - 1]  B[i]: a[i + 1] ~ a[len - 1] 
         */
        if(a == null || a.length == 0) return new int[0];
        int[] A = new int[a.length];
        int[] B = new int[a.length];
        A[0] = B[a.length - 1] = 1;

        for(int i = 1; i < a.length; i++){
            A[i] = A[i - 1] * a[i - 1];
        }

        for(int i = a.length - 2; i >= 0; i--){
            B[i] = B[i + 1] * a[i + 1];
        }

        int[] res = new int[a.length];

        for(int i = 0; i < a.length; i++){
            res[i] = A[i] * B[i];
        }        

        return res;
    }
}

```



## 数学题

#### 剑指 Offer 62. 圆圈中最后剩下的数字
[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```java

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。



class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推,最后一轮的位置
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}



假设我们最好剩余的数字是N。

执行完“删除第三个元素”的操作后，N在新数组中的位置P的意义是什么？ ——它表示，在新数组中，N前面有还有P个元素。那么，在当前数组中，N前面一定有“P+3”个元素。 明白了这一点即可开始倒推。

最后一轮：当前有1个元素。N的位置是0；

倒数第2轮：当前有2个元素。已知在执行完“删除第三个元素”后，N在新数组中的位置是0。则说明在本轮中N前面有0+3=3个元素，所以N的位置是3，然而本轮只有2个元素，所以N的实际位置是（0+3）%2=1；

倒数第3轮：当前有3个元素。已知在执行完“删除第三个元素”后，N’在新数组中的位置是1。说明此刻，N前面有1+3=4个元素，所以N的位置是4。而当前数组只有3个元素，故实际位置是（1+3）%3=1；
```


#### 剑指 Offer 61. 扑克牌中的顺子
[剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```java

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。


class Solution {
    public boolean isStraight(int[] nums) {
        int joker = 0;
        Arrays.sort(nums); // 数组排序
        for(int i = 0; i < 4; i++) {
            if(nums[i] == 0) joker++; // 统计大小王数量
            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false
        }
        return nums[4] - nums[joker] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

class Solution {
    public boolean isStraight(int[] nums) {
        Set<Integer> repeat = new HashSet<>();
        int max = 0, min = 14;
        for(int num : nums) {
            if(num == 0) continue; // 跳过大小王
            max = Math.max(max, num); // 最大牌
            min = Math.min(min, num); // 最小牌
            if(repeat.contains(num)) return false; // 若有重复，提前返回 false
            repeat.add(num); // 添加此牌至 Set
        }
        return max - min < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

```



## 二分法


#### 剑指 Offer 53 - II. 0～n-1中缺失的数字
[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。


class Solution {
    public int missingNumber(int[] nums) {
					//可能插在最后一个位置
        int left = 0, right = nums.length;

        while(left < right){

            int mid = left + (right - left) / 2;

            if(nums[mid] != mid){
                right = mid;
            }else{
                left = mid + 1;
            }
        }

        return left;
    }
}

```