
## 贪心法

#### 179. 最大数
[179. 最大数](https://leetcode-cn.com/problems/largest-number/)

```java
给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] ss = new String[n];
        for (int i = 0; i < n; i++) ss[i] = "" + nums[i];
        Arrays.sort(ss, (a, b) -> {
            String sa = a + b, sb = b + a ;
            return sb.compareTo(sa);
        });
        
        StringBuilder sb = new StringBuilder();
        for (String s : ss) sb.append(s);
        int len = sb.length();
        int k = 0;
        while (k < len - 1 && sb.charAt(k) == '0') k++;
        return sb.substring(k);
    }
}
```


## 滑动窗口

#### 3. 无重复字符的最长子串
[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```java
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

class Solution {
    public int lengthOfLongestSubstring(String s) {

        int left = 0, right = 0;

        Map<Character, Integer> map = new HashMap<>();

        int maxLen = 0;

        char[] chars = s.toCharArray();

        while(right < s.length()){
            
            if(map.containsKey(chars[right])){

                // abcba  再遇到最后一个a的时候,left指向c,但从map中取到a的位置却在0.所以要跟现在比较一下
              left = Math.max(left, map.get(chars[right]) + 1);
            }
            map.put(chars[right], right);

            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    }
}
```



## 双指针
#### 11. 盛最多水的容器
[11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```java

给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
            // [left, right] 之间的矩形面积
            int cur_area = Math.min(height[left], height[right]) * (right - left);
            res = Math.max(res, cur_area);
            // 双指针技巧，移动较低的一边
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
}

```

#### 42. 接雨水
[42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
```java


给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

```


#### 剑指 Offer 11. 旋转数组的最小数字
[剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

```java

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。

给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  

注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

class Solution {
    public int minArray(int[] numbers) {

        int left = 0, right = numbers.length - 1;

        while(left < right){
            int mid = left + (right - left) / 2;

            if(numbers[mid] == numbers[right]) right--;
            else if(numbers[mid] > numbers[right]) left = mid + 1;
            else right = mid;
        }

        return numbers[left];
    }
}


```

## 链表

#### 2. 两数相加
[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 在两条链表上的指针
        ListNode p1 = l1, p2 = l2;
        // 虚拟头结点（构建新链表时的常用技巧）
        ListNode dummy = new ListNode(-1);
        // 指针 p 负责构建新链表
        ListNode p = dummy;
        // 记录进位
        int carry = 0;
        // 开始执行加法，两条链表走完且没有进位时才能结束循环
        while (p1 != null || p2 != null || carry > 0) {
            // 先加上上次的进位
            int val = carry;
            if (p1 != null) {
                val += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                val += p2.val;
                p2 = p2.next;
            }
            // 处理进位情况
            carry = val / 10;
            val = val % 10;
            // 构建新节点
            p.next = new ListNode(val);
            p = p.next;
        }
        // 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next;
    }
}


```


#### 21. 合并两个有序链表
[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if(list1 == null) return list2;
        if(list2 == null) return list1;

        if(list1.val < list2.val){
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        }

        list2.next = mergeTwoLists(list1,list2.next);

        return list2;
    }
}
```


#### 206. 反转链表
[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
```java
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

class Solution {
    public ListNode reverseList(ListNode head) {

        if(head == null || head.next == null) return head;

        ListNode last = reverseList(head.next);

        head.next.next = head;

        head.next = null;

        return last;
    }
}
```

#### 92. 反转链表 II
[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
```java
递归
// 记录后节点
    ListNode last;
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(left==1){
            // 反转链表的内容
            return reverse(head,right);
        }
        ListNode newhead=reverseBetween(head.next,left-1,right-1);
        head.next=newhead;
        return head;
    }

    ListNode reverse(ListNode head,int count){
        // base case
        // 递归到最后一个我们需要的节点了 记录他的后节点 last
        if(count==1){
            last=head.next;
            return head;
        }
        ListNode cur=reverse(head.next,count-1);
        // 后续遍历位置 从最后往前翻转
        head.next.next=head;
        head.next=last;
        return cur;
    }



遍历，头插法
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        // 定义一个dummyHead, 方便处理
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;

        // 初始化指针
        ListNode g = dummyHead;
        ListNode p = dummyHead.next;

        // 将指针移到相应的位置
        for(int step = 0; step < m - 1; step++) {
            g = g.next; p = p.next;
        }

        // 头插法插入节点
        for (int i = 0; i < n - m; i++) {
            ListNode removed = p.next;
            p.next = p.next.next;

            removed.next = g.next;
            g.next = removed;
        }

        return dummyHead.next;
    }
}

```


#### 25. K 个一组翻转链表
[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```java

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

进阶：

你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。


迭代
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a, b;
        a = b = head;
        for (int i = 0; i < k; i++) {
            // 不足 k 个，不需要反转，base case  //若是没达到 b)之前为 null，则不用转了， 若到达 b)为null，说明前面刚好为k个
            if (b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverse(a, b);
        // 递归反转后续链表并连接起来   // a变为末尾，指向下一段的头
        a.next = reverseKGroup(b, k);
        return newHead;
    }

    /* 反转区间 [a, b) 的元素，注意是左闭右开 */
    ListNode reverse(ListNode a, ListNode b) {
        ListNode pre, cur, nxt;
        pre = null;
        cur = a;
        nxt = a;
        // while 终止的条件改一下就行了
        while (cur != b) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        // 返回反转后的头结点
        return pre;
    }
}



```



#### 114. 二叉树展开为链表
[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
```java

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。


class Solution {
    // 定义：将以 root 为根的树拉平为链表
    public void flatten(TreeNode root) {
        // base case
        if (root == null) return;
        // 先递归拉平左右子树
        flatten(root.left);
        flatten(root.right);

        /****后序遍历位置****/
        // 1、左右子树已经被拉平成一条链表
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 2、将左子树作为右子树
        root.left = null;
        root.right = left;

        // 3、将原先的右子树接到当前右子树的末端
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    }
}
```


## 字符串


#### 5. 最长回文子串(中心扩散法和dp)
[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java

给你一个字符串 `s`，找到 `s` 中最长的回文子串。`s` 仅由数字和英文字母组成

class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            String s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            String s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

    String palindrome(String s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.length()
                && s.charAt(l) == s.charAt(r)) {
            // 向两边展开
            l--;
            r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r);
    }
}


```


#### 翻转单词顺序
[剑指 Offer 58 - I. 翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)


```java
class Solution {
    public String reverseWords(String s) {
        if(s == null || s.length() == 0) return "";
        StringBuilder stringBuilder = new StringBuilder();
        int right = s.length() - 1;
        int left = right;
        while (left >= 0) {
            //过滤掉空格
            while (right >= 0 && s.charAt(right) == ' ')
                right--;
            left = right;
            while (left >= 0 && s.charAt(left) != ' ')
                left--;
            //截取单词,然后把它加入到StringBuilder中，然后加个空格
            stringBuilder.append(s.substring(left + 1, right + 1) + " ");
            //下一个单词开始的位置
            right = left;
        }
        //转化为字符串，并去掉最后加的空格
        int index = stringBuilder.length() - 1;

        while(index >= 0 && stringBuilder.charAt(index) == ' ') index--;
        //if(index < 0) return "";
        return stringBuilder.substring(0, index + 1);
    }
}

```





#### 567. 字符串的排列
[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)
```java
给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。

换句话说，s1 的排列之一是 s2 的 子串 。

class Solution {
    public boolean checkInclusion(String s1, String s2) {

        int[] window = new int[26];

        int[] need = new int[26];

        int wCount = 0,  nCount = 0;

        int left = 0, right = 0;
        int valid = 0;

        for(char c : s1.toCharArray()){
            if(need[c - 'a'] == 0) nCount++;
            need[c - 'a']++;
        }


        while(right < s2.length()){

            char c = s2.charAt(right);
            right++;

            int index = c - 'a';
            if(need[index] > 0){
                
                window[index]++;

                if(need[index] == window[index]) valid++;
            }

            while(right - left >= s1.length()){
                if(valid == nCount) return true;

                char d = s2.charAt(left);
                left++;

                if(need[d - 'a'] > 0){
                    if(window[d - 'a'] == need[d - 'a']) valid--;

                    window[d - 'a']--;
                }
            }
        }
        
        return false;       
    }
}
```



## 二叉树
#### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先

[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val > q.val) { // 保证 p.val < q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        }
        while(root != null) {
            if(root.val < p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val > q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        }
        return root;
    }
}

```


#### 剑指 Offer 54. 二叉搜索树的第k大节点
[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthLargest(TreeNode root, int k) {

        Deque<TreeNode> queue = new ArrayDeque<>();

        while(root != null || !queue.isEmpty()){

            while(root != null){
                queue.push(root);
                root = root.right;
            }

            TreeNode node = queue.pop();

            k--;

            if(k == 0) return node.val;

            root = node.left;
        }

        return -1;
    }
}
```


#### 653. 两数之和 IV - 输入 BST
[653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

```java
给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

class Solution {
    Set<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        if (set.contains(k - root.val)) return true;
        set.add(root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}






解法一中没有利用 BST 特性，利用 BST 中序遍历有序的特性，我们可以实现类似「双指针」的效果。

起始先让 BST 的最左链和最右链完全入栈，此时栈顶元素为 BST 中的最小值和最大值，分别使用 l 和 r 充当指针代指，根据两指针指向的节点值之和与 kk 的大小关系来指导如何让 l 和 r 移动，l 的移动过程其实就是找下一个比 l.val 更大的值，而 r 的移动过程其实就是找下一个比 r.val 更小的值。



class Solution {
    public boolean findTarget(TreeNode root, int k) {
        Deque<TreeNode> ld = new ArrayDeque<>(), rd = new ArrayDeque<>();
        TreeNode temp = root;
        while (temp != null) {
            ld.addLast(temp);
            temp = temp.left;
        }
        temp = root;
        while (temp != null) {
            rd.addLast(temp);
            temp = temp.right;
        }
        TreeNode l = ld.peekLast(), r = rd.peekLast();
        while (l.val < r.val) {
            int t = l.val + r.val;
            if (t == k) return true;
            if (t < k) l = getNext(ld, true);
            else r = getNext(rd, false);
        }
        return false;
    }
    TreeNode getNext(Deque<TreeNode> d, boolean isLeft) {
        TreeNode node = isLeft ? d.pollLast().right : d.pollLast().left;
        while (node != null) {
            d.addLast(node);
            node = isLeft ? node.left : node.right;
        }
        return d.peekLast();
    }
}
```


#### 剑指 Offer 37. 序列化二叉树
[剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

```java

请实现两个函数，分别用来序列化和反序列化二叉树。

你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

public class Codec {
    public String serialize(TreeNode root) {
        if(root == null) return "[]";
        StringBuilder res = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node != null) {
                res.append(node.val + ",");
                queue.add(node.left);
                queue.add(node.right);
            }
            else res.append("null,");
        }
        res.deleteCharAt(res.length() - 1);
        res.append("]");
        return res.toString();
    }

    public TreeNode deserialize(String data) {
        if(data.equals("[]")) return null;
        String[] vals = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i++;
            if(!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;
    }
}

```


#### 剑指 Offer 54. 二叉搜索树的第k大节点
[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {

    int res, k;
    public int kthLargest(TreeNode root, int k) {

        this.k = k;

        dfs(root);

        return res;
    }

    private void dfs(TreeNode root){
        
        if(root == null) return;

        dfs(root.right);

        if(k == 0) return;

        if(--k == 0) res = root.val;

        dfs(root.left);

    }
}
```

## 树
#### 剑指 Offer 26. 树的子结构
[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```java

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {

        if( A == null || B == null) return false;

        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }

    private boolean isSub(TreeNode A, TreeNode B){

        if( B == null) return true;

        if( A == null) return false;

        if( A.val != B.val) return false;

        return isSub(A.left, B.left) && isSub(A.right, B.right);
    }
}
```


#### 剑指 Offer 68 - II. 二叉树的最近公共祖先
[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        

        return helper(root, p, q);
    }


    private TreeNode helper(TreeNode root, TreeNode p, TreeNode q){

        if(root == null) return null;

        if(root.val == p.val || root.val == q.val) return root;

        TreeNode left = helper(root.left, p, q);
        TreeNode right = helper(root.right, p, q);

        if(left == null) return right;
        if(right == null) return left;

        return root;
    }
}
```

## 前缀和
#### 剑指 Offer 66. 构建乘积数组
[剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

```java
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。




class Solution {
    public int[] constructArr(int[] a) {

        /**
            两个数组 A[i]: a[0] ~ a[i - 1]  B[i]: a[i + 1] ~ a[len - 1] 
         */
        if(a == null || a.length == 0) return new int[0];
        int[] A = new int[a.length];
        int[] B = new int[a.length];
        A[0] = B[a.length - 1] = 1;

        for(int i = 1; i < a.length; i++){
            A[i] = A[i - 1] * a[i - 1];
        }

        for(int i = a.length - 2; i >= 0; i--){
            B[i] = B[i + 1] * a[i + 1];
        }

        int[] res = new int[a.length];

        for(int i = 0; i < a.length; i++){
            res[i] = A[i] * B[i];
        }        

        return res;
    }
}

```



## 数学题

#### 剑指 Offer 62. 圆圈中最后剩下的数字
[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```java

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。



class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推,最后一轮的位置
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}



假设我们最好剩余的数字是N。

执行完“删除第三个元素”的操作后，N在新数组中的位置P的意义是什么？ ——它表示，在新数组中，N前面有还有P个元素。那么，在当前数组中，N前面一定有“P+3”个元素。 明白了这一点即可开始倒推。

最后一轮：当前有1个元素。N的位置是0；

倒数第2轮：当前有2个元素。已知在执行完“删除第三个元素”后，N在新数组中的位置是0。则说明在本轮中N前面有0+3=3个元素，所以N的位置是3，然而本轮只有2个元素，所以N的实际位置是（0+3）%2=1；

倒数第3轮：当前有3个元素。已知在执行完“删除第三个元素”后，N’在新数组中的位置是1。说明此刻，N前面有1+3=4个元素，所以N的位置是4。而当前数组只有3个元素，故实际位置是（1+3）%3=1；
```


#### 剑指 Offer 61. 扑克牌中的顺子
[剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```java

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。


class Solution {
    public boolean isStraight(int[] nums) {
        int joker = 0;
        Arrays.sort(nums); // 数组排序
        for(int i = 0; i < 4; i++) {
            if(nums[i] == 0) joker++; // 统计大小王数量
            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false
        }
        return nums[4] - nums[joker] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

class Solution {
    public boolean isStraight(int[] nums) {
        Set<Integer> repeat = new HashSet<>();
        int max = 0, min = 14;
        for(int num : nums) {
            if(num == 0) continue; // 跳过大小王
            max = Math.max(max, num); // 最大牌
            min = Math.min(min, num); // 最小牌
            if(repeat.contains(num)) return false; // 若有重复，提前返回 false
            repeat.add(num); // 添加此牌至 Set
        }
        return max - min < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

```

#### 剑指 Offer 39. 数组中出现次数超过一半的数字(摩尔投票法)
[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

```java
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

class Solution {
    public int majorityElement(int[] nums) {
        int x = 0, votes = 0, count = 0;
        for(int num : nums){
            if(votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        // 验证 x 是否为众数
        for(int num : nums)
            if(num == x) count++;
        return count > nums.length / 2 ? x : 0; // 当无众数时返回 0
    }
}
```


#### 剑指 Offer 49. 丑数
[剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)


```java
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

class Solution {
    public int nthUglyNumber(int n) {

        int a = 0, b = 0, c = 0;

        int[] dp = new int[n];
        dp[0] = 1;

        for(int i = 1; i < n; i++){

            //基于1衍生出来的丑数,找出最小的那一个作为下一个丑数
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
            dp[i] = Math.min(Math.min(n2, n3), n5);

            /*
            比如如果按照这样的顺序排列下去肯定有问题[1*2, 1*3, 1*5, 2*2, 2*3, 2*5, 3*2, 3*3, 3*5, ... , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3* 3, n2 * 5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面， 后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面
            方法就是记录每个数是否被 2 3 5计算过,根据下次应该乘哪个数,拿到新一轮最小的丑数
             */
            if(dp[i] == n2) a++;
            if(dp[i] == n3) b++;
            if(dp[i] == n5) c++;
        }

        return dp[n - 1];
    }
}

```



#### 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面
[剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)
```java

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。


```class Solution {
    public int[] exchange(int[] nums) {
        
        int left = 0, right = nums.length - 1;

        while(left < right){

            while(left < right && nums[left] % 2 == 1) left++;
            while(left < right && nums[right] % 2 == 0) right--;

            if(left == right) break;//不然相交的地方变为0
            nums[left] = nums[right] + nums[left];
            nums[right] = nums[left] - nums[right];
            nums[left] = nums[left] - nums[right];

			 //nums[left] = nums[right] ^ nums[left];
			 //nums[right] = nums[left] ^ nums[right];
			 //nums[left] = nums[left] ^ nums[right];
        }

        return nums;
    }
}

## 二分法


#### 剑指 Offer 53 - II. 0～n-1中缺失的数字
[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。


class Solution {
    public int missingNumber(int[] nums) {
					//可能插在最后一个位置
        int left = 0, right = nums.length;

        while(left < right){

            int mid = left + (right - left) / 2;

            if(nums[mid] != mid){
                right = mid;
            }else{
                left = mid + 1;
            }
        }

        return left;
    }
}

```



#### 剑指 Offer 04. 二维数组中的查找
[剑指 Offer 04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

```java

class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        int i = matrix.length - 1, j = 0;
        while(i >= 0 && j < matrix[0].length)
        {
            if(matrix[i][j] > target) i--;
            else if(matrix[i][j] < target) j++;
            else return true;
        }
        return false;
    }
}

```


#### 剑指 Offer 45. 把数组排成最小的数
[剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

```java
输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。


```

#### 剑指 Offer 16. 数值的整数次方(快速幂)
[剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

```java
实现 pow(_x_, _n_) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。

class Solution {
    public double myPow(double x, int n) {

        if(x == 0) return 0;

        long b = n;

        double res = 1.0;

        if(b < 0) {
            x = 1 / x;
            b = -b;
        }

        while(b > 0){

            if( (b & 1) == 1) res *= x;

            x *= x;

            b >>= 1;
        }

        return res;
    }
}

```

## 动态规划

#### 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```java
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

class Solution {
    public int lengthOfLIS(int[] nums) {
        // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);

        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;

    }
}
```



## 回溯

#### 39. 组合总和
[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

candidate 中的每个元素都 互不相同

class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // 记录回溯的路径
    LinkedList<Integer> track = new LinkedList<>();

    // 回溯算法主函数
    void backtrack(int[] candidates, int start, int target, int sum) {
        if (sum == target) {
            // 找到目标和
            res.add(new LinkedList<>(track));
            return;
        }

        if (sum > target) {
            // 超过目标和，直接结束
            return;
        }

        // 回溯算法框架
        for (int i = start; i < candidates.length; i++) {
            // 选择 candidates[i]
            track.add(candidates[i]);
            sum += candidates[i];
            // 递归遍历下一层回溯树
            backtrack(candidates, i, target, sum);
            // 撤销选择 candidates[i]
            sum -= candidates[i];
            track.removeLast();
        }
    }
}



//优化

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // 先进行排序
        backtracking(res, new ArrayList<>(), candidates, target, 0, 0);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int sum, int idx) {
        // 找到了数字和为 target 的组合
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = idx; i < candidates.length; i++) {
            // 如果 sum + candidates[i] > target 就终止遍历
            if (sum + candidates[i] > target) break;
            path.add(candidates[i]);
            backtracking(res, path, candidates, target, sum + candidates[i], i);
            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素
        }
    }
}
```


#### 46. 全排列
[46. 全排列](https://leetcode-cn.com/problems/permutations/)
```java
给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。

class Solution {


    public List<List<Integer>> permute(int[] nums) {

        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();
        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        List<Integer> path = new ArrayList<>();

        dfs(nums, len, 0, path, used, res);
        return res;


    }


   private void dfs(int[] nums, int len, int depth,
                     List<Integer> path, boolean[] used,
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList(path));
            return;
        }

        // 在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。
        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                dfs(nums, len, depth + 1, path, used, res);
                // 注意：下面这两行代码发生 「回溯」，回溯发生在从 深层结点 回到 浅层结点 的过程，代码在形式上和递归之前是对称的
                used[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }
}

```



#### 51. N 皇后
[51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

```java
n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。


```

## 队列
#### 剑指 Offer 59 - II. 队列的最大值
[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

```java

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1


class MaxQueue {

    Deque<Integer> queue = new ArrayDeque<>();
    Deque<Integer> minQueue = new ArrayDeque<>();

    public MaxQueue() {

    }
    
    public int max_value() {

        if(minQueue.isEmpty()) return -1;
        return minQueue.peekFirst();

    }
    
    public void push_back(int value) {

        queue.offer(value);

        while(minQueue.size() > 0 && minQueue.peekLast() < value){
            minQueue.pollLast();
        }

        minQueue.offerLast(value);
    }
    
    public int pop_front() {

        if(queue.isEmpty()) return -1;

        int value = queue.pop();// pop == pollFirst

        if(value == minQueue.peekFirst()){
            minQueue.pollFirst();
        }

        return value;
    }
}


```


#### 剑指 Offer 59 - I. 滑动窗口的最大值
[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
```java

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。



```


## 栈

#### 155. 最小栈
[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```java
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。


class MinStack {

    Deque<Integer> A = new ArrayDeque<>();
    Deque<Integer> B = new ArrayDeque<>();
    public MinStack() {

    }
    
    public void push(int val) {

        A.addFirst(val);
        if(B.isEmpty()){
            B.addFirst(val);
        }else if(B.peekFirst() >= val){
            B.addFirst(val);
        }
    }
    
    public void pop() {
        int i = A.pollFirst();

        if(B.peekFirst() == i) B.pollFirst();
    }
    
    public int top() {
        return A.peekFirst();
    }
    
    public int getMin() {
        return B.peekFirst();
    }
}

```

#### 剑指 Offer 09. 用两个栈实现队列
[剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

class CQueue {

    Stack<Integer> A = new Stack<>();
    Stack<Integer> B = new Stack<>();

    public CQueue() {

    }
    
    public void appendTail(int value) {

        A.push(value);
    }
    
    public int deleteHead() {

        if(A.isEmpty() && B.isEmpty()) return -1;
        if(B.isEmpty()){
            while(!A.isEmpty()){
                B.push(A.pop());
            }
        }

        return B.pop();
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```


#### 剑指 Offer 31. 栈的压入、弹出序列
[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

```java

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。



class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Deque<Integer> stack = new ArrayDeque<>();

        int i = 0;

        for(int num : pushed){
            stack.addFirst(num);

            while(!stack.isEmpty() && stack.peekFirst() == popped[i]){
                stack.pollFirst();
                i++;
            }
        }

        return stack.isEmpty();
    }
}

```

## 位运算
#### 剑指 Offer 56 - I. 数组中数字出现的次数
[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

```java
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

class Solution {
    public int[] singleNumbers(int[] nums) {

        int temp = 0;

        //find the different between A and B
        for(int num : nums){
            temp = temp ^ num;
        }

        int index = 1;
        while((temp & index) == 0){

            index = index << 1;
        }

        int a = 0, b = 0;

        for(int n : nums){
            if((index & n) != 0) a ^= n;
            else b ^= n;
        }

        return new int[]{a,b};
    }
}

```


## 归并

#### 
```java

递归：

// 最基本的
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode res = null;

        for(ListNode list : lists){
            res = merge(res, list);
        }

        return res;
    }

        public ListNode merge(ListNode list1, ListNode list2) {

	        if(list1 == null) return list2;
	        if(list2 == null) return list1;
	
	        if(list1.val < list2.val){
	            list1.next = merge(list1.next, list2);
	            return list1;
	        }
	
	        list2.next = merge(list1,list2.next);
	
	        return list2;
	    }
}



//升级版
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {

        if(lists == null || lists.length == 0) return null;

        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int left, int right) {

        if(left == right) return lists[left];

        int mid = left + (right - left) / 2;

        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);

        return mergeList(l1, l2);
    }
    public ListNode mergeList(ListNode list1, ListNode list2) {

        if(list1 == null) return list2;
        if(list2 == null) return list1;

        if(list1.val < list2.val){
            list1.next = mergeList(list1.next, list2);
            return list1;
        }

        list2.next = mergeList(list1,list2.next);

        return list2;
    }
}

时间复杂度：必须经过 logk轮次的排序，假设最长链表为n，那么要经过每论排序每条链表的每个元素都参与，就是 kn了 全部轮次合起来就是 kn * logk


迭代：
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {

        if(lists == null || lists.length == 0) return null;

        int k = lists.length;

        while(k > 1){
            int index = 0;

            for(int i = 0; i < k; i+=2){
                if(i == k - 1){
                    lists[index++] = lists[i];
                }else{
                    lists[index++] = mergeList(lists[i], lists[i + 1]);
                }
            }
            
			//代表着当前排序完最末尾的链表
            k = index;
        }

        return lists[0];
    }

    public ListNode mergeList(ListNode l1, ListNode l2){

        ListNode dummy = new ListNode();
        ListNode tail = dummy;

        while(l1 != null && l2 != null){
            if(l1.val < l2.val){
                tail.next = l1;
                l1 = l1.next;
            }else{
                tail.next = l2;
                l2 = l2.next;
            }

            tail = tail.next;
        }

        tail.next = l1 == null? l2 : l1;

        return dummy.next;
    }

}

```


#### 剑指 Offer 51. 数组中的逆序对
[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

```java
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。


class Solution {
 int count;
    public int reversePairs(int[] nums) {
        this.count = 0;
        merge(nums, 0, nums.length - 1);
        return count;
    }

    public void merge(int[] nums, int left, int right) {
        int mid = left + ((right - left) >> 1);
        if (left < right) {
            merge(nums, left, mid);
            merge(nums, mid + 1, right);
            mergeSort(nums, left, mid, right);
        }
    }

    public void mergeSort(int[] nums, int left, int mid, int right) {
        int[] temparr = new int[right - left + 1];
        int index = 0;
        int temp1 = left, temp2 = mid + 1;

        while (temp1 <= mid && temp2 <= right) {
            if (nums[temp1] <= nums[temp2]) {
                temparr[index++] = nums[temp1++];
            } else {
                //用来统计逆序对的个数
                count += (mid - temp1 + 1);
                temparr[index++] = nums[temp2++];
            }
        }
        //把左边剩余的数移入数组
        while (temp1 <= mid) {
            temparr[index++] = nums[temp1++];
        }
        //把右边剩余的数移入数组
        while (temp2 <= right) {
            temparr[index++] = nums[temp2++];
        }
        //把新数组中的数覆盖nums数组
        for (int k = 0; k < temparr.length; k++) {
            nums[k + left] = temparr[k];
        }
    }
}
```


## 设计数据结构

#### 380. O(1) 时间插入、删除和获取随机元素
[380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

```java
实现RandomizedSet 类：

RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。

class RandomizedSet {
    List<Integer> list;
    Map<Integer,Integer> map;
    int i;
    public RandomizedSet() {
        list=new ArrayList<>();
        map=new HashMap<>();
        i=0;
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){return false;}
        list.add(val);
        map.put(val,i);
        i++;
        return true;
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){return false;}
        int k=map.get(val);
        list.remove(k);
        map.remove(val);
        i--;
        if(k<i){
            int a=list.remove(i-1);
            list.add(k,a);
            map.put(a,k);
        }
        return true;
    }
    
    public int getRandom() {
        return list.get((int)(Math.random()*i));
    }
}
```



## 动态规划

#### 53. 最大子数组和(dp和贪心)
[53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```java

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

//dp
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        int[] dp = new int[n];
        // base case
        // 第一个元素前面没有子数组
        dp[0] = nums[0];
        // 状态转移方程
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        }
        // 得到 nums 的最大子数组
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}


class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}


//贪心法
class Solution {
    public int maxSubArray(int[] nums) {

        if(nums == null || nums.length == 0) return 0;

        int right = 0;

        int res = Integer.MIN_VALUE, sum = 0;

        while(right < nums.length){

            sum += nums[right];

            if(sum > res){ res = sum;}
            sum = sum < 0 ? 0 : sum;
            right++;
        }

        return res;
    }
}

```

#### 375. 猜数字大小 II
[375. 猜数字大小 II](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/)
```java

我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。

class Solution {
    public int getMoneyAmount(int n) {

        if(n == 1) return 0;

        int[][] dp = new int[n + 1][n + 1];


        for(int i = 0; i <=n; i++){
            for(int j = 0; j <= n; j++){
                dp[i][j] = Integer.MAX_VALUE;
            }
        }

        for(int i = 0; i <= n; i++){
            dp[i][i] = 0;
        }

        //从第二列开始
        for(int j = 2; j<= n; j++){
            
            int i = j - 1;
            //从后往前推 [i, j]  j固定,i不断往左移
            for(; i >= 1; i--){
                
                // i 和 j 确定, 也就是边界确定了,开始对切割点进行计算
                for(int k = i + 1; k <= j - 1; k++){
                    int temp = k + Math.max(dp[i][k - 1], dp[k + 1][j]);
                    dp[i][j] = Math.min(temp, dp[i][j]);
                }

                //由于切割点没割到边界,所以这里要计算边界
                dp[i][j] = Math.min(dp[i][j], i + dp[i + 1][j]);
                dp[i][j] = Math.min(dp[i][j], j + dp[i][j - 1]);
            }

        }

        return dp[1][n];
    }
}

```



#### 剑指 Offer 12. 矩阵中的路径
[剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```java

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        board[i][j] = '\0';
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
}

```


#### 剑指 Offer 14- I. 剪绳子
[剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)
```java

class Solution {
    public int cuttingRope(int n) {

        int[] dp = new int[n + 1];

        for(int i = 2; i <= n; i++){
			//从长度为1的地方剪
            for(int j = 1; j <= i - 1; j++){

                int temp = Math.max(dp[j] * (i - j), j * (i - j));
                //找长度为i时最大长度
                dp[i] = Math.max(dp[i], temp);
            }
        }

        return dp[n];
    }
}
```


## 单调栈
#### 496. 下一个更大元素 I
[496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

```java

nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。

给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。

对于每个 0 <= i < nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。

返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。



class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int[] res = new int[nums1.length];

        Stack<Integer> stack = new Stack<>();
        Map<Integer, Integer> map = new HashMap<>();

        //将 nums1 值与索引下标用 map 对应起来
        for(int i = 0; i < nums1.length; i++){
            map.put(nums1[i], i);
        }

        //从后往前遍历,这样的原因是 可以找到 位于当前数的后面 的大于当前数 的第一个数
        // eg : 1 3 5 4 7  4小于5,4踢出去,换7来跟5比较,若7 大于 5,则 5留下来跟下一个数比较,若7 小于 5, 7 也踢出去
        for(int i = nums2.length - 1; i >= 0; i--){
            
            //不断踢掉栈顶小于当前数的数
            while(!stack.isEmpty() && stack.peek() <= nums2[i]){
                stack.pop();
            }

            if(map.containsKey(nums2[i])){
                res[map.get(nums2[i])] = stack.isEmpty()? -1 : stack.peek();
            }

            stack.push(nums2[i]);
        }

        return res;
    }
}
```


#### 503. 下一个更大元素 II
[503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)
```java
给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素 。

数字 x 的 下一个更大的元素 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1 。


class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int[] res = new int[nums.length];

        Deque<Integer> stack = new LinkedList<>();

        int n = nums.length;   //这里一定要 >= 0, 因为可能第一个元素比后面都大，在循环的条件下，后面的元素在res中要更新值为第1个元素
       for(int i = 2 * nums.length - 1; i >= 0; i--){
           while(!stack.isEmpty() && stack.peek() <= nums[i % n]){
               stack.pop();
           }

           res[i % n] = stack.isEmpty() ? -1 : stack.peek();
           stack.push(nums[i % n]);
       }

        return res;
    }
}
```

#### 剑指 Offer II 038. 每日温度
[剑指 Offer II 038. 每日温度](https://leetcode-cn.com/problems/iIQa4I/)

```java
请根据每日 气温 列表 temperatures ，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        
        int[] res = new int[temperatures.length];

        Deque<Integer> stack = new LinkedList<>();

        for(int i = res.length - 1; i >= 0; i--){

            while(!stack.isEmpty() && temperatures[i] >= temperatures[stack.peek()]){
                stack.pop();
            }

            if(!stack.isEmpty()){
                res[i] = stack.peek() - i;
            }

            stack.push(i);
        }
        return res;
    }
}
```


## 图


#### 剑指 Offer 13. 机器人的运动范围
[剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)
```java

class Solution {

    boolean[][] visit;
    public int movingCount(int m, int n, int k) {

        visit = new boolean[m][n];

        return dfs(m, n, k, 0, 0);
    }

    private int dfs(int m, int n, int k, int i, int j){

        if(i >= m || j >= n || visit[i][j] || (cul(i) + cul(j) > k)) return 0;

        visit[i][j] = true;

        return 1 + dfs(m, n, k, i + 1, j) + dfs(m, n, k, i, j + 1);
    }


    private int cul(int num){
        int res = 0;

        while(num != 0){
            res += num % 10;
            num /= 10;
        }

        return res;
    }
}
```



## 大数问题

#### 剑指 Offer 17. 打印从1到最大的n位数
[剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

```java
输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
class Solution {

    int count = 0;
    int[] res;
    public int[] printNumbers(int n) {

        res = new int[(int) Math.pow(10, n) - 1];

        for(int digit = 1; digit < n + 1; digit++){

            for(char first = '1'; first <= '9'; first++){
                
                char[] num = new char[digit];

                num[0] = first;

                dfs(1, num, digit);
            }
        }

        return res;
    }

    private void dfs(int index, char[] num, int digit){

        //当前第几位 是否等于最大位数
        if(index == digit){
            res[count++] = Integer.parseInt(String.valueOf(num));
            return;
        }

        for(char i = '0'; i <= '9'; i++){
            num[index] = i;
            dfs(index + 1, num, digit);
        }
    }
}

```

## 多线程
