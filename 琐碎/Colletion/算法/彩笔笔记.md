
## 贪心法

#### 179. 最大数
[179. 最大数](https://leetcode-cn.com/problems/largest-number/)

```java
给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] ss = new String[n];
        for (int i = 0; i < n; i++) ss[i] = "" + nums[i];
        Arrays.sort(ss, (a, b) -> {
            String sa = a + b, sb = b + a ;
            return sb.compareTo(sa);
        });
        
        StringBuilder sb = new StringBuilder();
        for (String s : ss) sb.append(s);
        int len = sb.length();
        int k = 0;
        while (k < len - 1 && sb.charAt(k) == '0') k++;
        return sb.substring(k);
    }
}
```


## 滑动窗口

#### 3. 无重复字符的最长子串
[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```java
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

class Solution {
    public int lengthOfLongestSubstring(String s) {

        int left = 0, right = 0;

        Map<Character, Integer> map = new HashMap<>();

        int maxLen = 0;

        char[] chars = s.toCharArray();

        while(right < s.length()){
            
            if(map.containsKey(chars[right])){

                // abcba  再遇到最后一个a的时候,left指向c,但从map中取到a的位置却在0.所以要跟现在比较一下
              left = Math.max(left, map.get(chars[right]) + 1);
            }
            map.put(chars[right], right);

            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    }
}
```



## 链表

#### 2. 两数相加
[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 在两条链表上的指针
        ListNode p1 = l1, p2 = l2;
        // 虚拟头结点（构建新链表时的常用技巧）
        ListNode dummy = new ListNode(-1);
        // 指针 p 负责构建新链表
        ListNode p = dummy;
        // 记录进位
        int carry = 0;
        // 开始执行加法，两条链表走完且没有进位时才能结束循环
        while (p1 != null || p2 != null || carry > 0) {
            // 先加上上次的进位
            int val = carry;
            if (p1 != null) {
                val += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                val += p2.val;
                p2 = p2.next;
            }
            // 处理进位情况
            carry = val / 10;
            val = val % 10;
            // 构建新节点
            p.next = new ListNode(val);
            p = p.next;
        }
        // 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next;
    }
}


```


#### 21. 合并两个有序链表
[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {

        if(list1 == null) return list2;
        if(list2 == null) return list1;

        if(list1.val < list2.val){
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        }

        list2.next = mergeTwoLists(list1,list2.next);

        return list2;
    }
}
```


#### 206. 反转链表
[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
```java
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

class Solution {
    public ListNode reverseList(ListNode head) {

        if(head == null || head.next == null) return head;

        ListNode last = reverseList(head.next);

        head.next.next = head;

        head.next = null;

        return last;
    }
}
```

#### 92. 反转链表 II
[92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)
```java
递归
// 记录后节点
    ListNode last;
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if(left==1){
            // 反转链表的内容
            return reverse(head,right);
        }
        ListNode newhead=reverseBetween(head.next,left-1,right-1);
        head.next=newhead;
        return head;
    }

    ListNode reverse(ListNode head,int count){
        // base case
        // 递归到最后一个我们需要的节点了 记录他的后节点 last
        if(count==1){
            last=head.next;
            return head;
        }
        ListNode cur=reverse(head.next,count-1);
        // 后续遍历位置 从最后往前翻转
        head.next.next=head;
        head.next=last;
        return cur;
    }



遍历，头插法
class Solution {
    public ListNode reverseBetween(ListNode head, int m, int n) {
        // 定义一个dummyHead, 方便处理
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;

        // 初始化指针
        ListNode g = dummyHead;
        ListNode p = dummyHead.next;

        // 将指针移到相应的位置
        for(int step = 0; step < m - 1; step++) {
            g = g.next; p = p.next;
        }

        // 头插法插入节点
        for (int i = 0; i < n - m; i++) {
            ListNode removed = p.next;
            p.next = p.next.next;

            removed.next = g.next;
            g.next = removed;
        }

        return dummyHead.next;
    }
}

```


#### 25. K 个一组翻转链表
[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```java

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

进阶：

你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。


迭代
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a, b;
        a = b = head;
        for (int i = 0; i < k; i++) {
            // 不足 k 个，不需要反转，base case  //若是没达到 b)之前为 null，则不用转了， 若到达 b)为null，说明前面刚好为k个
            if (b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverse(a, b);
        // 递归反转后续链表并连接起来   // a变为末尾，指向下一段的头
        a.next = reverseKGroup(b, k);
        return newHead;
    }

    /* 反转区间 [a, b) 的元素，注意是左闭右开 */
    ListNode reverse(ListNode a, ListNode b) {
        ListNode pre, cur, nxt;
        pre = null;
        cur = a;
        nxt = a;
        // while 终止的条件改一下就行了
        while (cur != b) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        // 返回反转后的头结点
        return pre;
    }
}



```



#### 114. 二叉树展开为链表
[114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)
```java

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。


class Solution {
    // 定义：将以 root 为根的树拉平为链表
    public void flatten(TreeNode root) {
        // base case
        if (root == null) return;
        // 先递归拉平左右子树
        flatten(root.left);
        flatten(root.right);

        /****后序遍历位置****/
        // 1、左右子树已经被拉平成一条链表
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 2、将左子树作为右子树
        root.left = null;
        root.right = left;

        // 3、将原先的右子树接到当前右子树的末端
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    }
}
```


## 字符串


### 5. 最长回文子串(中心扩散法和dp)
[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java

给你一个字符串 `s`，找到 `s` 中最长的回文子串。`s` 仅由数字和英文字母组成

class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            String s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            String s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

    String palindrome(String s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.length()
                && s.charAt(l) == s.charAt(r)) {
            // 向两边展开
            l--;
            r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r);
    }
}


```



#### 567. 字符串的排列
[567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)
```java
给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。

换句话说，s1 的排列之一是 s2 的 子串 。

class Solution {
    public boolean checkInclusion(String s1, String s2) {

        int[] window = new int[26];

        int[] need = new int[26];

        int wCount = 0,  nCount = 0;

        int left = 0, right = 0;
        int valid = 0;

        for(char c : s1.toCharArray()){
            if(need[c - 'a'] == 0) nCount++;
            need[c - 'a']++;
        }


        while(right < s2.length()){

            char c = s2.charAt(right);
            right++;

            int index = c - 'a';
            if(need[index] > 0){
                
                window[index]++;

                if(need[index] == window[index]) valid++;
            }

            while(right - left >= s1.length()){
                if(valid == nCount) return true;

                char d = s2.charAt(left);
                left++;

                if(need[d - 'a'] > 0){
                    if(window[d - 'a'] == need[d - 'a']) valid--;

                    window[d - 'a']--;
                }
            }
        }
        
        return false;       
    }
}
```



## 二叉树
#### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先

[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val > q.val) { // 保证 p.val < q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        }
        while(root != null) {
            if(root.val < p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val > q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        }
        return root;
    }
}

```


#### 剑指 Offer 54. 二叉搜索树的第k大节点
[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthLargest(TreeNode root, int k) {

        Deque<TreeNode> queue = new ArrayDeque<>();

        while(root != null || !queue.isEmpty()){

            while(root != null){
                queue.push(root);
                root = root.right;
            }

            TreeNode node = queue.pop();

            k--;

            if(k == 0) return node.val;

            root = node.left;
        }

        return -1;
    }
}
```


#### 653. 两数之和 IV - 输入 BST
[653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

```java
给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

class Solution {
    Set<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        if (set.contains(k - root.val)) return true;
        set.add(root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}






解法一中没有利用 BST 特性，利用 BST 中序遍历有序的特性，我们可以实现类似「双指针」的效果。

起始先让 BST 的最左链和最右链完全入栈，此时栈顶元素为 BST 中的最小值和最大值，分别使用 l 和 r 充当指针代指，根据两指针指向的节点值之和与 kk 的大小关系来指导如何让 l 和 r 移动，l 的移动过程其实就是找下一个比 l.val 更大的值，而 r 的移动过程其实就是找下一个比 r.val 更小的值。



class Solution {
    public boolean findTarget(TreeNode root, int k) {
        Deque<TreeNode> ld = new ArrayDeque<>(), rd = new ArrayDeque<>();
        TreeNode temp = root;
        while (temp != null) {
            ld.addLast(temp);
            temp = temp.left;
        }
        temp = root;
        while (temp != null) {
            rd.addLast(temp);
            temp = temp.right;
        }
        TreeNode l = ld.peekLast(), r = rd.peekLast();
        while (l.val < r.val) {
            int t = l.val + r.val;
            if (t == k) return true;
            if (t < k) l = getNext(ld, true);
            else r = getNext(rd, false);
        }
        return false;
    }
    TreeNode getNext(Deque<TreeNode> d, boolean isLeft) {
        TreeNode node = isLeft ? d.pollLast().right : d.pollLast().left;
        while (node != null) {
            d.addLast(node);
            node = isLeft ? node.left : node.right;
        }
        return d.peekLast();
    }
}
```

## 前缀和
#### 剑指 Offer 66. 构建乘积数组
[剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

```java
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。




class Solution {
    public int[] constructArr(int[] a) {

        /**
            两个数组 A[i]: a[0] ~ a[i - 1]  B[i]: a[i + 1] ~ a[len - 1] 
         */
        if(a == null || a.length == 0) return new int[0];
        int[] A = new int[a.length];
        int[] B = new int[a.length];
        A[0] = B[a.length - 1] = 1;

        for(int i = 1; i < a.length; i++){
            A[i] = A[i - 1] * a[i - 1];
        }

        for(int i = a.length - 2; i >= 0; i--){
            B[i] = B[i + 1] * a[i + 1];
        }

        int[] res = new int[a.length];

        for(int i = 0; i < a.length; i++){
            res[i] = A[i] * B[i];
        }        

        return res;
    }
}

```



## 数学题

#### 剑指 Offer 62. 圆圈中最后剩下的数字
[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```java

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。



class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推,最后一轮的位置
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}



假设我们最好剩余的数字是N。

执行完“删除第三个元素”的操作后，N在新数组中的位置P的意义是什么？ ——它表示，在新数组中，N前面有还有P个元素。那么，在当前数组中，N前面一定有“P+3”个元素。 明白了这一点即可开始倒推。

最后一轮：当前有1个元素。N的位置是0；

倒数第2轮：当前有2个元素。已知在执行完“删除第三个元素”后，N在新数组中的位置是0。则说明在本轮中N前面有0+3=3个元素，所以N的位置是3，然而本轮只有2个元素，所以N的实际位置是（0+3）%2=1；

倒数第3轮：当前有3个元素。已知在执行完“删除第三个元素”后，N’在新数组中的位置是1。说明此刻，N前面有1+3=4个元素，所以N的位置是4。而当前数组只有3个元素，故实际位置是（1+3）%3=1；
```


#### 剑指 Offer 61. 扑克牌中的顺子
[剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```java

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。


class Solution {
    public boolean isStraight(int[] nums) {
        int joker = 0;
        Arrays.sort(nums); // 数组排序
        for(int i = 0; i < 4; i++) {
            if(nums[i] == 0) joker++; // 统计大小王数量
            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false
        }
        return nums[4] - nums[joker] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

class Solution {
    public boolean isStraight(int[] nums) {
        Set<Integer> repeat = new HashSet<>();
        int max = 0, min = 14;
        for(int num : nums) {
            if(num == 0) continue; // 跳过大小王
            max = Math.max(max, num); // 最大牌
            min = Math.min(min, num); // 最小牌
            if(repeat.contains(num)) return false; // 若有重复，提前返回 false
            repeat.add(num); // 添加此牌至 Set
        }
        return max - min < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

```

#### 剑指 Offer 39. 数组中出现次数超过一半的数字(摩尔投票法)
[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

```java
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

class Solution {
    public int majorityElement(int[] nums) {
        int x = 0, votes = 0, count = 0;
        for(int num : nums){
            if(votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        // 验证 x 是否为众数
        for(int num : nums)
            if(num == x) count++;
        return count > nums.length / 2 ? x : 0; // 当无众数时返回 0
    }
}
```


#### 剑指 Offer 49. 丑数
[剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)


```java
我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

class Solution {
    public int nthUglyNumber(int n) {

        int a = 0, b = 0, c = 0;

        int[] dp = new int[n];
        dp[0] = 1;

        for(int i = 1; i < n; i++){

            //基于1衍生出来的丑数,找出最小的那一个作为下一个丑数
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
            dp[i] = Math.min(Math.min(n2, n3), n5);

            /*
            比如如果按照这样的顺序排列下去肯定有问题[1*2, 1*3, 1*5, 2*2, 2*3, 2*5, 3*2, 3*3, 3*5, ... , n1 *2, n1 * 3, n1 * 5, n2 * 2, n3* 3, n2 * 5]，因为后面乘2的数据可能会比前面乘3乘5的数据要小，那这个乘2的数应该排在他们的前面， 后面乘3的数据也可能比前面乘5的数据要小，那这个乘3的数应该排在他们的前面
            方法就是记录每个数是否被 2 3 5计算过,根据下次应该乘哪个数,拿到新一轮最小的丑数
             */
            if(dp[i] == n2) a++;
            if(dp[i] == n3) b++;
            if(dp[i] == n5) c++;
        }

        return dp[n - 1];
    }
}

```


## 二分法


#### 剑指 Offer 53 - II. 0～n-1中缺失的数字
[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。


class Solution {
    public int missingNumber(int[] nums) {
					//可能插在最后一个位置
        int left = 0, right = nums.length;

        while(left < right){

            int mid = left + (right - left) / 2;

            if(nums[mid] != mid){
                right = mid;
            }else{
                left = mid + 1;
            }
        }

        return left;
    }
}

```




## 动态规划

#### 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```java
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

class Solution {
    public int lengthOfLIS(int[] nums) {
        // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);

        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;

    }
}
```



## 回溯

#### 39. 组合总和
[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

candidate 中的每个元素都 互不相同

class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // 记录回溯的路径
    LinkedList<Integer> track = new LinkedList<>();

    // 回溯算法主函数
    void backtrack(int[] candidates, int start, int target, int sum) {
        if (sum == target) {
            // 找到目标和
            res.add(new LinkedList<>(track));
            return;
        }

        if (sum > target) {
            // 超过目标和，直接结束
            return;
        }

        // 回溯算法框架
        for (int i = start; i < candidates.length; i++) {
            // 选择 candidates[i]
            track.add(candidates[i]);
            sum += candidates[i];
            // 递归遍历下一层回溯树
            backtrack(candidates, i, target, sum);
            // 撤销选择 candidates[i]
            sum -= candidates[i];
            track.removeLast();
        }
    }
}



//优化

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // 先进行排序
        backtracking(res, new ArrayList<>(), candidates, target, 0, 0);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int sum, int idx) {
        // 找到了数字和为 target 的组合
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = idx; i < candidates.length; i++) {
            // 如果 sum + candidates[i] > target 就终止遍历
            if (sum + candidates[i] > target) break;
            path.add(candidates[i]);
            backtracking(res, path, candidates, target, sum + candidates[i], i);
            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素
        }
    }
}
```



## 队列
#### 剑指 Offer 59 - II. 队列的最大值
[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

```java

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1


class MaxQueue {

    Deque<Integer> queue = new ArrayDeque<>();
    Deque<Integer> minQueue = new ArrayDeque<>();

    public MaxQueue() {

    }
    
    public int max_value() {

        if(minQueue.isEmpty()) return -1;
        return minQueue.peekFirst();

    }
    
    public void push_back(int value) {

        queue.offer(value);

        while(minQueue.size() > 0 && minQueue.peekLast() < value){
            minQueue.pollLast();
        }

        minQueue.offerLast(value);
    }
    
    public int pop_front() {

        if(queue.isEmpty()) return -1;

        int value = queue.pop();// pop == pollFirst

        if(value == minQueue.peekFirst()){
            minQueue.pollFirst();
        }

        return value;
    }
}


```


#### 剑指 Offer 59 - I. 滑动窗口的最大值
[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
```java

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。



```


## 栈

#### 155. 最小栈
[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```java
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。


class MinStack {

    Deque<Integer> A = new ArrayDeque<>();
    Deque<Integer> B = new ArrayDeque<>();
    public MinStack() {

    }
    
    public void push(int val) {

        A.addFirst(val);
        if(B.isEmpty()){
            B.addFirst(val);
        }else if(B.peekFirst() >= val){
            B.addFirst(val);
        }
    }
    
    public void pop() {
        int i = A.pollFirst();

        if(B.peekFirst() == i) B.pollFirst();
    }
    
    public int top() {
        return A.peekFirst();
    }
    
    public int getMin() {
        return B.peekFirst();
    }
}

```

#### 剑指 Offer 09. 用两个栈实现队列
[剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

class CQueue {

    Stack<Integer> A = new Stack<>();
    Stack<Integer> B = new Stack<>();

    public CQueue() {

    }
    
    public void appendTail(int value) {

        A.push(value);
    }
    
    public int deleteHead() {

        if(A.isEmpty() && B.isEmpty()) return -1;
        if(B.isEmpty()){
            while(!A.isEmpty()){
                B.push(A.pop());
            }
        }

        return B.pop();
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```


#### 剑指 Offer 31. 栈的压入、弹出序列
[剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

```java

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。



class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Deque<Integer> stack = new ArrayDeque<>();

        int i = 0;

        for(int num : pushed){
            stack.addFirst(num);

            while(!stack.isEmpty() && stack.peekFirst() == popped[i]){
                stack.pollFirst();
                i++;
            }
        }

        return stack.isEmpty();
    }
}

```

## 位运算
#### 剑指 Offer 56 - I. 数组中数字出现的次数
[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

```java
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

class Solution {
    public int[] singleNumbers(int[] nums) {

        int temp = 0;

        //find the different between A and B
        for(int num : nums){
            temp = temp ^ num;
        }

        int index = 1;
        while((temp & index) == 0){

            index = index << 1;
        }

        int a = 0, b = 0;

        for(int n : nums){
            if((index & n) != 0) a ^= n;
            else b ^= n;
        }

        return new int[]{a,b};
    }
}

```


## 归并

#### 
```java

递归：

// 最基本的
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode res = null;

        for(ListNode list : lists){
            res = merge(res, list);
        }

        return res;
    }

        public ListNode merge(ListNode list1, ListNode list2) {

	        if(list1 == null) return list2;
	        if(list2 == null) return list1;
	
	        if(list1.val < list2.val){
	            list1.next = merge(list1.next, list2);
	            return list1;
	        }
	
	        list2.next = merge(list1,list2.next);
	
	        return list2;
	    }
}



//升级版
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {

        if(lists == null || lists.length == 0) return null;

        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int left, int right) {

        if(left == right) return lists[left];

        int mid = left + (right - left) / 2;

        ListNode l1 = merge(lists, left, mid);
        ListNode l2 = merge(lists, mid + 1, right);

        return mergeList(l1, l2);
    }
    public ListNode mergeList(ListNode list1, ListNode list2) {

        if(list1 == null) return list2;
        if(list2 == null) return list1;

        if(list1.val < list2.val){
            list1.next = mergeList(list1.next, list2);
            return list1;
        }

        list2.next = mergeList(list1,list2.next);

        return list2;
    }
}

时间复杂度：必须经过 logk轮次的排序，假设最长链表为n，那么要经过每论排序每条链表的每个元素都参与，就是 kn了 全部轮次合起来就是 kn * logk


迭代：
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {

        if(lists == null || lists.length == 0) return null;

        int k = lists.length;

        while(k > 1){
            int index = 0;

            for(int i = 0; i < k; i+=2){
                if(i == k - 1){
                    lists[index++] = lists[i];
                }else{
                    lists[index++] = mergeList(lists[i], lists[i + 1]);
                }
            }
            
			//代表着当前排序完最末尾的链表
            k = index;
        }

        return lists[0];
    }

    public ListNode mergeList(ListNode l1, ListNode l2){

        ListNode dummy = new ListNode();
        ListNode tail = dummy;

        while(l1 != null && l2 != null){
            if(l1.val < l2.val){
                tail.next = l1;
                l1 = l1.next;
            }else{
                tail.next = l2;
                l2 = l2.next;
            }

            tail = tail.next;
        }

        tail.next = l1 == null? l2 : l1;

        return dummy.next;
    }

}

```


## 设计数据结构

#### 380. O(1) 时间插入、删除和获取随机元素
[380. O(1) 时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)

```java
实现RandomizedSet 类：

RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。
你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。

class RandomizedSet {
    List<Integer> list;
    Map<Integer,Integer> map;
    int i;
    public RandomizedSet() {
        list=new ArrayList<>();
        map=new HashMap<>();
        i=0;
    }
    
    public boolean insert(int val) {
        if(map.containsKey(val)){return false;}
        list.add(val);
        map.put(val,i);
        i++;
        return true;
    }
    
    public boolean remove(int val) {
        if(!map.containsKey(val)){return false;}
        int k=map.get(val);
        list.remove(k);
        map.remove(val);
        i--;
        if(k<i){
            int a=list.remove(i-1);
            list.add(k,a);
            map.put(a,k);
        }
        return true;
    }
    
    public int getRandom() {
        return list.get((int)(Math.random()*i));
    }
}
```