
## 贪心法

#### 179. 最大数
[179. 最大数](https://leetcode-cn.com/problems/largest-number/)

```java
给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：** 输出结果可能非常大，所以你需要返回一个字符串而不是整数。

class Solution {
    public String largestNumber(int[] nums) {
        int n = nums.length;
        String[] ss = new String[n];
        for (int i = 0; i < n; i++) ss[i] = "" + nums[i];
        Arrays.sort(ss, (a, b) -> {
            String sa = a + b, sb = b + a ;
            return sb.compareTo(sa);
        });
        
        StringBuilder sb = new StringBuilder();
        for (String s : ss) sb.append(s);
        int len = sb.length();
        int k = 0;
        while (k < len - 1 && sb.charAt(k) == '0') k++;
        return sb.substring(k);
    }
}
```


## 滑动窗口

#### 3. 无重复字符的最长子串
[3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```java
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

class Solution {
    public int lengthOfLongestSubstring(String s) {

        int left = 0, right = 0;

        Map<Character, Integer> map = new HashMap<>();

        int maxLen = 0;

        char[] chars = s.toCharArray();

        while(right < s.length()){
            
            if(map.containsKey(chars[right])){

                // abcba  再遇到最后一个a的时候,left指向c,但从map中取到a的位置却在0.所以要跟现在比较一下
              left = Math.max(left, map.get(chars[right]) + 1);
            }
            map.put(chars[right], right);

            maxLen = Math.max(maxLen, right - left + 1);
            right++;
        }

        return maxLen;
    }
}
```



## 链表

#### 2. 两数相加
[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

```java

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 在两条链表上的指针
        ListNode p1 = l1, p2 = l2;
        // 虚拟头结点（构建新链表时的常用技巧）
        ListNode dummy = new ListNode(-1);
        // 指针 p 负责构建新链表
        ListNode p = dummy;
        // 记录进位
        int carry = 0;
        // 开始执行加法，两条链表走完且没有进位时才能结束循环
        while (p1 != null || p2 != null || carry > 0) {
            // 先加上上次的进位
            int val = carry;
            if (p1 != null) {
                val += p1.val;
                p1 = p1.next;
            }
            if (p2 != null) {
                val += p2.val;
                p2 = p2.next;
            }
            // 处理进位情况
            carry = val / 10;
            val = val % 10;
            // 构建新节点
            p.next = new ListNode(val);
            p = p.next;
        }
        // 返回结果链表的头结点（去除虚拟头结点）
        return dummy.next;
    }
}


```




## 字符串


### 5. 最长回文子串(中心扩散法和dp)
[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

```java

给你一个字符串 `s`，找到 `s` 中最长的回文子串。`s` 仅由数字和英文字母组成

class Solution {
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            String s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            String s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }

    String palindrome(String s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.length()
                && s.charAt(l) == s.charAt(r)) {
            // 向两边展开
            l--;
            r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r);
    }
}


```



## 二叉树
#### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先

[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(p.val > q.val) { // 保证 p.val < q.val
            TreeNode tmp = p;
            p = q;
            q = tmp;
        }
        while(root != null) {
            if(root.val < p.val) // p,q 都在 root 的右子树中
                root = root.right; // 遍历至右子节点
            else if(root.val > q.val) // p,q 都在 root 的左子树中
                root = root.left; // 遍历至左子节点
            else break;
        }
        return root;
    }
}

```


#### 剑指 Offer 54. 二叉搜索树的第k大节点
[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

```java
给定一棵二叉搜索树，请找出其中第 `k` 大的节点的值。


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthLargest(TreeNode root, int k) {

        Deque<TreeNode> queue = new ArrayDeque<>();

        while(root != null || !queue.isEmpty()){

            while(root != null){
                queue.push(root);
                root = root.right;
            }

            TreeNode node = queue.pop();

            k--;

            if(k == 0) return node.val;

            root = node.left;
        }

        return -1;
    }
}
```


#### 653. 两数之和 IV - 输入 BST
[653. 两数之和 IV - 输入 BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

```java
给定一个二叉搜索树 `root` 和一个目标结果 `k`，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 `true`。

class Solution {
    Set<Integer> set = new HashSet<>();
    public boolean findTarget(TreeNode root, int k) {
        if (root == null) return false;
        if (set.contains(k - root.val)) return true;
        set.add(root.val);
        return findTarget(root.left, k) || findTarget(root.right, k);
    }
}






解法一中没有利用 BST 特性，利用 BST 中序遍历有序的特性，我们可以实现类似「双指针」的效果。

起始先让 BST 的最左链和最右链完全入栈，此时栈顶元素为 BST 中的最小值和最大值，分别使用 l 和 r 充当指针代指，根据两指针指向的节点值之和与 kk 的大小关系来指导如何让 l 和 r 移动，l 的移动过程其实就是找下一个比 l.val 更大的值，而 r 的移动过程其实就是找下一个比 r.val 更小的值。

```

## 前缀和
#### 剑指 Offer 66. 构建乘积数组
[剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

```java
给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。




class Solution {
    public int[] constructArr(int[] a) {

        /**
            两个数组 A[i]: a[0] ~ a[i - 1]  B[i]: a[i + 1] ~ a[len - 1] 
         */
        if(a == null || a.length == 0) return new int[0];
        int[] A = new int[a.length];
        int[] B = new int[a.length];
        A[0] = B[a.length - 1] = 1;

        for(int i = 1; i < a.length; i++){
            A[i] = A[i - 1] * a[i - 1];
        }

        for(int i = a.length - 2; i >= 0; i--){
            B[i] = B[i + 1] * a[i + 1];
        }

        int[] res = new int[a.length];

        for(int i = 0; i < a.length; i++){
            res[i] = A[i] * B[i];
        }        

        return res;
    }
}

```



## 数学题

#### 剑指 Offer 62. 圆圈中最后剩下的数字
[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

```java

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。



class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推,最后一轮的位置
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}



假设我们最好剩余的数字是N。

执行完“删除第三个元素”的操作后，N在新数组中的位置P的意义是什么？ ——它表示，在新数组中，N前面有还有P个元素。那么，在当前数组中，N前面一定有“P+3”个元素。 明白了这一点即可开始倒推。

最后一轮：当前有1个元素。N的位置是0；

倒数第2轮：当前有2个元素。已知在执行完“删除第三个元素”后，N在新数组中的位置是0。则说明在本轮中N前面有0+3=3个元素，所以N的位置是3，然而本轮只有2个元素，所以N的实际位置是（0+3）%2=1；

倒数第3轮：当前有3个元素。已知在执行完“删除第三个元素”后，N’在新数组中的位置是1。说明此刻，N前面有1+3=4个元素，所以N的位置是4。而当前数组只有3个元素，故实际位置是（1+3）%3=1；
```


#### 剑指 Offer 61. 扑克牌中的顺子
[剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

```java

从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。


class Solution {
    public boolean isStraight(int[] nums) {
        int joker = 0;
        Arrays.sort(nums); // 数组排序
        for(int i = 0; i < 4; i++) {
            if(nums[i] == 0) joker++; // 统计大小王数量
            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false
        }
        return nums[4] - nums[joker] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

class Solution {
    public boolean isStraight(int[] nums) {
        Set<Integer> repeat = new HashSet<>();
        int max = 0, min = 14;
        for(int num : nums) {
            if(num == 0) continue; // 跳过大小王
            max = Math.max(max, num); // 最大牌
            min = Math.min(min, num); // 最小牌
            if(repeat.contains(num)) return false; // 若有重复，提前返回 false
            repeat.add(num); // 添加此牌至 Set
        }
        return max - min < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}

```

#### 剑指 Offer 39. 数组中出现次数超过一半的数字(摩尔投票法)
[剑指 Offer 39. 数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)

```java
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

class Solution {
    public int majorityElement(int[] nums) {
        int x = 0, votes = 0, count = 0;
        for(int num : nums){
            if(votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        // 验证 x 是否为众数
        for(int num : nums)
            if(num == x) count++;
        return count > nums.length / 2 ? x : 0; // 当无众数时返回 0
    }
}
```


## 二分法


#### 剑指 Offer 53 - II. 0～n-1中缺失的数字
[剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

```java
一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。


class Solution {
    public int missingNumber(int[] nums) {
					//可能插在最后一个位置
        int left = 0, right = nums.length;

        while(left < right){

            int mid = left + (right - left) / 2;

            if(nums[mid] != mid){
                right = mid;
            }else{
                left = mid + 1;
            }
        }

        return left;
    }
}

```




## 动态规划

#### 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```java
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

class Solution {
    public int lengthOfLIS(int[] nums) {
        // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
        int[] dp = new int[nums.length];
        // base case：dp 数组全都初始化为 1
        Arrays.fill(dp, 1);

        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j])
                    dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }

        int res = 0;
        for (int i = 0; i < dp.length; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;

    }
}
```



## 回溯

#### 39. 组合总和
[39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```java
给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

candidate 中的每个元素都 互不相同

class Solution {
    List<List<Integer>> res = new LinkedList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if (candidates.length == 0) {
            return res;
        }
        backtrack(candidates, 0, target, 0);
        return res;
    }

    // 记录回溯的路径
    LinkedList<Integer> track = new LinkedList<>();

    // 回溯算法主函数
    void backtrack(int[] candidates, int start, int target, int sum) {
        if (sum == target) {
            // 找到目标和
            res.add(new LinkedList<>(track));
            return;
        }

        if (sum > target) {
            // 超过目标和，直接结束
            return;
        }

        // 回溯算法框架
        for (int i = start; i < candidates.length; i++) {
            // 选择 candidates[i]
            track.add(candidates[i]);
            sum += candidates[i];
            // 递归遍历下一层回溯树
            backtrack(candidates, i, target, sum);
            // 撤销选择 candidates[i]
            sum -= candidates[i];
            track.removeLast();
        }
    }
}



//优化

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(candidates); // 先进行排序
        backtracking(res, new ArrayList<>(), candidates, target, 0, 0);
        return res;
    }

    public void backtracking(List<List<Integer>> res, List<Integer> path, int[] candidates, int target, int sum, int idx) {
        // 找到了数字和为 target 的组合
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = idx; i < candidates.length; i++) {
            // 如果 sum + candidates[i] > target 就终止遍历
            if (sum + candidates[i] > target) break;
            path.add(candidates[i]);
            backtracking(res, path, candidates, target, sum + candidates[i], i);
            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素
        }
    }
}
```



## 队列
#### 剑指 Offer 59 - II. 队列的最大值
[剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

```java

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1


class MaxQueue {

    Deque<Integer> queue = new ArrayDeque<>();
    Deque<Integer> minQueue = new ArrayDeque<>();

    public MaxQueue() {

    }
    
    public int max_value() {

        if(minQueue.isEmpty()) return -1;
        return minQueue.peekFirst();

    }
    
    public void push_back(int value) {

        queue.offer(value);

        while(minQueue.size() > 0 && minQueue.peekLast() < value){
            minQueue.pollLast();
        }

        minQueue.offerLast(value);
    }
    
    public int pop_front() {

        if(queue.isEmpty()) return -1;

        int value = queue.pop();// pop == pollFirst

        if(value == minQueue.peekFirst()){
            minQueue.pollFirst();
        }

        return value;
    }
}


```


#### 剑指 Offer 59 - I. 滑动窗口的最大值
[剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
```java

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。



```


## 栈

#### 155. 最小栈
[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```java
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

实现 MinStack 类:

MinStack() 初始化堆栈对象。
void push(int val) 将元素val推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素。


class MinStack {

    Deque<Integer> A = new ArrayDeque<>();
    Deque<Integer> B = new ArrayDeque<>();
    public MinStack() {

    }
    
    public void push(int val) {

        A.addFirst(val);
        if(B.isEmpty()){
            B.addFirst(val);
        }else if(B.peekFirst() >= val){
            B.addFirst(val);
        }
    }
    
    public void pop() {
        int i = A.pollFirst();

        if(B.peekFirst() == i) B.pollFirst();
    }
    
    public int top() {
        return A.peekFirst();
    }
    
    public int getMin() {
        return B.peekFirst();
    }
}

```

#### 剑指 Offer 09. 用两个栈实现队列
[剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

```java
用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )

class CQueue {

    Stack<Integer> A = new Stack<>();
    Stack<Integer> B = new Stack<>();

    public CQueue() {

    }
    
    public void appendTail(int value) {

        A.push(value);
    }
    
    public int deleteHead() {

        if(A.isEmpty() && B.isEmpty()) return -1;
        if(B.isEmpty()){
            while(!A.isEmpty()){
                B.push(A.pop());
            }
        }

        return B.pop();
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```


## 位运算
#### 剑指 Offer 56 - I. 数组中数字出现的次数
[剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

```java
一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

class Solution {
    public int[] singleNumbers(int[] nums) {

        int temp = 0;

        //find the different between A and B
        for(int num : nums){
            temp = temp ^ num;
        }

        int index = 1;
        while((temp & index) == 0){

            index = index << 1;
        }

        int a = 0, b = 0;

        for(int n : nums){
            if((index & n) != 0) a ^= n;
            else b ^= n;
        }

        return new int[]{a,b};
    }
}

```