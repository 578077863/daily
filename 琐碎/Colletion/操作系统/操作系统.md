# 进程和线程

历史：
最开始，没有进程和线程的概念，一个程序就是一个任务，CPU按照顺序执行用户输入的任务。
出现的问题就是：程序是顺序执行的，一个任务正在执行的过程中，另一个任务必须等待。
这就导致了两个问题：
	1. 如果存在某些紧急任务需要执行，就必须等待前面的任务执行，
    2. 当前执行的任务可能在某些环节，CPU并不参与计算（如等待IO设备就绪），但是CPU仍被该任务占用。

为了解决这两类问题，引入了进程，引入进程后的改变：
	原来的程序是静态的，而且一次只能执行一个程序，而且不能被中断，也不能被抢占。一个任务只有两种状态：没执行，执行完了。
	而现在引入进程的主要作用是什么——**引入了一个新的状态“正在执行的程序”**。有了这个状态，我们可以指明哪个程序在执行的过程中遇到了中断，哪些程序执行到一半CPU被抢占了。说白了，引入进程本质上是为了保存程序运行途中的上下文。
	“上下文”是一个比较抽象的概念，它指的是一组软件或硬件的状态，比如当前某个寄存器保存的值、当前程序计数器指向了那个指令等，例如游戏打到一半存个档，当前的血槽、当前的金币数目都是上下文的一部分。上下文可以直接看作一组寄存器的状态和一组变量的值。（或者理解为硬件软件状态在某一刻的快照）
	能够保存存档，我就能玩玩其他存档了，于是你可以“并发”玩多个存档
	狭义上的并发就是这样产生的，**并发的基础就是上下文能够被保存与恢复。** 我们可以将进程想象为一长串**顺序**的指令流，当指令流执行完毕后，进程就退出来了，那么我们可以将这一串指令流来切开，即将这一长串指令流切为一片一片的指令片，只要CPU按照顺序执行这些指令片，也能得到和一直执行进程一样的结果。

引入进程后，由于进程切换代价大，我们由引入了线程，为什么：
	进程切换知识点
	引入线程之后，本质上是为了实现多线程，减少进程的切换。如果默认创建一个进程，那么它仅有一个执行流，我们可以称之为主线程。之前谈论的都可以看作单线程进程，进程之间的切换其实本质上是两个线程的跨进程切换。
	如果一个程序内部想要实现并发，那么程序内部能够包含多个执行流，这个执行流就是线程。如果将多个单线程进程的程序改造成多线程单进程的程序，那么执行流之间的切换，时间成本将大大降低，CPU就可以更多的执行程序本身的代码，而不是执行流切换的内核代码。

总结：线程是对程序执行流的抽象，引入线程是为了实现程序内执行流之间的并发，进而减少执行流切换的代价，同时进一步提升CPU利用率。进程侧重程序之间的并发，而线程侧重于程序内部的并发


之前说过，不管进程切换还是线程切换，本质上切换的是任务执行流。进程至少包含一个执行流，同时它管理了各种资源如内存地址空间、文件描述符等程序所拥有的资源。这个执行流就是一个线程，而线程的实现主要分为系统线程和用户线程。
系统线程之间由操作系统管理(os能够“看见”它，因为os转为为它定义了特定的结构体)。而os“看不见”用户线程。
系统线程的切换、销毁、创建等全部由os负责，但是如果系统线程过多，对操作系统来说也是不小的压力，因为系统线程的保存占用系统内存，**系统线程的调度也是需要经过“陷入内核”的 ，这个“陷入内核”将导致上下文切换，使得一部分时间不得不用来执行内核的代码。**
为了解决上下文切换这个问题，引入了协程：
协程的引用，其实就是通过线程的分时复用实现基于一对多或多对多的线程模型。
其中一个系统线程可以与多个用户线程产生映射，用户线程的切换在用户态进行，不需要上下文切换，CPU利用率进一步提高。
>再次使用上面的例子，CPU使用的会议软件有多个对话框， 每个框是一个系统线程，CPU可以看见每一个框。引入协程，一个框不再是一个用户了，而是若干个用户，每个用户都是一个用户线程。（这下子，CPU切换框的几秒钟摸鱼时间都没了，CPU快被榨干了！）
这也存在一个问题，当其中一个用户线程（协程）发起系统调用或其他阻塞操作，系统线程对应的一组用户线程（协程）都将被阻塞。因此协程一般不进行阻塞调用，一般将协程和异步IO结合使用。（框里面一个用户办点事，然后CPU开始框中服务另一个用户，前一个用户办完事后主动通知CPU我办完了，咱们继续吧）
黑皮书里提了一个解决方案：如果某个协程进行阻塞调用，就拿到一个新的系统线程，然后将其他任务迁移过去，调用返回后读取结果

总之：常规的线程通常指的是操作系统可以直接控制的系统线程，而协程是一种用户线程，一个线程与多个协程可以通过分时复用进行映射，协程的引入通过减少线程切换的次数来进一步提升CPU利用率。
但是，协程毕竟是用户级层面的，而系统线程委托给操作系统管理，操作系统直接管理CPU硬件，它将把线程映射到多核CPU的每一个核心上，实现线程（执行流）的并行执行。而协程则无法利用这一点，因为操作系统只能看见与协程关联的系统进程而已


## 区别
我们聊一聊进程与线程的区别，进程是对运行中程序的抽象，而线程是对程序执行流的抽象。进程的引入是为了保存运行到一半的程序的状态，转而可以执行别的程序，以此来实现程序之间的并发。而线程的引入同理，也是为了保存运行到一半的某条执行流，转而可以执行另外的一条执行流，以此来实现执行流之间的并行。
其实线程可以粗略地看作进程的一个子集，广义上的进程可以看作内存空间、CPU、文件描述符等资源的分配的基本单位。而狭义上的进程可以看作一个仅有一个主线程的工作单元，因此线程也称为轻量级线程。引入线程概念之前，进程即使资源分配的单位，又是程序调度和执行的基本单位。而引入线程后，“执行流”这个抽象的东西就被概念化为了“线程”，因此线程称为了描述任务执行的基本单位。
>一个程序如果能够被执行下去，那么地址空间必不可少，程序中可能涉及打开文件、申请变量等操作，而且程序想要执行也必须占用CPU这个资源。如何理解资源分配的基本单位？内存条这个硬件被操作系统管理，操作系统将内存地址分配出去是以进程为单位分配的，但是一般分配的都是逻辑地址（虚拟地址），当对应空间需要被访问时才会映射为物理地址。而CPU也是一次分配给一个进程的，CPU的作用可以粗略理解为：一行行扫描代码，然后转换为CPU指令集中的汇编指令，产生结果…执行一个范围内的代码就是一个执行流，因此线程是程序执行的基本单位。


```markdown
**1.进程和线程分别是什么？**
说道这个问题，我们需要首先说下操作系统，操作系统将硬件管理起来，提供统一管理接口供用户调用。操作系统提供一个平台，进程则在平台上完成相应的操作(比如听音乐，看电影，编辑word文档等等)。在现代的操作系统中，操作系统支持多进程，即现代操作系统支持多个进程*同时*运行。进程提供了运行的环境，具体的逻辑任务由线程来完成。

我们来系统总结下：**_进程提供一个各种资源的容器，定义了一个地址空间作为基本的执行环境；线程是一个指令执行序列，可以直接访问进程中的资源。每个进程中至少有一个线程，线程在任一时刻必属于某个进程。_**


**2.前面说现代操作系统支持多个进程同时运行，那么是如何实现同时运行呢？**

这里的同时运行，需要区分CPU多核和单核的情况。

在单核的情况下，因为只有一个CPU，所以只能是在某一个时候只有一个进程在运行，操作系统采用了“分时”的办法。

首先，我们可以将进程想象为一长串**顺序**的指令流，当指令流执行完毕后，进程就退出来了，那么我们可以将这一串指令流来切开，即将这一长串指令流切为一片一片的指令片，只要CPU按照顺序执行这些指令片，也能得到和一直执行进程的结果。

当有多个进程的时候，我们将每个进程都切为对应的片，每隔一定时间来执行某个进程的片，之后在切换到另一个进程的片，这样就达到了“同时运行”的效果。只要时间片是很短暂的，小于人的感知时间(大约100ms到200ms)，就可以让人感觉不到进程在切换。

多核的情况和单核的情况相似，也是采用“分时”的方法。只不过是多核有多个处理器。这里可以把每个核想象为一个个单核就可以了。

到这里，大家就知道了如何达到多进程并行的效果，那么这**需要操作系统提供什么呢？**

很显然，操作系统要想完成分时的效果，需要做如下的事情：
> 1.  维护一个全局的进程表，记录当前哪些进程正在被执行。      
> 2.  将时间分为适当的片段。  
> 3.  在进程间实施切换，即保存上一个进程的执行环境信息，恢复下一个进程的执行环境。


**3.进程在操作系统中是怎么来的和怎么没的呢？**

在操作系统启动的时候，需要先把进程的运行环境全部创建起来，为进程的运行打好基础。创建一个进程即为进程建立基本的执行环境，然后将其加入到系统的全局进程表中，这样进程就能获得相应的资源来运行。

而进程的退出则是通知操作系统将其由全局进程表中去除，之后销毁此进程所有的资源。一般，系统会有检测的功能，当发现某个进程不正常的时候，操作系统可以将这个进程*杀掉*,从而释放对应的资源。


**4.既然进程就能达到并行的目的，那么为什么还需要线程呢？**

总地说来，是因为线程比进程成本更低。因为创建一个进程需要为其分配各种资源，而线程只需要使用进程事先分配好的即可；进程之间的通信成本也会较高，而线程则是在一个进程的环境下，通信起来会很方便。其实，我们可以把线程看做是一个“轻量级”的进程。


**5.线程的创建和切换是什么样子的？**

线程的创建其实和进程类似，也是建立起来线程的执行环境，比如分配线程所需要的数据结构和调用栈，完成这些数据结构的初始化操作。虽然这些操作比较于进程是很轻量级的，但是频繁创建和销毁也会是不可忽视的消耗。所以当需要频繁创建和销毁线程的时候，可以考虑线程池式的方式来解决消耗过大的问题。

进程中的多个线程执行的时候，是乱序的，即在某个时刻执行哪个线程，是不确定的，所以多线程的问题会比较难以调试。对于线程来说，是有用户态和内核态的区别，当进行线程切换的时候，如果线程是用户态，是需要切换为内核态的，这种切换也是需要耗费资源，不过目前随着硬件的发展，这部分切换的成本正在减少，所以，这部分的开销是可以接受的，大部分情况下，我们可以忽略线程的切换。



**6.线程的调度算法**

在这里我们先需要来了解下如何评价算法。调度算法的准则大约有如下的方面：

> 1.  公平性，在选择下一个运行的线程时，要考虑同等地位的线程必须有相同的机会来获取处理器执行权。  
>     
> 2.  CPU有效利用，即只要有进程和线程在等待，CPU就不能空闲。

对于不同类型的操作系统会对算法有不同的需求，例如：实时操作系统对于响应时间有最低的要求。

调度算法可以分为非抢占式和抢占式，在非抢占式系统中，一个线程一旦被选择在处理器上执行，就一直运行，直到阻塞或自愿放弃或退出。我们可以看到，这类算法如果一个线程陷入长时间的处理中时，系统就无法切换其它的线程，容易造成其它线程的饿死。而抢占式系统中，一个线程被选中后，允许运行的时间长度有最大的限制，当到达这个时间后，就被迫放弃执行权，由系统来决定下一个执行的线程。
```