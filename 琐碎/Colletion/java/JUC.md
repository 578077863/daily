## 1. 为什么需要并发
通过并发编程的形式可以充分发挥多核CPU的性能，减少cpu空闲时间，提高程序响应速度

## 2. 并发编程有哪些缺点
### 2.1 上下文切换开销

什么情况会发生线程上下文切换：
 1. 线程的cpu时间片用完
 2. 垃圾回收
 3. 有更高优先级的线程需要运行
 4. 线程自己调用了 sleep , yield , wait , join , park , synchronized , lock等方法

Context Switch发生时,需要由操作系统保存当前线程的状态,并恢复另一个线程的状态,Java中对应的概念就是程序计数器,其作用是记录了下一条JVM指令的执行地址
* 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
* Context Switch 频繁发生会影响性能


减少上下文切换的思路：
	1. 无锁并发编程，可以参照concurrentHashMap锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。
	2.CAS算法，利用Atomic下使用CAS算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换
	3.使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态
	4.协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换
### 2.2 线程安全
什么是线程安全
	多个线程同一时刻对同一份资源做写操作时（读操作不会涉及到线程安全），如果结果和我们预期的一样，则是线程安全
	eg：抢火车票
### 2.3 死锁

由死锁联想到 redis分布式锁
### 2.4 增加资源消耗
线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程
### 2.5 设计更加复杂
[[MySQL#隔离级别]]
MySQL隔离级别就是为了解决线程并发带来的问题所设计的

## 3. 基础知识
### 3.1 同步与异步
同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行，比如，主线程中突然另外一个线程加入，t.join(),主线程被挂起，只有t线程完成后才能继续前行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者

### 3.2 并发与并行
并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。

### 3.3 阻塞和非阻塞
阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行

### 3.4 临界区
临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。

### 3.5 进程 & 线程


1. 联系：
  线程是进程中的一部分，一个进程可以有多个线程，但线程只能存在于一个进程中。

2.区别：

 根本区别：进程是操作系统资源调度的基本单位，线程是任务的调度执行的基本单位

 开销方面：进程都有自己的独立数据空间，程序之间的切换开销大；线程也有自己的运行栈和程序计数器，线程间的切换开销较小，更加轻量。

 比如说，一个web服务器，在接受一个新的请求的时候，可以大动干戈的fork一个子进程去处理这个请求，也可以只在进程内部创建一个新的线程来处理。线程更加轻便一点。线程可以有很多，但他们并不会改变进程对内存（heap）等资源的管理，线程之间会共享这些资源。

 共享空间：进程拥有各自独立的地址空间、资源，所以共享复杂，需要用IPC（Inter-Process Communication，进程间通信），但是同步简单。而线程共享所属进程的资源，因此共享简单，但是同步复杂，需要用加锁等措施。

  
进程和线程的主要差别在于**它们是不同的操作系统资源管理方式**。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，**而线程只是一个进程中的不同执行路径**。线程有自己的堆栈和局部变量，但**线程之间没有单独的地址空间**，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

联想：[[#4 java线程]]

[[操作系统#进程和线程]]


## 4. java线程
Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一条线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。所以synchronized是Java语言中的一个重量级操作。在JDK1.6中，虚拟机进行了一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态中

### 4.1 线程状态及状态转变方式
- 线程状态
	1.  NEW –> RUNNABLE
	    
	    -   当调用了t.start()方法时，由 NEW –> RUNNABLE
	        
	2.  RUNNABLE <–> WAITING
	    
	    -   当调用了t 线程用 synchronized(obj) 获取了对象锁后
	        
	        -   调用 obj.wait() 方法时，t 线程从 RUNNABLE –> WAITING
	            
	        -   调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时
	            
	            -   竞争锁成功，t 线程从 WAITING –> RUNNABLE
	                
	            -   竞争锁失败，t 线程从 WAITING –> BLOCKED
	                
	3.  RUNNABLE <–> WAITING
	    
	    -   当前线程
	        
	        调用 t.join() 方法时，当前线程从 RUNNABLE –> WAITING
	        
	        -   注意是**当前线程**在t 线程对象的监视器上等待
	            
	    -   t 线程**运行结束**，或调用了**当前线程**的 interrupt() 时，当前线程从 WAITING –> RUNNABLE
	        
	4.  RUNNABLE <–> WAITING
	    
	    -   当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –> WAITING
	        
	    -   调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –> RUNNABLE
	        
	5.  RUNNABLE <–> TIMED_WAITING
	    
	    t 线程用 synchronized(obj) 获取了对象锁后
	    
	    -   调用 obj.wait(**long n**) 方法时，t 线程从 RUNNABLE –> TIMED_WAITING
	        
	    -   t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时
	        
	        -   竞争锁成功，t 线程从 TIMED_WAITING –> RUNNABLE
	            
	        -   竞争锁失败，t 线程从 TIMED_WAITING –> BLOCKED
	            
	6.  RUNNABLE <–> TIMED_WAITING
	    
	    -   当前线程调用 t.join
	        
	        (long n) 方法时，当前线程从 RUNNABLE –> TIMED_WAITING
	        
	        -   注意是当前线程在t 线程对象的监视器上等待
	            
	    -   当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –> RUNNABLE
	        
	7.  RUNNABLE <–> TIMED_WAITING
	    
	    -   当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –> TIMED_WAITING
	        
	    -   当前线程等待时间超过了 n 毫秒，当前线程从 TIMED_WAITING –> RUNNABLE
	        
	8.  RUNNABLE <–> TIMED_WAITING
	    
	    -   当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –> TIMED_WAITING
	        
	    -   调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–> RUNNABLE
	        
	9.  RUNNABLE <–> BLOCKED
	    
	    -   t 线程用 synchronized(obj) 获取了对象锁时如果**竞争失败**，从 RUNNABLE –> BLOCKED
	        
	    -   持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –> RUNNABLE ，其它**失败**的线程仍然 BLOCKED
	        
	10.  RUNNABLE <–> TERMINATED
		* 当前线**程所有代码运行完毕**，进入 TERMINATED
![[Pasted image 20220211120101.png]]

操作系统中的 Ready 和 Running 状态 合起来对应 java Runnable状态

为什么要合起来

因为 主流JVM的底层系统调度全交给操作系统,所以jvm启动线程后进入runnable,这时候线程处于操作系统调度中,可以处于运行中（内核态）或者阻塞（挂起到用户态），所以jvm并不知道它启动以后的线程是处于操作系统阻塞还是操作系统运行中，因此笼统得称之为runnable。
现在的时分多任务操作系统架构 通常都是用 时间片轮转的方式进行抢占式调度，通常 Java的线程状态是服务于监控的,由于线程的上下文切换速度对于人来说非常快,那么区分ready 与 running 就没什么意义

### 4.2 线程使用方式
1. 继承Thread类
 通过继承Thread类重写 run方法
2. 实现Runnable接口
 通过实现Runnable接口中的run方法，然后将实现该接口的类的实例作为参数传给Thread的实例，由Thread的实例调用start方法	
3. 实现Callable接口
 实现Callable接口，返回值通过FutureTask进行封装

 
**Java 线程调用 start->start0 这个本地方法，实际上会调用到 JVM_StartThread 方法，而 JVM_StartThread方法中会创建与平台相关的本地线程，该线程执行 Java 线程的 run 方法。**
**创建线程只有一种方式就是构造Thread类,而实现线程的执行单元有两种方式**

实现接口和继承Thread比较
实现接口会更好一些，因为:
-   从共享资源来看，Runnable接口更适合（因为都是同一个Runnable实例）
-   从继承角度看，Runnable更适合，因为接口可以多继承，类只能单继承，这样不利于扩展


### 4.3 基础线程机制
#### Executor
通常是管理多个互不干扰，不需要进行同步操作的任务的执行，无需程序员显示地管理线程地生命周期
主要的Executor：


手写Executor：


#### Daemon
守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。

当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

main() 属于非守护线程。

在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。


#### sleep
Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。

sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

#### yield
对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。


### 4.5 synchronized及锁升级
jdk1.6的优化是：
1. 锁升级机制
2. 锁消除。锁消除是一种编译器优化，通过逃逸分析消除部分无必要的同步代码。
3. 锁粗化。在编译期间将相邻的同步代码块合并成一个大的同步代码块，减少反复申请、释放造成的开销。（即使每次都可以获得锁，那么频繁的操作底层同步队列也将造成不必要的消耗）
4. 自适应自旋锁。synchronizedCAS占用owner失败后，会进行自旋尝试，这个时间不是固定的，而是**前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定的**


锁的状态取决于对象头的mark word低两位。

锁升级是单向的（也不一定，和JVM的实现有关）：

创建锁记录(Lock Record) 对象 , 每个线程的栈帧都会包含一个锁记录的结构,内部可以存储锁定对象的Mark Word

Synchronized经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。

#### 特点:

1.  原子性
    
    > 线程操作同步块代码时，是**原子**的（即使OS层面存在线程切换，但是java层面我们将线程访问共享变量的整套同步代码的操作看作是原子的
    
2.  可见性
    
    > 同步块具有**可见性**，线程**写共享同步块内的共享变量**，会使得其他线程保存该共享变量的对应缓存行**失效**，读共享变量则会重新从主存中去读取。
    
3.  有序性
    
    > synchronized块内的代码不会被重排序到synchronized块外。（synchronized同步块可以看作单线程，遵循as-if-serial，会进行重排序优化）

#### 锁升级过程中mark word存储的变化：

当对象状态为**偏向锁**时，mark word存储的是**偏向的线程ID**，当状态为**轻量级锁**的时候，存储的是**指向线程栈中 lock record(锁记录对象) 的指针**，当状态为**重量级锁**的时候，**指向堆中monitor对象的指针**。

线程在进入同步块之前，JVM会在当前线程的栈帧中创建一个**锁记录 lock record**（不同的锁类型对lock record具有不同的处理，偏向锁中lock record是存在的,但存储对象的mark word 为 null，所以偏向锁调用锁对象的hashcode会撤销偏向锁状态，因为lock record没有创建所以mark word和偏向锁有关的信息就丢失了，而轻量级锁和重量级锁中保存了lock record的地址），这个结构用于保存对象头mark word初始结构的复制，称为**displaced mark word**

其中displaced mark word用于保存对象mark word未锁定状态下的结构（用于替换——**因为mark word的结构依据锁的状态不同动态变化着，因此必须有一个结构用于保存mark word的原始状态**，这个结构就是保存在线程栈帧中的displaced mark word）。

#### Monitor
[[JVM#Monitor]]
#### 偏向锁

偏向锁——一段同步代码总是被一个线程所访问（不存在另外一个线程），那么该线程会自动获取锁，降低获取锁的代价。（单线程环境下都是偏向锁） 偏向锁在一个线程第一次访问的时候将该线程的id记录下来，下次判断如果还是该线程就不会加锁了。如果有另一个线程也来访问它，说明有可能出现线程并发。此时偏向锁就会升级为轻量级锁。

偏向锁的目的——在某个线程获得锁之后，消除这个线程重入（CAS）的开销，看起来让这个线程得到了偏向。 偏向锁只需要在设置thread ID时进行一次CAS操作，后续发生重入时仅仅进行简单的thread id检查，**并且向线程栈帧中添加一个空的lock record表示重入**，不需要CAS指令。（偏向锁一旦被某个线程获得，除非出现竞争导致撤销，否则线程不会主动释放锁即thread id只能被设定一次）

如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起（走到安全点后stop the world），JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。

偏向锁是对单线程场景下的优化，例如消除第三方框架同步代码带来的性能损失

##### 批量重偏向
当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程

##### 批量撤销
当撤销偏向锁的阈值超过40以后，就会将**整个类的对象都改为不可偏向的**

#### 轻量级锁

使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化

线程试图占用轻量级锁时，必须使用CAS指令，这是相对于偏向锁提升的开销。轻量级锁在对象头的mark word体现，就是一个指向lock record的指针（偏向锁则是thread id）。 线程monitorenter时，栈帧中创建一个锁记录结构，将锁记录的Object reference 指向锁对象，然后将对象的mark word的值存入到锁记录中，**然后使用CAS试图修改对象mark word的值为lock record地址值和状态**，成功则代表成功获取锁，失败则要么存在重入，或者存在竞争并通知JVM执行锁升级

轻量级锁适用于线程交替执行同步块的情况，如果存在同一时间访问同一锁即冲突访问的情况，就会导致轻量级锁膨胀为重量级锁。在线程总是能交替执行的场景（并发量小、同步代码执行快速），可以防止monitor对象的创建。

轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能

如果CAS替换成功,对象头中存储了锁记录地址和状态00,表示由线程给对象加锁

如果CAS失败,**如果发现是其他进程来竞争,首先会进行自旋锁,自旋一定次数后还是失败就进入锁膨胀过程,** 如果发现锁的持有者是自己,则再添加一条Lock Record作为重入的计数,退出synchronized时,如果有取值的null的锁记录,则重置锁记录,表示重入数减1,若锁记录的值不为null,则使用cas将Mark Work的值恢复给对象头(就是替换掉对象头的值),替换成功,解锁,替换失败,说明轻量级锁已经进行了锁膨胀或已经升级到重量级锁,进入重量级锁的解锁流程

调用一个对象的hashcode会撤销掉该对象的偏向锁,但其他锁没影响,因为有存储锁信息的地方(线程栈帧的锁记录里,Monitor对象里)

轻量级锁在没有竞争时(也就是当前只有自己一个线程),每次重入都需要执行CAS操作,JDK6引入了偏向锁来做优化 : 只有第一次使用CAS将线程ID设置到对象的Mark Word头, 之后发现这个线程ID是自己的就表示没有竞争,不用重新CAS.以后只要不发生竞争,这个对象就归该线程所有

##### 流程图片

![image-20211114174217419](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\image-20211114174217419.png?lastModify=1644675866)

![image-20211114174617695](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\image-20211114174617695.png?lastModify=1644675866)

![image-20211114174657339](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\image-20211114174657339.png?lastModify=1644675866)




#### 重量级锁

如果显示调用了hashCode()、notify、wait方法则会导致对象直接升级为重量级锁


**自旋优化:重量级锁竞争的时候,使用自旋来优化**

锁膨胀流程:

为Object对象申请Monitor锁,让Object指向重量级锁地址,然后竞争的线程进入Monitor的EntryList,自身状态变成blocked

**当持有对象的线程退出同步块解锁时,使用CAS将Mark Word的值恢复给对象头,失败.进入重量级锁解锁流程,按照Monitor地址找到Monitor对象,设置Owner 为 nul,**
唤醒EntryList中的Blocked线程.

重量级锁之所以重是因为底层依赖OS的mutex互斥量实现，依赖堆中的monitor对象（Hotspot对应objectMonitor实现）。 当然了，如果单线程下，或者不存在“竞争明显”的情况下，没有线程会被挂起，也不会出现进程切换，但是仍然需要为使用的锁对象创建绑定的monitor并且频繁CAS设置owner。用户态与内核态的切换主要是由于park()底层涉及系统调用导致的，如果CPU上下文切换的时间接近同步代码的执行时间，那么就显得效率很低下。

##### 锁膨胀

尝试加轻量级锁过程中,CAS操作无法成功,需要进行锁膨胀,将轻量级锁变为重量级锁

![image-20211114175849415](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\image-20211114175849415.png?lastModify=1644677687)

![image-20211114180015604](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\image-20211114180015604.png?lastModify=1644677687)
Monitor获取失败到陷入阻塞中间有自旋优化,如果成功则避免阻塞

自旋会占用cpu,得多核才有优势


**自旋优化:重量级锁竞争的时候,使用自旋来优化**

锁膨胀流程:

为Object对象申请Monitor锁,让Object指向重量级锁地址,然后竞争的线程进入Monitor的EntryList,自身状态变成blocked

当持有对象的线程退出同步块解锁时,使用CAS将Mark Word的值恢复给对象头,失败.进入重量级锁解锁流程,按照Monitor地址找到Monitor对象,设置Owner 为 nul,

唤醒EntryList中的Blocked线程.

重量级锁之所以重是因为底层依赖OS的mutex互斥量实现，依赖堆中的monitor对象（Hotspot对应objectMonitor实现）。 当然了，如果单线程下，或者不存在“竞争明显”的情况下，没有线程会被挂起，也不会出现进程切换，但是仍然需要为使用的锁对象创建绑定的monitor并且频繁CAS设置owner。用户态与内核态的切换主要是由于park()底层涉及系统调用导致的，如果CPU上下文切换的时间接近同步代码的执行时间，那么就显得效率很低下。



##### 重量级锁为什么重
synchronized 底层是利用 monitor 对象，CAS 和 mutex 互斥锁(量)来实现的，内部会有等待队列(cxq 和 EntryList)和条件等待队列(waitSet)来存放相应阻塞的线程。

未竞争到锁的线程存储到等待队列中，获得锁的线程调用 wait 后便存放在条件等待队列中，解锁和 notify 都会唤醒相应队列中的等待线程来争抢锁。

然后由于阻塞和唤醒依赖于底层的操作系统实现，(这里说下JVM线程是1对1关系)系统调用存在用户态与内核态之间的切换，所以有较高的开销，因此称之为重量级锁。

所以又引入了自适应自旋机制，来提高锁的性能。