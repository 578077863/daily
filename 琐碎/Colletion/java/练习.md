## Java 语言的特点
面向对象（封装，继承，多态）；
平台无关性（ Java 虚拟机实现平台无关性）；
支持多线程（而 Java 语言却提供了多线程支持）；；
支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；
编译与解释并存；(重点讲.class->机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。)


## JVM,JDK和JRE
Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。
JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

#### 什么是字节码?采用字节码的好处是什么?
在 Java 中，JVM 可以理解的代码就叫做**字节码**（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。

JDK它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。 JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。


## Java的基本数据类型有哪些？
Java 中有 8 种基本数据类型，分别为：

1. 6 种数字类型 ：`byte`、`short`、`int`、`long`、`float`、`double`
2. 1 种字符类型：`char`
3. 1 种布尔型：`boolean`。
![[Pasted image 20220206190701.png]]

另外，对于 `boolean`，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。

**注意：**

1.  Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
    
2.  `char a = 'h'`char :单引号，`String a = "hello"` :双引号。
    

这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。

包装类型不赋值就是 `Null` ，而基本类型有默认值且不是 `Null`。

另外，这个问题建议还可以先从 JVM 层面来分析。

基本数据类型直接存放在 Java 虚拟机栈中的局部变量表中，而包装类型属于对象类型，我们知道对象实例都存在于堆中。相比于对象类型， 基本数据类型占用的空间非常小。

> 《深入理解 Java 虚拟机》 ：局部变量表主要存放了编译期可知的基本数据类型 **（boolean、byte、char、short、int、float、long、double）**、**对象引用**（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

## 什么是值传递和引用传递
java中的所有参数传递都是值传递，对于基本类型就是字面量，而对于引用类型就是地址值。

## 自动装箱和拆箱
-   **装箱**：将基本类型用它们对应的引用类型包装起来；
-   **拆箱**：将包装类型转换为基本数据类型；

-   `Integer i = 10` 等价于 `Integer i = Integer.valueOf(10)`
-   `int n = i` 等价于 `int n = i.intValue()`

-   赋值操作（装箱或拆箱）
-   进行加减乘除混合运算 （拆箱）
-   进行>,<,==比较运算（拆箱）
-   调用equals进行比较（装箱）
-   ArrayList、HashMap等集合类添加基础类型数据时（装箱）


## String为什么不可变

[[背诵/笔记#String StringBuilder StringBuffer]]


#### 常用方法
  
-   indexOf()：返回指定字符的索引。
-   charAt()：返回指定索引处的字符。
-   replace()：字符串替换。
-   trim()：去除字符串两端空白。
-   split()：分割字符串，返回一个分割后的字符串数组。
-   getBytes()：返回字符串的 byte 类型数组。
-   length()：返回字符串长度。
-   toLowerCase()：将字符串转成小写字母。
-   toUpperCase()：将字符串转成大写字符。
-   substring()：截取字符串。
-   equals()：字符串比较。

  

## 什么是字符串常量池？

字符串常量池（String Pool）保存着所有字符串字面量，这些字面量在编译时期就确定。字符串常量池位于堆内存中，专门用来存储字符串常量。在创建字符串时，JVM首先会检查字符串常量池，如果该字符串已经存在池中，则返回其引用，如果不存在，则创建此字符串并放入池中，并返回其引用。


## Object常用方法有哪些？

Object常用方法有：`toString()`、`equals()`、`hashCode()`、`clone()`、`getClass()`等。

**toString**：默认输出对象地址。可以重写toString方法，按照重写逻辑输出对象值。

**equals**：默认比较两个引用变量是否指向同一个对象（内存地址）。

**hashCode**：将与对象相关的信息映射成一个哈希值，默认的实现hashCode值是根据内存地址换算出来。

**clone**：可以实现对对象中各个属性的复制。

**getClass**：返回此 Object 的运行时类，常用于java反射机制。

**wait**：当前线程调用对象的wait()方法之后，当前线程会释放对象锁，进入等待状态。等待其他线程调用此对象的notify()/notifyAll()唤醒或者等待超时时间wait(long timeout)自动唤醒。线程需要获取obj对象锁之后才能调用 obj.wait()。

**notify**：唤醒在此对象上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象上等待的所有线程。



## 讲讲深拷贝和浅拷贝,如何实现对象克隆？？

  
-   实现`Cloneable`接口，重写 `clone()` 方法。这种方式是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。如果对象的属性的Class也实现 `Cloneable` 接口，那么在克隆对象时也会克隆属性，即深拷贝。
-   结合序列化，深拷贝。


## Java创建对象有几种方式？
  
-   用new语句创建对象。
-   使用反射，使用Class.newInstance()创建对象。
-   调用对象的clone()方法。
-   运用反序列化手段，调用java.io.ObjectInputStream对象的readObject()方法。


## 说说类实例化的顺序
1.  静态属性，静态代码块。
2.  普通属性，普通代码块。
3.  构造方法。


  

## equals和\==有什么区别
-   对于基本数据类型,\==比较的是他们的值。基本数据类型没有equal方法；
    
-   对于复合数据类型，\==比较的是它们的存放地址(是否是同一个对象)。equals()默认比较地址值，重写的话按照重写逻辑去比较。



## final, finally, finalize 的区别
  
-   final 用于修饰属性、方法和类, 分别表示属性不能被重新赋值，方法不可被覆盖，类不可被继承。
-   finally 是异常处理语句结构的一部分，一般以`try-catch-finally`出现，`finally`代码块表示总是被执行。
-   finalize 是Object类的一个方法，该方法一般由垃圾回收器来调用，当我们调用`System.gc()`方法的时候，由垃圾回收器调用`finalize()`方法，回收垃圾，JVM并不保证此方法总被调用。


[[背诵/笔记#final关键字的作用和用法]]

## 方法重载和重写的区别
[[背诵/笔记#多态 重载和重写]]

## 接口与抽象类区别？
[[背诵/笔记#接口和抽象类]]]


## 常见的Exception有哪些,Error和Exception的区别,运行时异常和非运行时异常（checked）的区别？

[[Java基础#异常]]


## BIO/NIO/AIO区别的区别？

[[背诵/笔记#IO]]

同步阻塞IO : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。

同步非阻塞IO: 客户端与服务器通过Channel连接，采用多路复用器轮询注册的`Channel`。提高吞吐量和可靠性。用户进程发起一个IO操作以后，可做其它事情，但用户进程需要轮询IO操作是否完成，这样造成不必要的CPU资源浪费。

异步非阻塞IO: 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。用户进程发起一个IO操作，然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类似Future模式。


### 同步和异步的区别？
同步：发出一个调用时，在没有得到结果之前，该调用就不返回。

异步：在调用发出后，被调用者返回结果之后会通知调用者，或通过回调函数处理这个调用。

select 在消息通知这块是异步的

## 守护线程是什么？

[[JUC#Daemon]]


## 阻塞和非阻塞的区别？

阻塞和非阻塞关注的是线程的状态。

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会恢复运行。

非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

> 举个例子，理解下同步、阻塞、异步、非阻塞的区别：
> 
> 同步就是烧开水，要自己来看开没开；异步就是水开了，然后水壶响了通知你水开了（回调通知）。阻塞是烧开水的过程中，你不能干其他事情，必须在旁边等着；非阻塞是烧开水的过程里可以干其他事情。



## 什么是序列化和反序列化？
序列化：把内存中的对象转换为字节序列的过程。

反序列化：把字节序列恢复为Java对象的过程。

[[Java基础#序列化和反序列化]]


## 线程池
### 有几种方式实现
```markdown

fixedThreadPool
```

### 拒绝策略

```markdown
丢掉最古老的,然后提交任务
丢掉当前任务
直接抛出异常
让提交任务的线程去执行
```
