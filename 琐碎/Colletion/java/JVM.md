# Java对象内存组成
每个java对象在内存布局中由三部分组成：**对象头**、**实例数据**和**填充数据/对齐填充**。

其中对象头又可以分为两部分：**标记字段 mark word** 和 **类型指针**
## Java对象头

32位虚拟机

```markdown
普通对象
|--------------------------------------------------------------|
|                  Object Header (64 bits)                     |
|------------------------------------|-------------------------|
| Mark Word (32 bits)                | Klass Word (32 bits)    |
|------------------------------------|-------------------------|




数组对象
|---------------------------------------------------------------------------------|
|                             Object Header (96 bits)                             |
|--------------------------------|-----------------------|------------------------|
| Mark Word(32bits)              | Klass Word(32bits)    | array length(32bits)   |
|--------------------------------|-----------------------|------------------------|

Mark Word 结构
|-------------------------------------------------------|--------------------|
|                  Mark Word (32 bits)                  | State              |
|-------------------------------------------------------|--------------------|
| hashcode:25 | age:4 | biased_lock:0              | 01 | Normal             |
|-------------------------------------------------------|--------------------|
| thread:23 | epoch:2 | age:4 | biased_lock:1      | 01 | Biased             |
|-------------------------------------------------------|--------------------|
| ptr_to_lock_record:30                            | 00 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
| ptr_to_heavyweight_monitor:30                    | 10 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                                  | 11 | Marked for GC      |
|-------------------------------------------------------|--------------------|

```
![[Pasted image 20220211141514.png]]

# 基础知识

### 程序计数器
在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。

任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。

它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。**字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。**

它是唯一一个在Java虚拟机规范中没有规定任何outotMemoryError情况的区域。

**PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。**

### Class文件
[Class类文件结构简介 - 开心的鱼a1 - 博客园 (cnblogs.com)](https://www.cnblogs.com/dw-haung/p/9764352.html)

**魔数与Class文件的版本**
每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。

 **常量池**
 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。

**类索引、父类索引与接口索引集合**
这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中

## Monitor
 Monitor被翻译为监视器或管程
每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针
![[Pasted image 20220211153227.png]]

synchronized 字节码层面是 首先拿到引用地址,复制一份存储到一个临时变量(slot 1) , 将 lock对象的 MarkWord 置为 Monitor指针

操作完后 aload_1 拿到lock引用 , monitorexit 将lock对象的MarkWord重置,唤醒EntryList

如果在同步代码块出现异常, 也是会释放锁的(拿到引用地址,重置,唤醒,抛出异常)



synchronized包裹的内容可以是字符串、class对象、this（synchronized实例方法包裹的是this，而synchronized类方法包裹的是class对象）等。不管它包裹的什么，那一定是一个对象。

包裹对象,方法,同步代码块

monitor在底层，对应C++定义的objectMonitor。

**synchronized关联的是monitor结构，而monitor和Object对象绑定**

![img](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\20200608145148.png?lastModify=1644678223)

-   当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)**是否绑定了Monitor**。
    
    -   如果**没有绑定**，则会先去去与Monitor绑定，并且将Owner设为当前线程。
        
    -   如果已经绑定，则会去查询该Monitor是否已经有了Owner
        
        -   如果没有，则Owner与将当前线程绑定
            
        -   如果有，则放入EntryList，进入阻塞状态(blocked)
            
        
        > 在并发情况下,线程执行到临界区代码时,会尝试一次CAS使自己成为 Owner,如果第一次CAS失败则说明抢占失败, 接着会尝试自适应自旋,在自旋期间如果成功就将Owner修改为自己,并且将count加一。执行完毕将count减一，复位owner，并且唤起entryList阻塞的线程（实现上通常唤醒队头线程，不过如果没抢到还会进入entryList队尾，通常流动性很大，不会出现饥饿）。 如果失败就进入Monitor的EntryList同步队列,并且 调用park()阻塞当前线程,底层对应系统调用**将当前线程对象映射到的操作系统线程挂起，并让出CPU**
        > 
        > owner线程调用wait，则进入waitSet并阻塞（同样对应park调用），同时让出CPU。只有其他线程调用notify它才会被唤醒，而且唤醒后进入entryList，当owner被复位后，同entryList其他线程进行竞争，当成为owner将从原执行位置继续向下执行。
        

-   当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于**阻塞**状态的线程会被**叫醒并竞争**，此时的竞争是**非公平的**
    
-   **注意**：
    
    -   对象在使用了synchronized后与Monitor绑定时，会将对象头中的**Mark Word**置为Monitor指针。
        
    -   每个对象都会绑定一个**唯一的Monitor**，如果synchronized中所指定的对象(obj)**不同**，则会绑定**不同**的Monitor

## Lock Record
锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word



## 栈
[(53条消息) JVM之栈详解_可小辉的博客-CSDN博客_jvm栈](https://blog.csdn.net/weixin_44364444/article/details/110248863)
```markdown

栈（stack）又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。
主管程序运行，生命周期和线程同步，线程结束，栈内存就释放了。**不存在垃圾回收问题**

JVM 栈描述的是每个线程 Java 方法执行的内存模型：每个方法被执行的时候，JVM 会同步创建一个栈帧用于存储_局部变量表、操作数栈、动态链接、方法出口_ 等信息。

栈是运行时单位，而堆是存储的单位，即栈解决的是运行问题，即程序如何执行，或者如何处理数据，功能类似于计算机硬件 PC寄存器。堆解决的是数据存储的问题，即数据怎么放、放哪儿。

特点

访问速度快，仅次于程序计数器
线程私有
存在 OOM，不存在 GC
```

是一个只能在表尾进行插入和删除操作的线性表，其生命周期和线程同步，线程结束，栈内存就释放，不存在垃圾回收的问题
**JVM 栈描述的是每个线程 Java 方法执行的内存模型**：每个方法被执行的时候，JVM 会同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息

方法一旦执行完毕，栈帧出栈，里面的局部变量直接就从内存里清理掉了。

**栈与堆的区别**

栈是运行时单位，而堆是存储的单位，即栈解决的是运行问题，即程序如何执行，或者如何处理数据，功能类似于计算机硬件 PC寄存器。堆解决的是数据存储的问题，即数据怎么放、放哪儿。


特点
-   访问速度快，仅次于程序计数器
-   线程私有
-   存在 OOM，不存在 GC

**存放的类型**：8种数据类型、对象的引用、实例的方法


总结
```markdown

栈的数据结构，JVM虚拟机栈用来描述什么，栈与堆的区别，虚拟机栈的特点，存放的类型,OOM情况

栈帧的定义，栈帧结构（局部变量表），操作数栈，动态链接，返回地址
[(53条消息) JVM栈帧内部结构-局部变量表_chenxi_blog的博客-CSDN博客_局部变量表结构](https://blog.csdn.net/qq_20394285/article/details/104673874)

**方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。**
```


## 运行时常量池
该区域是方法区的一部分。Class文件中有除了类的版本、字段、方法、接口外，还有一个常量池表，这个常量池表在类加载后会存放到运行时常量池中。运行时常量池具有动态性，Class中的常量池没有动态性。因为Java可以在运行时产生常量，该常量也会进入到常量池中，如String.intern()方法


## JVM如何判断两个类相同
①类的全限定名是否相等
②类加载器是否相等
即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类


# 类与对象
 类就是模板，是图纸，实例是具体的实现，是解决问题具体的单位。类在C语言中就是一个结构体，包含若干类型看作成员，并且提供操作这些成员方法。而成员具体的值根据实例的不同而不同。

 ## 类
 ### 类加载过程
  谈论“动态、运行期”的前提一定是JVM实例被创建后。我们在写代码的时候，JVM根本就没有启动，甚至编译期都谈不上，只是在编译期上写“文本”罢了。而智能提示是正在运行中的“IDE”提供的功能。（在记事本还是IDE中写代码，没区别，本质上都是写文本，“人能看懂，计算机看不懂”，当变成二进制形式的字节码，只有JVM能看懂，当翻译成汇编语言后，硬件（CPU）才能看懂）
>  java.exe要做的事情：
>【1】根据JVM配置，在内存为JVM的运行申请内存空间
>【2】创建引导类加载器（bootstrap），初步加载子系统到JVM方法区（lib包下的jar）
>【3】创建JVM启动器实例（JVM实例：Laucher）,扩展类加载器（extension）和系统类（application）加载器都是launcher实例的内部类，laucher.getClassLoader()获得类加器实例
>【4】使用类加载器实例加载public类（主类），调用主类的main()方法
>【5】java程序开始运行…运行结束则JVM销毁


 >[JVM实例与java程序的关系_用户2894347827_新浪博客 (sina.com.cn)](http://blog.sina.com.cn/s/blog_ac843e3301016j5p.html)

类想要被使用，一定要先载入虚拟机内存（映射到JVM申请的内存地址范围）。主类被正式载入内存前，引导类加载器已经加载不少类进入内存了。

#### 加载
 加载顾名思义，就是将一个class文件从硬盘载入内存，将class文件映射到JVM的内存地址范围内。
三阶段：
【1】通过一个类的全限定类名获取定义该类的二进制字节流
【2】将字节流包含的信息转换为方法区的运行时数据结构
【3】在堆内存生成一个该class文件的映射对象——java.lang.Class对象，作为外部访问该类元数据的入口

其中第一步的动作是基于类加载器完成的（更灵活），这里就不展开了，比如现在由一个外部实现好的类加载器，它的功能：输入——待加载类的全限定类名，输出——该class文件的二进制字节流/字节数组
而最终这个class文件对应的信息将保存在JVM内存的方法区，用户无法直接访问方法区，而java.lang.Class对象就是对class文件信息的抽象/建模，用户可以通过访问class对象，间接访问方法区保存的信息。

对应每一个载入jvm内存的class文件，方法区保存两个对象的引用，一个是对class文件信息进行映射的class对象，另一个是加载该class文件的classLoader对象（对应自定义类，一般都指向applicationClassLoader）。
>加载的结果：class文件载入内存，堆内存创建了一个class对象，方法区为该class文件保存了一个class对象引用和一个classLoader引用。通过这两个引用可以判断两个类是否是一个类型

JVM加载类的信息到内存之后，使用字节码执行引擎去执行我们写的代码编译出来的代码指令，在执行代码的时候需要程序计数器来记录当前执行的字节码指令的位置的，也就是记录目前执行到了哪一条字节码指令。


```java
public class Load {

    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        MyClassLoader myClassLoader = new MyClassLoader();
        Class<?> myMap1 = myClassLoader.loadClass("MyMap");
        Class<?> myMap2 = myClassLoader.loadClass("MyMap");

        MyClassLoader myClassLoader1 = new MyClassLoader();
        Class<?> myMap3 = myClassLoader1.loadClass("MyMap");

        //myMap1 == myMap2  != myMap3
//        Object instance = myMap.newInstance();
    }
}

class MyClassLoader extends ClassLoader{

    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String path = "e:\\myclassPath\\" + name + ".class";

        try{

            ByteArrayOutputStream os = new ByteArrayOutputStream();
            Files.copy(Paths.get(path),os);

            //得到字节数组
            byte[] bytes = os.toByteArray();

            //byte[] -> *.class
            return defineClass(name,bytes,0,bytes.length);

        }catch (IOException e){
            e.printStackTrace();
            throw new ClassNotFoundException("类文件未加载到");
        }
    }
}


```


##### 双亲委派模型

1. 以保证绝对不会重复加载某个类
2. 基础类的统一

###### 为什么不选择从上往下加载
因为这样的话就写死了，每一个父加载器都要知道它的子加载器是谁，写死，不方便扩展
而双亲委派父类不必知道子类，找不到就抛异常，由子类catch后自己尝试加载


感觉这个无关 //还有就是一定程度上避免类的重复加载，父加载器可以加载，子加载器也可以加载，如果子类发现父类加载了，就不加载。

###### 理解JDBC

jdbc本质上是java官方定义的一组接口（Drive/Connect/Statement/ResultSet等），然后让各个数据库厂商去向用户提供各自的接口实现类，这些接口规定了一种行为——java语言如何操作数据库实例。用户可以基于这套接口去面向接口编程，作为用户的程序员只需要注册相应的驱动即可。  
而一个JDBC打开的连接，最终也会映射为一条数据库连接（mysql客户端与mysql服务器之间建立的TCP连接）

###### statement

Statement接口规范了执行sql语句，返回结果的行为。  
statement直接对参数的处理，是直接将sql语句与参数进行字符串拼接的，容易被sql注入攻击（例如 and 1 = 1恒成立，进行全表扫描）。preparedStatement是statement的子接口，可以防止SQL注入攻击，会对SQL进行预编译，效率很高，而且参数使用?进行占位，通过set方法给占位符赋值（这里谈论的都是具体的实现类行为）  
callableStatement继承自preparedStatement，用于调用存储过程，不过一般不使用JDBC创建存储过程。

###### JDBC流程

JDBC的流程可以概括为：  
【1】注册数据库驱动  
【2】拿到连接connect对象  
【3】拿到执行sql语句的statement对象  
【4】执行sql语句得到结果集resultSet对象

```java
        Class.forName("com.mysql.cj.jdbc.Driver");
        Connection root = DriverManager.getConnection("jdbc:mysql://localhost:3306/mysql?useSSL=false", "root", "123456");
        String sql ="select * from user";
        Statement statement = root.createStatement();
        ResultSet resultSet = statement.executeQuery(sql);
        statement.close();
        root.close();

    
```

获取connect对象的方式有两种，一种是直接new对应的Driver对象，然后使用driver对象的connect方法去获得，而另一种更加常用的方式是使用DriverManager的静态方法getConnection去获取

###### 注册驱动原理

注册注册，听着很玄乎，其实说白了就是driverManager这个类维护了一个集合，这个集合装载的是Driver对象（DriverInfo是对Driver的封装，内部组合了DrIver对象，内部还维护了一个DriverAction类型，可以指定取消注册的逻辑）。而注册说白了就是往这个容器中添加Driver的过程

```java
    private final static CopyOnWriteArrayList<DriverInfo> registeredDrivers = new CopyOnWriteArrayList<>();
```

当我们forName主动将一个类加载如内存，就会触发类初始化，执行该类的static块。这个块内执行的逻辑其实就是new一个对象，然后注册进driverManager的Driver集合中。

```java
    static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException("Can't register driver!");
        }
    }
```

Driver类还会有一个无参构造器，我们也可以直接使用这个无参构造器new一个driver对象，但是这样就属于硬编码了，而第一种方式完全可以写在配置文件中，然后读入properties对象。

```java
    public Driver() throws SQLException {
    }
```

driverManager设计的目的就是代替用户管理驱动（Driver），也算是一种控制反转吧…  
一旦将Driver委托给driverManager后，获得连接时，需要遍历集合找到合适的驱动对象（依次尝试connect，如果返回的连接对象不为null就返回），并且调用其对应的connect方法。

###### 打破双亲
DriverManager它是rt,jar包中定义的类，因此它的类加载器是bootstrap，而Driver是各个厂商提供的类，属于application加载的范畴，因此不能使用driverManager的类加载器直接去加载Driver。

> 双亲委派模型并不是一个强制性的约束模型，而是java设计者推荐给开发者使用的一种类加载器实现模型，它虽然解决了**类的唯一性问题（防止内存中存在多个同名类型）**：使用不同类加载器加载的类最终都会被同一个类加载器加载——也就是说，用户要使用DriverManager，那么使用时DriverManager会被bootstrap加载，但是现在DriverManager相应根据用户传入的String去加载这个Driver，就加载不了了，因为DriverManager只能使用bootstrap加载，它没有更高一级的领导，更不可能往下委托，这就是双亲模型的缺陷——**上层类无法回调下层类的代码**（下层类需要使用上层类代码时，可以直接new或者反射调用，反正肯定能将上层类加载入内存，但是上层类没法这么做，因为它没法加载一个下层类）

什么是打破双亲？本来按照双亲委派的规则，上层类（启动）无法加载下层类（应用），但是我通过某种方式达到这个目的——主动违背委派模型。

```java
        synchronized(DriverManager.class) {
            if (callerCL == null) {
                callerCL = Thread.currentThread().getContextClassLoader();
            }
        }
```

解决方案：使用调用类的类加载器去加载Driver类，如果调用类的类加载器为null，就设置为线程的上下文类加载器。

```java
		aClass =  Class.forName(driver.getClass().getName(), true, classLoader);
```

driverManager使用的是调用类的类加载器或者线程上下文类加载器去加载的Driver。



###### 线程上下文类加载器与SPI
SPI：服务提供接口——为某个接口寻找服务的实现，类似于依赖注入思想

> Java SPI的具体约定为：当服务的提供者提供了**服务接口的一种实现**之后，在jar包的META-INF/services/目录里同时创建一个**以服务接口命名的文件**，该文件里就是实现该服务接口的**具体实现类全限定名列表**。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入

java提供了很多SPI接口，如java.sql.Driver，而运行第三方为这些接口提供实现类，但是这就出现了一个问题：SPI接口是java类库的一部分，由bootstrap启动类加载器进行加载，而SPI的实现类是由application系统类加载器来加载的，因此**在双亲委派模型下，启动类加载器无法委派系统类加载器去加载类**。  
（使用SPI前，需要在类路径中加入JDBC的第三方jar包，相当于指明了JDBC接口的实现类，最终实现类会被application类加载器加载）

线程上下文类加载器是java对双亲委派模式与实现SPI之间的妥协，Java 应用运行的**初始线程**的上下文类加载器是**系统类加载器**，在线程中运行的代码可以通过此类加载器来加载类和资源。  
SPI接口中直接使用线程上下文加载器，而不使用自身的类加载器，就可以成功实现“向下委托”的效果。

> jdk6之后，oracle改写了加载JDBC驱动的方式，不必显示使用Class.forName()方法加载JDBC驱动，driverManager会在类加载阶段从（jar包的META-INF/services/）配置文件中加载Driver的所有实现类（驱动jar需要包含在类路径中）

总结：  
JDK提供SPI接口，第三方提供实现类，而且第三方按照约定将以服务接口名命名的文件放入jar包的META-INF/services/目录下，内容就是实现类全限定类名列表。按照约定jdk会去扫描jar包中符合约定的类名，然后依次调用forName加载，由于SPI接口自身的类加载器无法加载第三方类型，因此就将这个任务委托给当前执行线程的线程上下文加载器，加载完毕用户就可以正常使用了——_用着java官方提供的SPI接口，功能却是第三方实现的_。  
SPI的出现，让程序员可以真正实现面向接口编程，运行时自动注入实现类（不需要再forName指定实现类）

> 严格上说，正在起作用的是实现类，而实现类确实需要被application加载，只不过是看起来“application类加载器加载了Connect接口”，一般更严格意义上的“打破”是实现自定义类加载器并且重写loadClass方法




#### 连接
连接和加载阶段是可以一起进行的，连接就是“link：链在一起”，可以细分为：
【1】验证：文件格式、元数据、字节码、符号引用验证
【2】准备：为静态变量分配内存（堆）并设置零值。如果存在constantValue属性，通常就是在准备阶段进行赋值。（否则在初始化阶段，在\<clinit\>()中赋值）
【3】解析：符号引用解析为直接引用。


#### 初始化
为静态字段赋初值。将为静态变量赋值的语句、static块收敛到\<clinit\>方法中执行。JVM保证子类的\<clinit\>执行前，父类的\<clinit\>已经完成调用。
>不管是\<clinit\>还\<init\>，多线程环境下都是可以保证互斥调用的，jvm提供初始化锁。如果多个线程同时初始化一个类或实例，那么只有一个线程可以成功执行该方法，其他线程必须阻塞



### 主动使用问题
一个类被加载，但是不一定会触发初始化行为，以下情况则一定会触发类的初始化（有且仅有）
【1】new关键字（触发了构造器）
【2】读取/修改静态变量（除了静态常量）
【3】执行静态方法
【4】Class.forName()
【5】loadClass(），且第二个参数为true（初始化=true）
【6】初始化一个类的子类
【7】包含main方法的类（主类）


### static
静态创建，被static修饰的字段或者方法都是属于类的，不依赖于任何一个实例。
一旦类加载完毕，堆中便存在一个class实例，类的实例成员与方法可以看作与class实例绑定。
class文件中，static修饰的方法和字段与实例字段、方法一样存放在class文件的字段表和方法表。不同的是，访问标志ACC_static为true。

对于static修饰的方法，在类解析阶段便可以确定唯一调用版本。对于static修饰的字段，在类准备阶段就已经分配好内存空间并赋零值了。初始化阶段使用\<clinit\>()初始化。

### this与static无法共存的本质
static方法和实例方法的执行都是基于栈的，区别不多，一个是invokeVirtual/invokestatic，另一个是static方法栈帧的局部变量表中没有参数this，而实例方法中的局部变量表中，第一个参数总是预留给this的。这也是为什么static方法中为什么不能出现this的原因。
语义上：static属于类，this代表当前实例，二者生命周期不一致
实现上：static方法栈帧的局部变量表没有保存this的引用，因此无法使用this。（除非你把this作为一个引用类型，通过参数的形式传入方法中）


 ## 对象
  创建对象同样需要分配内存，对象创建在堆中，被引用类型执行。最常见创建对象的方式便是通过构造器的方式，也就是常说的“new”方式。

### 对象内存
 对象存放在堆内存，一个对象可以划分为三个部分：
 1】对象头：对象元信息
【2】实例数据：对象存储的有效信息
【3】对齐填充：保证对象是8的整数倍，因此最小的对象也会占用8字节
对象头主要包含两类信息：对象本身的运行时数据（mark word）和类型指针
通过类型指针，可以指定这个对象的真实类型是什么（属于哪个的实例）。如果是数组还会保存一个用于标记长度的数据。

>java的数组类型是jvm运行时基于newarray指令动态创建的，长度字段直接维护在底层的对象结构中

mark word包含了各种运行时数据，包含hashCode值、锁标记、对象分代年龄、GC标记等

>[Java对象在内存中的布局_ju_362204801的博客-CSDN博客_对象在内存中的存储布局](https://blog.csdn.net/ju_362204801/article/details/98802697)

### 对象的创建过程

1. 查找类在常量池中的引入，如果不是直接引用则说明类还未必加载，则会对类进行加载、连接和初始化。
2. 为对象分配内存空间，并且置零值，此时一个空对象创建完毕。
	>如果内存规整，则使用指针碰撞的方式分配内存：把空闲与非空闲内存使用一个指针隔开，分配内存移动指针实现  
	 如果内存不规整，则使用空闲列表管理内存  
	 更新基于CAS保证原子性，如内存分配
	 
3. 设置对象头，完成对象的构造
4. 执行\<init\>()进行初始化（实例属性和构造块按照顺序收敛，最后是构造函数）
5. 将堆中对象的首地址赋值给引用变量，入栈

#### 对象存放位置
除了在堆存放，还可以在栈和TLAB（TLAB本质也是在堆，只不过避免了CAS）

### 对象的创建方式

1. new：通过构造函数创建
2. 反射，动态创建：借助java.lang.Class类的newInstance（）方法（调用无参构造器）
3. 使用java.lang.reflectConstructor类的newInstance（）方法（反射调用某个构造器）
4. 使用对象克隆方法clone（）
5. 先进行序列化，然后在调用反序列化（objectInputStream）的readObject方法。（深拷贝）
>静态创建：创建哪个对象编译后JVM就知道了，类已经被载入常量池了。  
>动态创建：JVM仅知道需要加载反射相关的类，但是要创建什么对象只有运行到反射方法才知道，类可能也是运行时载入内存的。（编译后类的符号引用可能没有被放入常量池）




### new关键字做了什么

通过反编译，可以指定new对应四个指令  
【1】new  
在堆中开辟内存空间，并将一个引用类型(this)入栈。
>OS管理内存，jvm向OS申请内存，并且为堆划分出一部分内存，类加载更多的是向jvm方法区申请内存，而创建任意对象则是向jvm的堆区申请内存

【2】dup
把栈顶的this拷贝一份，因为之后需要调用（构造器）方法也需要这个引用
【3】invokeSpecial
执行构造器方法，参数是一个类的常量池引用，这会触发类的加载。而子类的加载又会触发父类的加载，而且编译器为\<init\>方法首行自动调用父类的\<init\>方法，最终的效果：
执行父\<clinit\>()——> 子\<clinit\>()——>父 \<init\>()——>子\<init\>()
> 我的理解，代码块和变量赋值的动作优先级高于\<init\>()，编译器会默认在构造函数第一句执行空的父构造器，也可以指定。如果没有写构造器则编译器生成默认的空构造器，否则不生成默认空构造器，因此父 \<init\>()中执行的是子\<init\>()指定调用的构造器或者默认构造器。

【4】引用出栈，存入局部变量表（astore）


### this的本质
因此，this本质上就是一个引用，它指向的就是当前实例对象，我们使用this和使用其他的引用无本质区别。
另一方面，new指令的本质就是触发构造器的调用。构造器的写法上是不加返回值的，但是它其实是有返回值的，返回的就是this这个引用。而this引用指向的就是创建完成的对象。

而**实例方法中可以直接使用this，是因为实例方法的局部变量表中总是在第一个位置存放this引用（slot_0）,static则没有this这个隐式参数。**

### super的本质
super代表当前实例从父类继承而来**信息域**的引用（地址）  
也就是说super并不是一个完整的对象，他只是一个内存范围，因此使用super可以访问有限的信息，但是却不能把super当做一个引用
`        Program cur = this;`
`        Object o = super;  报错`
子类字节码中有父类索引，因此可以直接找到父类的各种信息（元信息、方法指令），父类定义的内存全部在子类的内存范围，new开辟的内存空间中，不仅含有子类的数据，也包含父类拿到的数据，子类是父类的延伸，因此子类对象往往比父类对象更占用内存空间。

### 能否访问？
子类能否访问父类的字段和方法由标准ACC_FLAG决定，而且这在编译阶段和类检验阶段已经可以保证这条语义的正确性了。用户看似“没有继承”或者“看不见”，其实是“继承”下来的，同样占用内存空间，这也就解释为什么通过反射暴力破解能够访问到相应的值了——不是拿不到，而是私有字段或方法对应的内存地址禁止访问，这在编译期是可以检查出来的。

总结：
this和super本质上都是指向一段内存（new出来的内存空间）的指针，但是super只能访问该空间的部分数据（专门存储父类信息的内存数据），调用父类构造函数是为这段空间的成员初始化/填充数据。通过super调用方法对应invokeSpecial指令，调用版本编译期确认，就是父类的方法，解析阶段将常量池中的引用解析为直接引用。而this调用的方法对应invokeVirtual，运行时分派，无法确认方法是否被子类重写。

```markdown

http://jseafly.blog.sohu.com/145651869.html

http://blog.sina.com.cn/s/blog_5ddb672b0100jedt.html
[Java父类与子类的内存引用讲解 - hello,MR.Guo - 博客园 (cnblogs.com)](https://www.cnblogs.com/MR-Guo/p/3306539.html)
 从对象的内存角度来理解试试.  
假设现在有一个父类Father,它里面的变量需要占用1M内存.有一个它的子类Son,它里面的变量需要占用0.5M内存.  
现在通过代码来看看内存的分配情况:  
Father f = new Father();//系统将分配1M内存.  
Son s = new Son();//系统将分配1.5M内存!因为子类中有一个隐藏的引用super会指向父类实例,所以在实例化子类之前会先实例化一个父类,也就是说会先执行父类的构造函数.由于s中包含了父类的实例,所以s可以调用父类的方法.  
Son s1 = s;//s1指向那1.5M的内存.  
Father f1 = (Father)s;//这时f1会指向那1.5M内存中的1M内存,即是说,f1只是指向了s中实例的父类实例对象,所以f1只能调用父类的方法(存储在1M内存中),而不能调用子类的方法(存储在0.5M内存中).  
Son s2 = (Son)f;//这句代码运行时会报ClassCastException.因为f中只有1M内存,而子类的引用都必须要有1.5M的内存,所以无法转换.  
Son s3 = (Son)f1;//这句可以通过运行,这时s3指向那1.5M的内存.由于f1是由s转换过来的,所以它是有1.5M的内存的,只是它指向的只有1M内存.

[(51条消息) 通过反射访问父类的私有成员_weixin_30555753的博客-CSDN博客](https://blog.csdn.net/weixin_30555753/article/details/95107779?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1.pc_relevant_aa&utm_relevant_index=2)
```






# 理解面向对象
什么是面向对象？面向对象就是对现实世界进行建模，将抽象复杂的现实问题，通过类型拆分，分解成一个个小问题。对于面向过程，解决问题的思路是先干什么，后干什么。而面向对象解决问题的思路是先把问题拆分成几个对象，然后考虑每个对象可以提供哪些方法。
面向对象的核心是对代码的管理。对于小问题（如打印helloWorld），我们在main方法中就可以搞定了，还费什么劲专门为他定义一个helloWorld类呢？但是如果现在让你为打印机编写一个程序，那这就不是三两行代码可以搞定的了，我们不但需要思考如何写代码，还需要考虑如何管理代码，这时我们应该采用面向对象编程。
>面向对象就是一种思想、一种工具、它不是实现一个功能必须的框架结构，但是它通过对现实世界建模，可以更好的展现实现某种功能或解决方案的思想。
就好像，给一家人做饭只需要考虑做菜的流程。而给一所学校的所有学生做饭，就要考虑哪些学生有忌口、给高年级做什么、低年级做什么，问题复杂化后就涉及对问题的拆分和管理了。其实面向对象和面向过程是相互包含的关系，面向对象的编程总是先考虑需要哪些对象，对象直接通过接口相互合作，委托方调用接口，被委托方实现接口（这里的接口也可以当做对象暴露出方法），而使用对象又可以看作面向过程的。

## 三大特性
面向对象的思想：使用一组数据结构和处理它们的方法组成对象，把具有相同行为的对象归纳为类，通过类的封装隐藏内部细节，通过类的继承实现类的重用与扩展，通过多态实现基于对象的动态分派。

封装是面向对象最重要的特征，封装就是屏蔽细节，只保留出实现的接口。（属性也通过方法暴露），就好像手机通过屏幕（展示）输出，通过按键进行输入，其中计算的细节被手机外壳屏蔽。用户只需要关注三点即可：输入、接口提供的功能、输出
而屏蔽细节的最好方式，就是寻找共同点，提取出一个抽象的上层模板，模板与具体实现的功能可以通过继承来体现。而通过同一个模板实现出的不同的类又可以表现出不同的行为，这便是多态。


## 接口与抽象类
### 设计思想对比
抽象类被设计为**对一类事物的抽象**，通过提取共同特征，屏蔽差异，用于被继承，核心设计目的——收集可重用的代码，通过被继承达到代码复用的目的。
>抽象类和普通类的唯一区别，就是它被abstract修饰，以至于它不能被实例化，因此它只能被看作为一个抽象的模板。普通类也可以被继承达到同样效果——抽象类是一种规范，
>不是必须的，是其中一种选择而已。因为继承的目的有很多：做代理类增强原类型、做适配器等等

接口被设计用于**对一组行为的规范**，要求某些类必须具有某些行为，但不要求如何实现。
>继承抽象类用于说明“是什么”，而实现接口用于说明“会什么”。二者设计的目的，本质上都是为了更好描述一个类型的功能和特征。
ArrayList和linkedList都直接或间接的继承了abstractList抽象类和实现了list接口。通过继承前者，说明二者属于“线性列表”类型，同时获得了一些和线性列表相关的可复用代码，而实现后者，规范了二者具有一些线性表的行为（如sort、set、get），但是并没有规定二者的具体实现，因此ArrayList可以基于数组实现以上行为，而linkedList可以基于链表实现以上行为。使用者可以通过List接口规范出来的方法，而方法的实现根据具体的实现类动态分派


### 接口细节
接口默认的使用public abstract修饰，而字段使用public static final修饰（注意，接口字段是静态常量，因此外部调用时不会引起接口初始化，因为编译后字段的值已经保存在接口字节码文件属性表的constantValue属性中了），方法使用public static修饰。
jdk8开始支持接口的默认方法和静态方法。其中默认方法是属于实例的，而静态方法是属于类的。

jdk中很多地方使用了标记接口（没有任何方法），它的作用主要有两个：提供一种新的数据类型、建立一个公共的父接口

#### 接口重名问题
【1】如果两个接口中定义了相同的方法（方法值相同），那么实现类只需要实现一次即可。  
【2】如果返回值不同，编译不通过。  
【3】如果两个接口定义了相同的默认方法，则实现类必须重写这个方法（也可以通过接口名.super.去引用接口对应的默认实现）

```java
    @Override
    public void A() {
        a.super.A();
        b.super.A();
    }

```

【4】如果存在重名的静态方法，只能通过接口名去调用  
【5】如果仅仅同名，但是参数列表不同，则可以看作两个方法。（相当于重载）

#### 多继承问题
Java不允许类进行多重继承（extends），因为存在“菱形继承问题”：B和C都继承A，而D同时继承B和C，那么D相当于间接继承了两份A，而且方法解析是也十分复杂，例如当D菱形继承A后，到底表现B还是C的多态？java允许多实现（implements），因为接口中都是抽象方法，最终都需要交给实现类实现，“菱形继承”的接口在实现类中也只需实现一次即可，不会增加JVM解析的复杂度。（接口的继承也使用extends关键字）

#### 接口初始化
当一个实现类初始化时，不会初始化它的接口。一个接口在初始化时，也不要求它的父类完成初始化。只有程序在首次访问接口的静态变量时，才会初始化——非string+8大基本类型的引用变量。（string+基本类型的值全部在编译期固化到使用方的字节码中了）

## 重写与重载

定义:
重写：存在继承关系的基础上，子类对父类方法进行重新实现。【纵向选择】
重载：同一实例可以拥有多个同名方法，根据方法签名（参数列表：类型、顺序、长度，不包含返回值和修饰符）的不同，**编译期可以确定唯一载入的版本**。【横向选择】

扩展:
重载是静态的，而重写是动态。 编译期多态，运行期多态

编译器在编译期就可以确认某一个方法的重载版本，但是并不一定能确认它的调用入口。父类重载的方法子类给重写了

哪些方法可以在运行前就可以确认方法的唯一调用版本——**当方法的符号引用，在类加载的解析阶段就可以转换为直接引用**：
>编译期指的是，源码被编译为字节码后，运行期指的是VM启动，加载类、创建实例等工作开始进行，主要指的是执行引擎开始工作、执行字节码指令…


【1】static方法(invokeStatic)
【2】super.XX() 即调用父类方法（invokeSpecial）
【3】final修饰的方法（invokeVirtual）
【4】private修饰的方法（invokeSpecial）
【5】构造器（invokeSpecial）

以上五个方法也被称为**非虚方法**，他们最大的特点就是**不能被重写**，因此可以在编译期确认唯一调用版本。与之相反的**虚方法**就是实例方法（invokeVirtual），虽然被final修饰的实例方法使用invokeVirtual调用，但是仍然属于非虚方法

### 使用上区别
重写一个方法时，**参数列表不能改变**，返回值要么不变，要么是可以兼容的类型（被重写方法返回值的子类、实现类、子接口等“小类型”），异常也同理，不能抛出更宽泛的异常类型，同时也不能做更严格的访问权限。  
重载一个方法时，**参数列表一定要变**，异常、修饰符、返回值不做要求

### 底层上区别
当一个类被编译后，它的某一个方法的信息将被保存在方法表和常量池中，其中方法的各个参数的符号引用集合将作为特征签名将被保存在常量池中，而返回值不会作为特征签名的成员。因此无法仅仅依靠返回值确认重载版本。


重写是运行时多态的体现，方法调用的本质就是将符号引用转换（解析）为直接引用，直接引用指向方法对应的字节码指令（的地址）。对于非虚方法，这个过程在类加载的解析阶段完成，而对于虚方法，这个过程在运行时完成（即执行引擎真正开始执行该方法调用代码时才进行解析）。
而对重写方法调用的解析，就是将符号引用指向重写方法执行入口的过程，运行时执行动态分派的动作，取决于变量对应的真实类型（变量指向的对象类型，而不是变量类型），只有虚方法才会执行动态分派

### 方法调用原理
每个方法的调用都有一个栈帧结构，而方法的引用（符号或者直接引用）被**动态链接结构**指向。局部变量表存储初始值、中间计算值（输入初始值和存储中间值），操作数栈进行运算（指向命令）、动态链接指向要执行的命令（指挥计算）、方法出口输出最终结果
>没有静态链接，栈帧中的静态链接是一个指针，指向常量池中方法对应的“符号或直接引用”

动态分派、重写都是基于基于虚方法而言的。而非虚方法总是在基于静态分派（解析）的，也就是说非虚方法（如静态方法）不存在所谓“重写”一说，但是存在因为“调用优先级”导致的“重名覆盖”现象

如果调用一个静态方法，对应的是invokeStatic指令，其中静态方法的符号引用在解析阶段就已经指向Father实现的方法了，因此调用的Father提供的方法。（类加载之后就已经确认唯一调用版本了，和创建什么实例已经没有关系了，由静态类型决定）

如果调用一个实例方法（非final），对应的是invokeVirtual指令。
【1】引用入操作数栈，这个引用指向的对象的对象头中具有一个执行真实类型的指针（类型指针）
【2】栈帧中有一个动态连接结构，保存了一个指（向运行时常量池中）当前栈帧所属方法的引用。（虚方法中，此时动态连接指针指向的还是方法的符号引用）
【3】在真实类型（方法表）中寻找是否存在相应的重写方法，如果存在则进行权限认证，通过后则将动态连接的符号引用，指向当前方法的入口（直接引用）
【4】否则按照继承关系向上搜索，如果始终未成功解析，则抛出异常：abstractMethodError

多态在于invokeVirtual的调用，因此非虚方法和字段不会展现“多态”


如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为**虚方法表**的方法来优化调用的效率。


所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。

虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量的初始值准备完成之后，JVM会把该类的方法表也初始化完毕


# GC
Java的一大特性就是支持垃圾的自动回收，这里的垃圾就是不再使用的对象，而完成自动回收的垃圾回收器（简称GC）。Java领域中，主流的Java虚拟机采用**可达性分析算法**来管理内存。更加简单的引用计数法更多使用在一些脚本语言如python，因为**引用计数法最大特点就是回收及时**，一旦引用为0就可以清除，而可达性分析通常**至少需要标记和清除(这一步也可能是其他的处理)两个阶段，一个垃圾对象至少经过两轮标记才会被清除**
>python的GC主流实现中，对于不可能产生循环引用的对象如数值、字符串采用引用计数，而对于集合、自定义对象等采用类似标记-清除的算法进行回收。

大部分对象存放在堆内存，而如果堆内存不足以用户申请的对象，则会触发GC进行垃圾回收，而如果最终仍然无法放下，将终止运行，并抛出OutOfMemoryError的异常。（在这里是堆内存溢出，而该异常也会出现在方法区溢出、直接内存溢出的场景）

>JVM中可以通过 -Xms和-Xmx来调整堆内存的范围。其中-X代表标准，所有JVM标准下的JVM实现都遵循-X，ms就是memory size 即JVM给堆内存的最小值，随着对象的创建堆的大小肯定是不断变大（动态扩展），而mx 就是memory max 即堆的最大值。
如果想要禁止堆的动态扩展，而限制堆内存为一个固定大小，则可以将-Xms和-Xmx指定一个同样的大小

## 可达性分析
可达性分析是主流JVM实现用于判断对象是否存活的方法。首先需要通过根结点枚举确定根结点集合GC roots，然后从这些节点开始，根据引用关系向下搜索对象图。这个对象图就是与GC roots可达的对象。（具体标记哪个对象与具体GC实现有关）

根对象集合包括（这里可以理解为引用，或者引用直接指向的堆中对象）：
【1】栈内存中，包括操作数栈、局部变量表引用的对象（具体表现为使用到的局部变量、返回值、参数）
【2】方法区引用的对象：classLoader和class对象
【3】常量池引用的对象，如常量池中的（引用的）字符串对象
【4】被同步锁synchronized持有的对象
【5】JVM内部的引用如系统类加载器、一些常驻的异常对象
【6】类所属的静态变量

**如果一个指针保存了堆中对象的地址，但是自己又不存放在堆中（存于栈中），那么它就是一个root**

>常驻JVM内存的对象基本都是不能轻易回收的，因为它们总是被生命周期更长的对象引用（例如JVM实例本身可以看作一个进程对象），他们就可以作为可达性分析的根对象，方法区总是保留引用的两个对象classLoader和class对象、常量池中保存的字符串字面量是什么——堆中字符串对象的引用、monitor关联的对象、总是需要用到的异常对象、与类同生共死的静态变量指向的对象、栈帧中各种结果指向的对象等

## 根结点枚举
这里存在两个待优化或解决的问题：

【1】 如果使用可达性分析算法进行判断，则分析工作必须在一个能保证**一致性的快照**中进行，否则无法保证结果的准确性。因此需要**stop the world**，停止所有的用户线程工作，使得GC线程可以在一个一致性快照中进行垃圾回收工作。

>STW原因：
【1】可行性分析工作必须在一个能确保一致性的快照中进行，分析期间整个执行系统需要是静止在某一个时间点的。
【2】如果分析过程中，对象引用关系在不断变化，会使得分析结果的准确性收到影响。
STW无法被避免，是JVM在后台自动发起和自动完成的，对用户透明。垃圾回收器的升级不断优化STW的时间

不断的GC可能造成频繁的STW，这会使得程序运行显得很慢，本质上是由于内存吃紧而不断触发GC。
>系统频繁变慢和通常和频繁STW有关，频繁STW是频繁GC的表现，一般是因为内存不够用了，再不GC就OOM了，这时候可以看一下是不是存在内存泄露了或者被外部DDOS攻击了。

【2】对象那么多，如果全部遍历一遍去进行根结点枚举，那么无疑是大海捞针，而且根结点枚举在垃圾回收器的大部分实现中，都是无法避免STW的，因此需要找到一种方法进行优化，以保证快速地完成根结点枚举。
主流的JVM使用的都是准确式垃圾收集（JVM可以知道内存中某个位置的数据具体是什么类型——字面量还是引用），JVM不需要查找所有GC root，而是可以使用一组数据结构，它指明了哪些位置存在对象引用。Hotspot中，使用一组称为OopMap的数据结构来快速完成GC root枚举。
一旦类加载完毕，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，并保存在oopMap中。

导致OOPMap内容变化的指令很多（程序运行期间很多指令都有可能修改引用关系），Hotspot没有为所有指令生成OOPMap，而是在安全点记录了OOPMap相关信息，只有在安全点才会对oopMap做一个统一的更新，因此只有安全点位置的oopMap一定是准确的，因此只能在安全点处理GC行为，进而STW一般也只发送在安全点
>一段程序被若干个安全点切出若干程序段，而CPU执行到程序安全点时才会GC，因为HotSpot只在安全点记录了oopMap的信息，而oopMap用于实现快速枚举GC root。
源码中变量都是有类型的，但是一旦经过编译后，变量就只有在局部变量表中slot的位置，oopMap用来说明栈上某个位置存放的变量原来是一个什么类型的。
换句话说，假如我们不计成本和实现复杂度，在任何位置、为每条指令的位置都记录oopMap，那么HotSpot的GC可以在任何时候进入GC，因为任何位置都是一个安全点。

**oop (ordinary object pointer) 普通对象指针，oopmap就是存放这些指针的map,OopMap 用于枚举 GC Roots，记录栈中引用数据类型的位置**

一个线程为一个栈，一个栈由多个栈桢组成，一个栈桢对应一个方法，一个方法有多个安全点。GC发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的OopMap，记录栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈桢的OopMap ，通过栈中记录的被引用的对象内存地址，即可找到这些对象（GC Roots）
>原文链接：https://blog.csdn.net/yunxing323/article/details/109249788

### 安全点
程序执行过程中并不是在任意位置都能够停下来开始GC，而是到达“安全点”。安全点通常为与方法调用处、循环跳转、异常跳转位置——**经常被复用的指令、执行时间较长的指令**
主流JVM采用**主动式中断**——垃圾收集器需要中断线程时，设置一个中断标志，各个线程在运行过程时不停地主动轮询这个标志，如果为真则**在最近的安全的主动挂起**。

这个中断标志就设置在**安全点**以及**所有创建对象**和其他**需要在堆上分配内存的地方**（为了没有足够内存分配新对象）

但是对于处于阻塞或等待状态的线程，就无法执行中断操作，因为它们此时无法进入运行状态，这时需要引入安全空间。（如果一个线程长期sleep，那么GC将暂时无法回收该线程在堆中产生的垃圾）
安全空间可以看作安全点的拉伸，线程要么冻结在安全点的位置，要么冻结在安全区域的范围。

**安全区域：指的是一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的**
>我的理解：**安全空间内，保证了oopMap的内容不会被改变**，即使此时sleep的线程没有被主动挂起进入STW状态，GC也可以对该线程进行根结点枚举，相当于该线程运行到了安全点，而涉及sleep、blocked的代码都属于安全区域代码，因为它不会改变某些对象的引用关系

【1】当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，如果这段时间发生GC，那么JVM会忽略标识为“已进入安全区域”状态的线程（因为JVM知道安全区域代码段内的oopMap内容不会变）。（进入安全空间后，即使程序因为某些原因无法响应JVM的中断请求，JVM也可以开始进行根结点枚举工作）
>一致性视图是指 **“一致的引用关系”** ，如果一段代码不会改变这个一致性视图，那么STW并GC和边GC边使得线程继续执行这段“不影响”的代码之间的效果差不多，但是如果线程想要退出这段安全区域代码，则需要“经过JVM的允许”

【2】当线程即将离开安全区域的时候，会检查JVM是否已经完成了根结点枚举，完成了则继续执行。否则需要等待接收JVM“允许离开安全空间”的通知。
>因为根结点枚举是STW的，如果没有进行完毕，那么用户线程需要停在安全区间，虽然它没有被STW，但是需要逻辑上达成STW的效果。因为离开安全空间时，可以看作达到安全点（离开安全点之后无法保证oopMap的准确性），而此时的JVM可能只在对程序进行根结点枚举，如果不经过JVM通知就离开安全空间相当于为枚举工作“添乱”，使得GC使用的oopMap不准确。


总结
GC roots枚举需要保证：
【1】确保一致性快照
一致性视图：分析期间，整个系统需要是静止在某个时间点的，并且能保证所有线程都能够响应JVM的STW信号。

【2】效率，快速定位的数据结构oopMap
基于准确式垃圾收集算法，通过数据结构oopMap记录内存中哪些位置存放了哪些对象。
但是oopMap总是被频繁的改变，但是不能在每条指令后面都更新一次oopMap，于是引入安全点，对oopMap进行统一的更新。而引入安全空间则是一种双重保险，防止某些用户线程迟迟不执行到安全点的位置，而导致GC无法开展工作。

因此，在oopMap的辅助下，GC能够快速完成根结点枚举，因为进入GC开始，程序不是运行在安全点下，就是运行在安全空间中，因此，此时的oopMap是被同步更新后的内容，GC能够拿到oopMap描述的对象内存分布的信息，就相当于拿到“一致性视图”


## 并发的可达性分析



对于非（GC线程与用户线程）并行的垃圾收集器，往往整个GC的过程都是STW的，因为需要整个过程基于一致性视图。其中根结点枚举中，枚举的都是GC根对象，而且能够通过oopMap优化，停顿时间相对短暂且固定。而从根节点开始，向下遍历对象图则占有很长的停顿时间，堆越大，存放的对象越多，标记占有的时间越长。
**并发的可行性分析主要分为四个阶段：根结点枚举、并发标记、修正标记、最终回收**

### 三色标记法
在遍历对象图的过程中，把所有对象按照“**（引用）是否被访问过**”标记为三种颜色  
【1】白色：对象尚未被垃圾回收器访问过  
【2】黑色：对象已经被访问过，且**对象内的所有引用也都被扫描过**。（表示未完成的工作状态，解决并发问题）  
【3】灰色：对象已经被垃圾回收器访问过，对象内至少存在一个引用还没有被扫描过。
>类比进程的引入，因为多线程环境下存在线程切换，因此存在“工作到一半/工作未完成”的任务

灰色是黑白对象直接的中间态，**标记过程结束后，只会有白色和黑色的对象**，其中白色对象就是需要被回收的对象——因为它不可达，GC没有办法“接触它

### 标记修正
因为并发标记阶段GC和用户线程一起工作。因此标记完成后必须**修正标记**。  
【1】GC标记死亡的对象可能被用户再次使用（**对象消失**、空指针）（大问题，在用户看来，对象离奇消失）  
【2】GC标记存活的对象可能被用户不再使用（**浮动垃圾**、多余垃圾未被清理，需要等待下一次）（这个是小问题，等待下一次GC捎带清理就可以了）

扫描过程中插入一条或者多条从黑色对象指向白色对象的新引用，而且**灰色对象对这个新插入的白色对象不存在（或者存在但是被删除了）直接或者间接的引用**，那么这个**新插入的对象将被GC当做不可达对象**清理掉。
>通俗的描述一下，某一时刻，有几个节点已经被扫描完毕，那么这几个节点都是黑色，现在用户线程创建一个对象，而且黑色节点对象存在一条指向白色节点的引用，可是黑色节点已经不会被再次扫描了，而且如果**不存在某一个灰色节点对这个新插入对象的引用，那么这个对象将被视为“不可达节点”而被清除。**  
另一种情况就是，对象插入后本来是由灰色节点可达的，但是经过一些操作后，白色节点与任何一个灰色节点的引用都被删除了，白色对象变为不可达状态


_当且仅当满足以上两种情况时（增黑白/删白灰），才会出现对象消失问题，因此破坏其中一个条件即可_ （通过理论证明得到的）  
解决思路：  
【1】记录被新增的黑白对象之间的引用  
【2】记录被删除的灰白对象之间的引用

解决方案  
【1】**增量更新——记录新增加引用**，这也是CMS的解决方案  
黑色对象一旦插入新的指向白色对象的引用时，就记录这个引用，之后再以这些引用中的黑色对象为根再次扫描一次——**黑色对象一旦插入了指向白色对象的引用之后，就变成了灰色对象**  
【2】**原始快照——记录被删除的引用**，这是G1的解决方案  
灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些**记录过的引用关系中的灰色对象为根，重新扫描一次**——无论引用关系删除与否，都会**按照刚刚开始扫描那一刻的对象图快照进行扫描**

> 我再直白点解释：扫描完的是黑节点。而扫描不到，准备回收的是白节点。如果你在可达性分析时，悄咪咪的新建个对象，那么它就是一个白节点。如果是和灰色节点相连还不算糟糕，但是如果和黑色节点相连那基本就是等死了，因为黑色节点不会被再次扫描，因此这个新建的白节点会被错误回收。而如果灰色节点和白色节点之间的线（引用）断了，那么这时的白节点也是死路一条。

> 增量更新是啥？如果这个新插入的白节点和黑节点相邻，我就记录下来，然后以这个黑节点再扫描一次，达到一个黑节点变灰的效果。  
> 原始快照是啥？记录被删除的引用，在并发扫描后，把这个被删除的引用加上再以灰色节点为根，再扫描一遍。


## GC算法
### 分代收集
主流的JVM都是基于分代收集理论而设计的。而该理论建立在两个分代假说：**绝大多数对象都是朝生息灭的，而熬过多次垃圾收集过程的对象都是难以消亡的**。  
设计者一般至少可以将对堆内存划分为年轻代和老年代，而根据分代理论，不同程度的GC有可以划分为minorGC、majorGC、FullGC。  
使用**JVM数据监测工具Jstat**可以拿到堆内存和垃圾回收的情况，还可以看到YGC和FGC的字段（表示从应用程序启动到采样时，不同generation的gc次数）。

一般针对不同的分代具有不同的垃圾回收器实现进行负责，而垃圾回收器针对不同的generation也会基于不同的算法进行实现。例如基于年轻代垃圾回收，使用标记复制算法实现的serial、parNew、parallel scavenger等，以及基于老年代垃圾回收，使用标记整理的parallel Old、serial Old，使用标记清除等待CMS等
>理清楚这个关系：堆内存是虚拟机向操作系统申请的一块内存（操作系统就是管理底层硬件的），这块内存从操作系统看就是一块连续的虚拟内存，而JVM将它划分若干个运行时数据区段，这是Jave虚拟机之于操作系统（物理机），而应用程序运行时，GC线程也可以看作程序的一部分（作为插件插入我们的程序，帮我们管理堆内存），GC设计者至少将堆内存划分为年轻代和老年代，但是这样粒度仍然很大，因此一般将堆内存的generation划分的更细，常见的Appel模型将年轻代划分为一个Eden空间和两个survivor空间（HotSpot默认Eden与survivor为8比1 ）、G1延续了分代的理念，但是仅是逻辑上的，而对堆内存进行分块，每次GC时生成回收集。  
>总结：分代是一种理念，如何分代或划分内存没有统一标准而只有参考模型，具体如何分代取决于GC的具体实现和某个版本的JVM选用了哪个垃圾回收器作为默认（也可以通过参数修改）

一般minor GC发生的十分频繁，只针对新生代区域的对象，回收的速度也很快。而majorGC、FullGC主要发生在老年代（不过一般也会伴随至少一次minorGC），速度一般比minorGC慢一个数量级。（newRatio默认是1:2，老年代很大，占用整个堆的2/3）

### 永久代
方法区和堆一样，都是被线程共享的一个区域，方法区存放的主要是一些元信息

方法区是JVM中的一个规范，JVM规范把方法区描述为堆的一个逻辑部分。具体实现取决于具体的JVM产品，这里以HotSpot为例。  
java7及以前，方法区（HotSpot）的实现中，物理上仍然与堆相连，仅在逻辑上与堆独立（如通过一个指针限制访问范围）。由于方法区的垃圾回收条件是十分严格的，因此方法区存放的元信息和常量几乎不会被回收，因此称为永久代  
方法区的垃圾回收主要为两部分：不被引用的常量和不再使用的类型  
回收必须满足以下三个条件：  
【1】该类的所有实例都被回收  
【2】加载该类的类加载器已经被回收（只能是自定义类加载器）  
【3】该类Class对象是不可达的，而且无法在任何地方通过反射访问该类的方法

这种实现，将方法区的内存限定在JVM从操作系统申请的内存，而且存在默认的上限（-XX:MaxPermSize），而且方法区几乎不存在垃圾回收（加载进内存的类型很难被卸载），这导致方法区的内存压力随着类不断被加载进内存而持续增大，最终导致OOM。

>在JDK1.7之前运行时常量池逻辑上包含字符串常量池，这时字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代  
在JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆（从一个class实例使用一个到一个VM实例共用一个）,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代  
在JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)


总结：方法区在JVM规范中，用于存放程序元信息，Hotspot jdk1.7属于堆内存的一部分，被看作逻辑上的非堆结构。1.8的时候使用本地内存实现，彻底变成了非堆结构。


### 元空间
Java7中已经有部分数据开始转移到堆内存或者本地内存了。  
例如：符号引用转移到了本地内存、字符串常量池转移到了java堆中，静态变量也转移了堆中  
而java8中，Hotspot移除了永久代，使用元空间去实现，而元空间属于本地内存。  
其中元空间与永久代的最大区别，也是堆内存与进程内存的区别。如果将方法区局限在JVM的堆内存，那么很容易触碰到内存上限导致OOM，而使用本地内存的情况下，只要没有触发到进程可用内存的上限就不会出现问题。（相当于类型加载不再向JVM申请内存，而是直接向OS申请内存）  
**元空间替换了永久代，它的内存不由虚拟机器管理，而是取决于物理机器，不再受限于JVM本身申请的内存**  
另一方面，HotSpot也是学习J9和JRockit等虚拟机产品的优点，使用本地内存实现方法区


### 标记复制算法
最基础的标记复制算法就是**将内存分为两块，每次只使用其中一块**，然后将没有被清理的对象存放到另一块上。这种算法一个缺点是：如果存活对象太多，复制将产生极大时间开销，同时存放存活对象也意味着目标区占用的内存空间需要很多。因此，**这种算法更加适合新生代的垃圾收集，因为新生代都是朝升息灭的**，一个young GC后仅有少部分对象存活，然后换入另一块内存。

有一种更加优化的模型，将新生代分为一个Eden区和两个survivor区。（serial、parNew等新生代GC均采用此内存布局），默认比例8:1，每次新生代可用的内存空间占整个新生代的90%（一个Eden和其中一个survivor）。如果一个survivor容纳不下当前轮次的存活对象，则需要依赖老年代进行分配担保（大对象直接放入老年代）

>eden区的对象都是朝升息灭的，每对Eden区和第一块survivor进行回收后，存活的对象复制进入第二个survivor，然后对Eden和第一块survivor全部清空，然后在将第二块survivor的对象复制进第一块。（也可能下一次扫描Eden和第二块survivor，然后复制存活对象到第一块survivor，看具体实现）下一次GC再次重复这个过程。因此**其中一个survivor相当于起到了一个交换缓冲区的作用**。  
>每一次复制，存活的对象对应对象头的age会加一，默认情况下达到15就可以晋升到老年代了。
>以通过JVM参数“-XX:MaxTenuringThreshold”来设置，默认是15岁


复制算法的最大特点就是**不产生内存碎片**，新生代内存相对规整，可以使用**碰撞指针**的方式分配内存。  
缺点的话就是复制耗时，而且一般存在至少10%的空间没有被利用

#### 动态年龄判断
>动态对象年龄判定：
>年龄1+年龄2+年龄3+年龄N的对象加起来的空间，大于survivor区域的一半，就会让年龄N和年龄N以上的对象进入老年代。动态年龄判断应该是这样子的。说的通俗一点：就是年龄从小到大对象的占据空间的累加和，而不是某一个特定年龄对象占据的空间。

1、如果没有动态计算，固定按照MaxTenuringThreshold设定的阈值作为晋升条件：

a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区大小不足以满足完成一次minorGC时，jvm会将Eden+Svuvivor中存活的一股脑全部移动到老年代，不管对象的年龄是多少。这样对象老化的机制就失效了。

b）MaxTenuringThreshold设置的过小，那么对象就会更早的被移动到老年代，对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。

2、应用程序在不同时间节点上的请求量与并发量都不同：特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面相同的问题。

总结来说，为了更好的适应不同程序的内存情况，虚拟机并不总是要求对象年龄必须达到Maxtenuringthreshhold再晋级老年代。而是通过这种方式来实现老年代的晋升。


#### 大对象直接进入老年代
有一个JVM参数，就是“-XX:PretenureSizeThreshold”，可以把他的值设置为字节数，比如“1048576”字节，就是1MB。

如果你要创建一个大于这个大小的对象，比如一个超大的数组，或者是别的啥东西，此时就直接把这个大对象放到老年 代里去。压根儿不会经过新生代。 之所以这么做，就是要避免新生代里出现那种大对象，然后屡次躲过GC，还得把他在两个Survivor区域里来回复制多次之后才能进入 老年代， 那么大的一个对象在内存里来回复制，不是很耗费时间吗？





#### Survivor不够存放，Old也不够存放
如果新生代里有大量对象存活下来，确实是自己的Survivor区放不下了，必须转移到老年代去。那么如果老年代里空间也不够放这些对象呢？这该咋整呢？

首先，**在执行任何一次Minor GC之前，JVM会先检查一下老年代可用的可用内存空间，是否大于新生代所有对象的总大小。**

为啥检查这个呢？因为最极端的情况下，可能新生代Minor GC过后，所有对象都存活下来了，那岂不是新生代所有对象全部要进入老 年代？

如果说发现老年代的内存大小是大于新生代所有对象的，此时就可以放心大胆的对新生代发起一次Minor GC了，因为即使Minor GC之 后所有对象都存活，Survivor区放不下了，也可以转移到老年代去。

假如Minor GC之前，发现老年代的可用内存已经小于了新生代的全部对象大小了，就会看一个“-XX:- HandlePromotionFailure”的参数是否设置了

如果有这个参数，那么就会继续尝试进行下一步判断。

下一步判断，就是看看老年代的内存大小，是否大于之前每一次Minor GC后进入老年代的对象的平均大小。 举个例子，之前每次Minor GC后，平均都有10MB左右的对象会进入老年代，那么此时老年代可用内存大于10MB。

这就说明，很可能这次Minor GC过后也是差不多10MB左右的对象会进入老年代，此时老年代空间是够的

如果上面那个步骤判断失败了，或者是“-XX:-HandlePromotionFailure”参数没设置，此时就会直接触发一次“Major GC”，就是对老年代进行垃圾回收，尽量腾出来一些内存空间，然后再执行Minor GC。

如果上面两个步骤都判断成功了，那么就是说可以冒点风险尝试一下Minor GC。此时进行Minor GC有几种可能。
第一种可能，Minor GC过后，剩余的存活对象的大小，是小于Survivor区的大小的，那么此时存活对象进入Survivor 区域即可。 
第二种可能，Minor GC过后，剩余的存活对象的大小，是大于 Survivor区域的大小，但是是小于老年代可用内存大小 的，此时就直接进入老年代即可。 
第三种可能，很不幸，Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内 存的大小。此时老年代都放不下这些存活对象了，就会发生“Handle Promotion Failure”的情况，这个时候就会触 发一次“Major GC”。

如果要是Major GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的 “OOM”内存溢出了


### 标记清除算法
主要分为标记和清除两步：从根结点开始遍历对象图，标记出所有可达的对象（这里如何标记取决于具体实现），然后回收所有不可达对象。  
**不需要额外空间，但是会产生内存碎片**——JVM需要维护**空闲列表**去分配对象的内存。（把需要清除的对象的内存地址放入空闲列表，则视为逻辑上的清除）

不适合新生代，因为新生代对象大多朝升息灭，要标记的对象太多，而且会在新生代产生大量碎片，为之后的对象创建制造困扰。

CMS就是标记清除算法的。

### 标记整理算法
标记后不是清理对象，而是**将存活对象移向内存的一端**，然后**清除端边界外的对象**  
这种**对象移动操作必须暂停用户程序（STW）**。  
该算法没有内存碎片，但是移动对象的成本很多，而且移动对象必须STW，将造成停顿时间上升，但是程序吞吐量更好，parallel scavenger就是基于标记整理算法的

老年代一般是将标记清除和标记整理混合使用的，例如，CMS虽然是基于标记清除算法，但是如果内存碎片过多导致无法分配对象，则会**使用基于标记整理的serial old垃圾回收器进行一次基于标记整理的GC。**


## 方法去里的类回收条件
首先该类的所有实例对象都已经从Java堆内存里被回收 其次加载这个类的ClassLoader已经被回收 最后，对该类的Class对象没有任何引用 满足上面三个条件就可以回收该类了。

## 跨代引用问题
我们将堆内存按照generation划分，但是每一个generation都不是独立的，新生代的对象可能引用老年代对象，反过来一样。我们不关心新生代对老年代的跨代引用，因为majorGC总是伴随着minorGC，但是我们在乎**老年代对象指向新生代对象的引用**。  
如果每次扫描一个新生代对象，还需要专门扫描一遍老年代，那么效率就太低了。  
基于假说：**跨代引用相对于同代引用，只占用极少部分**，我们不应该为了少量的跨代引用去扫描整个老年代，只需要在新生代建立一个全局的数据结构——**记忆集**


### 记忆集与卡表
记忆集相当于一个映射结构，它将老年代内存块划分为若刚个小块，每一个单位与一个小块产生映射，相当于bitMap。  
记忆集可以记录哪些内存块存在引用了新生代对象的老年代对象，我们在minorGC的时候不需要遍历老年代，只需要遍历**年轻代+记忆集**即可

**记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构**。（可以简单理解为一个对象引用数组Object[]）  
如果不考虑成本，那么这个记忆集就可以看作老年代指向年轻代对象的指针集合。

而在垃圾收集的场景中，收集器只需要通过记忆集判断出**某一块非收集区域是否存在有指向了收集区域的指针**就可以了，并不需要了解这些跨代指针的全部细节。  
卡精度：每个记录精确到一块内存区域，该区域内有对象，其中对象存在跨带指针。  
**卡表就是基于“卡精度”实现记忆集。**
>卡表是记忆集的一种实现，可以看作一个字节数组,每一个元素对应着其标识的内存区域中一块特定大小的内存块——**这个内存块中可以存在多个老年代对象**，因此一个卡页包含多个指针，如果任意一个指针是跨带指针，那么就将卡页标记为dirty，GC时扫描该卡页中的对象。  
>再通俗点，就把卡表看作一个布尔数组，每个单位映射到一块内存，如果b[2]=true，我YGC的时候就连带这扫描2映射到的那块老年代内存区。


#### 卡表
基于卡表（Card Table）的设计，**通常将堆空间划分为一系列2次幂大小的卡页（Card Page）**。

HotSpot JVM的卡页（Card Page）大小为512字节，卡表（Card Table）被实现为一个简单的字节数组，即卡表的每个标记项为1个字节。

当对一个对象引用进行写操作时（对象引用改变），**写屏障**逻辑将会标记对象所在的卡页为dirty。
>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的AOP切面

计算引用对象地址对应的卡页:`CARD_TABLE [this address >> 9] = 0;`
将地址除以512得到对应的卡表项的索引下标


卡表就是对一块块内存地址的映射，每一块称为一个**卡页**。只要一个卡页内的对象存在一个或者多个跨带引用指针，则**将该位置的卡表数组元素置为脏**。GC的时候将GC root连同脏卡表映射的地址一起扫描。

**卡页变脏的动作**原则上发生在引用类型字段赋值的那一刻，实现上，维护卡表状态的动作被放到了引用类型字段赋值的时候。（只要对引用类型进行更新都会产生额外的开销，不管是否是跨代引用）  
JVM注入的一小段代码，用于记录指针变化 Object.field = /<reference/>(putfield)  
**当更新（引用类型）指针的时候，标记（卡表中的卡）card为dirty，将card存于dirty card queue（当队列中达到一定数量时才考虑真正去同步更新Rset）。**  
HotSpot是通过写屏障技术维护卡表状态的，**写屏障相当于对“应用类型字段赋值”这个动作包了一层代码，赋值的前后都在写屏障的覆盖范围了**
>可看做在虚拟机层面对“引用类型字段赋值”动作的**AOP切面**，在赋值时产生一个环形通知。赋值前后都属于写屏障，赋值前称为“**写前屏障**（Pre-Write Barrier）”，赋值后称为“**写后屏障**（Post-Write Barrier）”。

因为java是基于多线程的，如果立即更新RS，那么可能存在竞争关系，因为写屏障（更新引用变量）的操作发送在线程中，十分频繁。


##### 引入写屏障和卡表带来的问题
###### 1.无条件写屏障带来的性能开销
每次对引用的更新，无论是否更新了老年代对新生代对象的引用，都会进行一次写屏障操作。显然，这会增加一些额外的开销。但是，与YGC时扫描整个老年代相比较，这个开销就低得多了。

不过，在高并发环境下，写屏障又带来了虚共享（false sharing）问题。

###### 2.高并发下虚共享带来的性能开销
在高并发情况下，频繁的写屏障很容易发生虚共享（false sharing），从而带来性能开销。

假设CPU缓存行大小为64字节，由于一个卡表项占1个字节，这意味着，64个卡表项将共享同一个缓存行。

HotSpot每个卡页为512字节，那么一个缓存行将对应64个卡页一共64*512=32KB。

如果不同线程对对象引用的更新操作，恰好位于同一个32KB区域内，这将导致同时更新卡表的同一个缓存行，从而造成缓存行的写回、无效化或者同步操作，间接影响程序性能。

一个简单的解决方案，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表项未被标记过才将其标记为dirty。

这就是JDK 7中引入的解决方法，引入了一个新的JVM参数-XX:+UseCondCardMark，在执行写屏障之前，先简单的做一下判断。如果卡页已被标识过，则不再进行标识。

```java
if (CARD_TABLE [this address >> 9] != 0)
  CARD_TABLE [this address >> 9] = 0;

```

与原来的实现相比，只是简单的增加了一个判断操作。

虽然开启-XX:+UseCondCardMark之后多了一些判断开销，但是却可以避免在高并发情况下可能发生的并发写卡表问题。通过减少并发写操作，进而避免出现虚共享问题（false sharing）。


###### 虚/伪共享
缓存是由缓存行组成的，通常是64字节组成。

一个java的long类型是8字节，因此一个缓存行中可以存放8个long类型的变量。

缓存每次更新都从主存读取连续的64个字节，即一个缓存行。因此如果访问一个long类型的数组时，数组中的一个值被加载到缓存，其余7个也会被加载到缓存。

此时也就会出现相应的问题：

如：

有一个单独的long类型变量x，还有另一个单独的long类型变量y，当加载x时，y也会被加载进去。

但当多线程操作时，如果对x进行修改，对x更新后，其他所有包含x的缓存行失效，需要将新的x写回主存。而另一个线程读取y时，发现y已经失效了，就需要去主存重新加载。

此时与x相互独立的y会因为每次对x的修改而重新到主存读取，这就是伪共享，会导致性能下降。

(在多线程程序执行的过程中，有可能将2个或多个需要频繁修改的变量存储在同一个缓存行当中。这样以来，会频繁的造成缓存头失效的问题)

从编码的角度，为了解决上面的问题，可以使用额外字段来填充缓存行数据。从而达到不同变量之间占用不用的缓存行，增加缓存的命中率

[对齐填充的目的_轻描淡写-CSDN博客_为什么要有对齐填充](https://blog.csdn.net/qq_36336332/article/details/117395992?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-117395992.pc_agg_new_rank&utm_term=java%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85&spm=1000.2123.3001.4430)

@sun.misc.Contended 是 Java 8 新增的一个注解，对某字段加上该注解则表示该字段会单独占用一个**缓存行**（Cache Line）。

适用场景：主要适用于**频繁写**的**共享数据**上。如果不是频繁写的数据，那么 CPU 缓存行被锁的几率就不多，所以没必要使用了，否则不仅占空间还会浪费 CPU 访问操作数据的时间。

**也用于CMS GC**

CMS在并发标记阶段，应用线程和GC线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：

-   新生代的对象晋升到老年代；
-   直接在老年代分配对象；
-   老年代对象的引用关系发生变更；
-   等等。

对于这些对象，需要重新标记以防止被遗漏。为了提高重新标记的效率，并发标记阶段会把这些发生变化的对象所在的Card标识为Dirty，这样后续阶段就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。

## 回答三个问题
【1】何时触发GC  
对于主流和常见的垃圾回收器来说，堆内存的Eden区无法容纳待创建的对象，触发**minorGC**。如果某一个新生代的对象需要晋升到老年代或者一个大对象准备放入老年代，而且老年代没有足够内存空间，则触发**majorGC**。（频繁YGC而导致不断有对象晋升，会触发FGC）  
根据一些垃圾回收器的特点，还会有一些其他的触发时机，例如CMS扫描到堆内存使用率超过某一个阈值，会产生一个concurrent mode failure并提前触发major/full GC。（如果考虑G1，那就能说更多了，下面再说）  
【2】对什么对象执行垃圾回收  
从GC roots开始扫描，最终被判定为不可达的对象，且**经过第一次标记没有被finalize方法复活的对象**  （如果重新让某个GC Roots变量引用了自己，那么就不用被垃圾回收了。）
【3】GC做了什么  
针对**不同分代**的**不同的垃圾回收器**具有不同的行为，可以举例其中一个垃圾回收器进行详细说明，例如年轻代的基于标记复制算法的serial垃圾回收器、老年代的基于标记清除的CMS垃圾回收器。


## 经典垃圾回收器
垃圾回收器的使用更多是看场景，下面的垃圾回收器更像是一段的历史，要从发展和迭代的眼光看待

### serial
串行垃圾回收器是最基本的垃圾回收器，使用**复制算法**。是一个单线程的收集器，并且在进行垃圾回收的同时，必须暂停其他所有的工作线程，直到垃圾回收结束。  
它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是**java虚拟机运行在Client模式下默认的新生代垃圾收集器**。
>垃圾回收中的“并行”和“串行”：并行指的是多条垃圾收集线程并行工作，而用户线程处于暂停状态。串行则指的是单条垃圾收集线程。  
>并发一般指的是用户线程与垃圾收集线程同时执行，如CMS/G1

通过**-XX:UseSerialGC**参数，可以使用两个新老代串行回收器的组合（垃圾回收器启用一般都是-XX：Use 垃圾回收器名字 GC）
>类比redis，serial不需要上下文切换，而此时用户线程又是STW，相当于GC 线程独占了CPU，效率也是比较高的。

### serial Old
使用**标记整理**算法。  
这个收集器也主要是运行在**Client默认的java虚拟机默认的年老代垃圾收集器**

两个Serial类型收集器配合使用，GC执行的**全程都是STW**的


### parallel scavenger
也是使用**复制算法**的**新生代**垃圾回收器，也是一个多线程垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量。（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即**吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）**（即最大化用户代码的执行效率）

高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，**主要适用于在后台运算而不需要太多交互的任务。** **自适应调节策略**也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。  
parNew仅是serial的一个多GC线程并行回收版本，而parallel scavenger问世的目的就是为了达到可控吞吐量

>parallel scavenger问世时处于一个尴尬的地位，因为当时能够与他搭配的老年代收集器只有serial old，由于**serial old更适用于客户端，而服务器应用性能不佳**，使得parallel scavenger未能在整体上达到吞吐量优先的目标。  
>**CMS无法与parallel scavenger配合工作**  
>而parallel old的问世更像是为了与parallel scavenger进行搭配。

### parallel old
Parallel Old收集器是Parallel Scavenge的年老代版本，使用**多线程的标记-整理算法**，在JDK1.6 才开始提供。（在此之前老年代只能使用serial old与parallel scavenger搭配使用）  
而serial old性能低于parallel scavenger使得吞吐量优先的效果不好


### CMS
CMS是第一款具有真正意义的并发收集器，可以使用GC线程与用户线程并行工作，是一款**老年代垃圾收集器**。其**主要目的是获取最短垃圾回收停顿时间**。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验
![[Pasted image 20220214213401.png]]

（注意，每一个步骤的GC线程都开始于一个安全点）  
【1】**初始标记**：只是标记一下**GC Roots能直接关联的对象**（根结点枚举的过程），速度很快（仅是直接关联的对象，不向下探索），仍然需要暂停所有的工作线程（STW）  
【2】**并发标记**：**从【1】标记出的对象开始遍历整个对象图的过程**。进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。  
【3】**重新标记**：（STW，时间也短，比【1】长一点）为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要**暂停所有的工作线程（比初始标记长一点，比并发标记短）**（例如通过**增量更新**的方式修复对象图）  
【4】**并发清除**：**（清理掉以上标记阶段中，被判定已经死亡的对象，释放内存空间）** 清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以**总体上来看 CMS收集器的内存回收和用户线程是一起并发地执行**。**（并发清除，不涉及移动对象，不会打扰用户线程占用的内存空间）**

>年轻代垃圾回收器一般是整体STW的，因为年轻代要回收的对象十分多，而老年代的对象都是经过多次YGC后晋升上去的对象，而且老年代一般是年轻代的两倍大小，一般可以通过并发标记的方式缩短停顿时间。

CMS垃圾回收器可以减少垃圾停顿的时间，缺点也很明显——频繁的进行垃圾回收，吞吐量下降；标记清除带来的缺点：存在**内存碎片（基于mark sweep）**【应该使用空闲链表分配内存，因为**可分配内存不够规整**】

与CMS搭配使用的主要是**parNew**，因此minorGC的时候会STW并以多个GC线程的方式进行垃圾回收，而Full GC的时候则使用多个GC线程对老年代空间进行扫描，并进行并发标记清除（CMS）

CMS应该确保应用程序有足够内存可用，因此不能“快满了”才开始回收，而是**当堆内存使用率达到某一阈值的时候，便开始进行回收**。  
**如果CMS运行期间预留的内存无法满足程序需要，则会出现concurrent mode failure失败**，这时JVM将会启动后备预案——**临时启用serial old重新进行老年代垃圾回收，防止用户程序OOM**。由concurrent mode failure导致一次 Full GC产生。另一方面，CMS会产生内存碎片，**并发清除后可能使得用户线程可分配空间不足**，（普遍基于复制算法的年轻代GC）无法为大对象分配内存时可能会提前触发Full GC。
>CMS垃圾收集器特有的错误，CMS的垃圾清理和应用线程运行是并行进行的，如果在**并行清理的过程中老年代的空间不足以容纳应用新产生的垃圾**（也就是老年代正在清理，用户线程产生垃圾触发GC，而从年轻代晋升了新的对象，或者用户程序直接分配大对象年轻代放不下导致直接在老年代生成，这时候老年代也放不下），则会抛出“concurrent mode failure”

一旦CMS退化为serial old，则停顿时间将会大大增加（退化为了STW）。产生该现象可能的原因：  
【1】空间碎片太多，用户程序运行时总是在触发minor GC  
【2】CMS触发太晚了  
【3】用户产生垃圾的速度超过了CMS清理的速度

CMS收集器也无法处理**浮动垃圾**，并发标记阶段如果产生了新的垃圾对象，CMS无法及时对新产生的垃圾对象进行标记，只能留到下一次并发GC。（CMS可以通过**增量更新**避免对象被误删除，但是不能处理浮动垃圾）

CMS对CPU资源十分敏感，并发阶段将会**占用一部分操作系统线程资源（参与CPU争抢）**，导致应用程序变慢（需要等待获得CPU资源），总吞吐量下降  
**CMS默认启动的线程数是 (ParallelGCThreads + 3) / 4**，**ParallelGCThreads是年轻代并行收集器的线程数**，可以当做是 **CPU 最大支持的线程数**。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕

>-XX：+use concMarkSweep GC 手动指定使用CMS执行内存回收任务，同时useParNewGC会自动打开——parNew（年轻代）+CMS（老年代）+serial old（老年代备选）  
>-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理  ，默认 是0，意思就是每次Full GC之后都会进行一次内存整理。
>-XX:ParallelCMSThreads：设置CMS的线程数量
>-XX:+UseCMSCompactAtFullCollection：在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片 连续内存空间，避免内存碎片。
>XX:CMSInitiatingOccupancyFaction：参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是 92%。



### G1
现代的堆越来越大，不适合全堆扫描。而G1是一个面向全堆的垃圾回收器，在JDK9正式替换了parallel scavenger/parallel old的组合，成为服务器模式下的默认垃圾回收器。(分区算法)

>G1使用：  
【1】开启G1垃圾回收器  
【2】设置堆的最大内存(-Xmx:)  
【3】设置最大停顿时间（-XX：MaxGCPauseMillis）

G1可以看作同时具有parallel scavenger和CMS的特点，官方目标：**在（停顿时间）延迟可控的情况下，尽可能获得高的吞吐量**。  
相对于parallel scavenger，G1可以建立停顿时间模型，做到**软实时**，同时尽可能获得高的吞吐量。相对于CMS，G1可以避免内存碎片，同时兼顾吞吐量。

G1不再将回收目标限定在某个区域，而是将内存切块，将回收的部分组成**回收集合collection set**，衡量的标准不再是属于哪一个分代，而是**哪一块（region）的垃圾数量最多，回收收益最大**，这就是G1的mixed GC模式。  
G1 收集器**避免全区域垃圾收集**，它把堆内存划分为**大小固定的几个独立区域region**，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个**优先级列表**，**每次根据所允许的收集时间，优先回收垃圾最多的区域**。
>和前面的几款垃圾回收器不同，G1它是面向全堆的，不管是年轻代还是老年代都可以管理，因此回收集可以同时包含不同的分代

G1会跟踪各个region中垃圾的“价值”大小，价值即为回收获得的空间大小以及回收所需时间的经验值。**每次根据用户设定的最大停顿时间，优先收集价值最大的那些region**

区域划分和优先级区域回收机制，确保 G1 收集器可以在**有限时间获得最高的垃圾收集效率**。

总结：  
G1建立了**可预测的停顿时间模型（软实时）**，可以让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒  
由于分区的原因，G1只对**选取分区（回收集)** 进行内存回收，缩小了回收的范围，可以对全局停顿情况进行更好的把控


![[Pasted image 20220214214449.png]]


G1的分区不再是Eden+survivor+tenured了。而是将内存划分为一个个的region。内存的回收是**以region作为基本单位**的。**Region之间是复制算法，但整体上实际可以看作是标记-压缩算法**。G1的垃圾回收算法可以**避免产生内存碎片**，因此G1下的堆内存比较规整，JVM通过**指针碰撞**分配空间，有利于程序的长时间运行，不会因为分配大对象时，找不到内存空间而提前触发GC，适合大内存堆。同时，G1的缺点也很明显**，垃圾回收时需要管理每个的region信息，系统变量占用内存很多，而且G1垃圾收集产生的内存占用、程序运行时的额外执行负载也很高**，因此适合大内存的堆，那种负载信息和总内存大小相比不算事的那种。

>可以通过操作系统分页内存管理和连续内存管理去对比G1和之前的那种内存分配管理

一个region可能属于Eden、survivor或者old内存区域，但是一个region只可能属于一个角色。G1收集器还增加了一种新的内存区域**humongous，主要用于存放大对象**。（如果超过1.5个region大小就放入H区）

>为什么设计humongous？  
>对于一个**短期存在的大对象**，如果直接分配到老年代就会对垃圾回收器造成负面影响。如果一个H区装不下（找不到连续区的话）那么G1会寻找连续的H区来存储，有时不得不启动full GC。

每个region的大小，通过 **-XX：G1HeapRegionSize**设置，默认最多2048个region。

每次回收不需要回收整个区域，而是选择一个**区域集合collection set**（region集合，不像之前一整代回收，而是将若干个region组合回收，这些region都是G1分析得出的有价值的region）

共两种GC： young GC和mixed GC。（尽量避免fullGC）  
G1可以在最后的回收阶段，粗略计算每个region的垃圾比例，优先回收垃圾多的region  
**将堆内存划分为若干个region，判断每个region的垃圾比例，优先回收垃圾多的region（或更有回收价值的region）。（garbage first）**

G1仍然使用分代的思想，但是不要求分代是物理上连续的，也不再坚持将内存划分为固定比例。将堆空间分为若干个区域（region），这些区域包含了**逻辑上的年轻代和老年代**

**应用场景**：面向服务端、面向具有大内存、多处理器的机器。


#### G1的跨代引用问题

一个region中的对象难以避免被其他region中的对象引用，G1同样也是基于记忆集避免全region扫描。其中**每个region都有一个对应的记忆集**。

每次reference类型数据写操作时，都会产生一个write barrier暂时中断操作，然后检查将要写入的引用指向的对象是否和该reference类型数据在不同的region（检查是否跨region修改引用，同一个region就没必要记录了，因为本身就会扫描）。如果不同，通过卡表把相关引用信息记录到引用指向对象（被跨代引用对象）的所在region对应的remember set中。当进行垃圾收集时，**在GC根结点的枚举范围包括记忆集**，就可以保证不进行全局扫描，也不会漏扫描。

![[Pasted image 20220214214737.png]]

在进入GC的时候，region2的记忆集已经记录了两块内存，这两块内存中的某些对象具有指向region对象的跨代指针。进行根结点枚举时除了需要枚举region中的对象，还需要将**脏卡页指向的内存**作为扫描的内容

#### G1垃圾回收
G1的垃圾回收主要为以下三个环节  
【1】年轻代GC  
【2】老年代并发标记过程（一般会伴随年轻代GC）  
【3】混合回收（标记和回收是两个独立的过程）  
在一定情况下还会触发**单线程**、**独占式（STW**的full GC，这是一种强力回收的保护机制。G1垃圾回收的目的是尽可能的避免full GC

>G1是面向全堆的，所以它同时具有年轻代GC和老年代GC，同时还能够在一定条件下触发mixed GC或者full GC。

其中年轻代GC和其他年轻代垃圾回收产品的过程很像，是多个GC线程和全程STW的。  
全局并发标记主要为mixed GC服务，属于老年代并发标记过程（**老年代并发标记结束后，马上开始混合回收过程**）。它标记出来老年代region垃圾数量，使得mixed GC可以创建适合的回收集，在可预测的停顿时间下，优先回收“回收价值”大的垃圾。  
因此**G1的老年代回收器不需要整个老年代被回收，一次只需要回收一小部分老年代的region就可以了**。mixedGC，老年代和年轻代region是一起被回收的（不是基于generation而是基于回收集）。

##### young GC
应用程序分配内存，当**年轻代的Eden区用尽（Eden对应region块没有空闲内存）时开始年轻代回收过程。G1的年轻代收集阶段是一个并行的独占式收集器**——年轻代GC，用户线程是STW的，多个GC线程并行清理。（和之前几款年轻代垃圾收集器的流程很像如parNew）
>（默认新生代占比region60%时，触发年轻代GC，标记复制算法，STW）  
JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，**当Eden耗尽时，G1会启动一次年轻代垃圾回收过程**。（只有Eden满才可以触发）

在年轻代回收期，会暂停所有的应用程序线程，启动多线程GC进行年轻代回收。然后从年轻代区间移动存活对象到survivor区间或者老年代区间，也有可能是两个区间都会涉及。
>G1创建回收集（collection set），回收集是指需要被回收的内存分段的集合

**年轻代回收只回收Eden区和survivor区**

**回收完Eden区和survivor区，Eden剩余存活的对象会复制到新的survivor区，survivor区达到一定的阈值可以晋升为old区对象**  
【1】达到年龄阈值 【2】动态年龄判断，survivor区年龄1、2、3对应的对象存活率加起来达到50%了，那么年龄3以上的对象直接晋升如老年代。  
一般超过region大小一半的对象都使用humongous存放，甚至使用多个存放。**该区域的回收会在新生、老年代回收时捎带回收**。

>YGC 细节补充：  
【1】首先对Eden和survivor的region块构建回收集（一般YGC构建回收集包含所有的eden和survivorregion）  
【2】将根结点连通记忆集记录的内存作为扫描存活对象的入口  
【3】将脏页队列的待更新卡页全部更新到卡表（记忆集）中  
【4】扫描记忆集，识别老年代对象指向的年轻代对象，将这些对象看作可达对象  
【5】基于复制算法，将存活对象拷贝到一块空闲的 survivor region，并且清空原region的内容（survivor内存不够则放入humongous，达到年龄阈值则晋升）  
【6】以上处理的是强引用，接下来接着处理其他类型的引用，最终回收集的region被清空，YGC完毕

##### 老年代并发标记
当堆内存的使用达到一定值（默认45%）时，开始**老年代并发标记过程**。  
过程和CMS有一定相似之处，都是一定程度上和用户线程并发执行的。

>细节;  
【1】初始标记.（STW，CMS也存在这个过程，时间很短，**标记根节点可以直接达到的对象**）  
该阶段**一般都是和minor GC同步进行的**，因此和minor GC同时等待相同的停顿时间  
minor GC的STW和并发标记过程的初始标记STW相当于一起进行了  
【2】根区域扫描  
G1扫描**survivor区对象直接引用的老年代region中的对象**，并标记被引用的对象（minor GC之前完成，因为minor GC会使用复制算法对survivor进行GC）  
【3】并发标记。  
和应用程序并发执行，**对整个堆进行并发标记**，这个过程可能被minor GC中断。在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。  
并发标记的过程中，还会计算每个区域的**对象活性（区域中存活对象的比例）**  
【4】再次标记/最终标记（STW回收 ,**修正并发标记的结果**，但是比CMS的增量更新快）采用了**STAB原始快照算法**。清空SATB缓冲区，跟踪未被访问的存活对象，并执行引用处理  
【5】独占清理(STW)  
该阶段不会进行实际上的垃圾收集，**会计算各个region的回收价值和成本，并进行排序**，**识别可以混合回收的区域**，根据用户期望的停顿时间制定回收计划。（为了达到预测时间，只会回收部分region）  
【6】并发清理阶段：识别并清理完全空闲的区域


##### mixed GC
当越来越多对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾回收器——mixed GC（通常在老年代并发标记后紧接着执行mixed GC）。该算法会**回收整个young region和部分 old region**，这里是mixed GC而不是full GC  
根据停顿时间的目标，优先选择垃圾最多的old region进行

>混合回收细节：  
【1】并发标记结束后，老年region中百分比为垃圾的内存分段被回收了，**还有一部分老年代region只有部分是垃圾**。默认情况下这些老年代的内存分段**分为8次被回收**。（该老年代region被分为8个内存分段）  
【2】混合回收的回收集，包括八分之一的老年代内存小段、Eden region和survivor region。**混合回收和年轻代回收的算法完全一致**，**只是包含了一部分老年代内存分段**。  
【3】对老年代内存分段的8次回收，G1优先收集垃圾多的小段，并有一个阈值会决定内存分段是否被回收  
【4】混合回收并不一定要进行8次。有一个阈值**-XX:G1HeapWastePercent**，默认值为10%，意思是**允许整个堆内存中有10%的空间被浪费**，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。


个人理解：引入mixed GC的目的更多是为了避免full GC，因为G1是面向整个堆的，同时支持年轻代GC和老年代GC，而G1的年轻代GC和老年代GC总是根据**内存使用量阈值触发**的，而如果内存仍然不够使用，就需要执行一次大型的GC去试图拿到更多内存，而mixed GC可以看作更轻量的full GC，是支持并行的、渐进式回收的，而full GC则是STW。


##### Full GC
G1设计的初衷就是避免full GC  
导致G1 full GC原因和CMS的concurrent mode failure类似。  
**回收阶段没有足够的to-space来存放晋升的对象**、**并发处理过程完成之前空间已经耗尽（垃圾产生速度大于回收速度，内存耗尽）**。如：堆内存太小，G1复制存活对象的时候没有空的内存分段可用，会回退到类似serial/serial old，这种情况下可以通过增大内存解决。

FullGC时，G1会停止执行应用程序，使用单线程的内存回收算法进行垃圾回收

##### G1聊天
G1是面向全堆的垃圾回收器，是官方推荐并且JDK9默认的垃圾回收器，它的主要特点就是保证软实时，可以指定一个期望的停顿时间。G1保留了分代的思想，但是将整个内存都划分为大小相同的若干个region，这个思想类似操作系统的内存分页管理的思想。并且每次不是选取某个区进行GC，而是生成一个由region组成的回收集。G1还会跟踪每个region的回收价值，为他们在后台维护一个优先级列表，每次优先回收价值最大的垃圾，这是G1实现软实时的基础，也是garbage first名字的由来。  
region之间存在跨度引用问题，需要为每个region维护一个卡表，这个卡表指向存在指向当前region指针所在的内存区域。  
G1是面向全堆的，可以分为三个阶段：年轻代GC、老年代并发标记清除以及mixed GC，在某些情况下还会引发full GC。G1设计的初衷就是避免full GC，因为full GC阶段会退化为单线程GC，停顿时间大大增加。  
其中年轻代GC类似于其他年轻代GC产品，是STW独占式回收的，每个region都是基于标记复制算法，整体上看是标记整理算法，当eden区的region耗尽后就会触发YGC，G1会创建回收集，并将eden和survivor region中有价值的垃圾作为回收集的一部分。回收完Eden区和survivor区，Eden剩余存活的对象会复制到新的survivor区，survivor区达到一定的阈值可以晋升为old区对象。  
老年代并发标记过程为mixed GC服务，算法类似CMS，可以分为初始标记、并发标记、修正标记和并发清理。当有不断地年轻代向老年代晋升就会触发mixed GC，mixed GC的内容是年轻代与部分老年代，而且根据暂停目标，优先选择垃圾最多的老年代region进行。


##### 常见GC参数
**-XX:G1 heap region size** 默认2048 ，region总数，堆内存/总数就是单个region大小

> 如果一个对象的对象大于region的一半，就会被视为大对象并放入humongous区。某些场景下，可以适度调大region size，减少大对象的判断，提高普通region空间的利用率。

-XX:G1 new size percent 上限默认5%  
-XX:G1 max new size percent 下限默认60% 默认情况下Eden占60%。

-XX:Parallel GC threads STW阶段工作的并行线程数量

-XX: initializating heap occupancy percent 触发全局并发标记的老年代占比，默认45%  
-XX:max tenuring threshold 晋升年龄阈值，调节该值，可以控制大对象的晋升数量  
-XX: pretenure size threshold: 设置**大对象直接进入老年代的阈值**  
-xx:G1 heap waste percent 触发混合GC的堆垃圾占比

-XX：+ Use conc mark sweep gc 开启CMS（use GC名字 GC）  
**-XX: + trace class loading 监控类加载**  
**-XX:newRatio 新老比例**  
**-XX:survivorRatio：survivor区和Eden比例**  
-XX: + head dump on Out of memory error 出现OOM时导出堆信息到文件中

-XX:+UseG1GC 启用G1  
-XX:MaxGCPauseMillis 设置最大垃圾回收停顿时间

**-XX：printGC  
-verbose：gc** **打印GC日志**

>反正常问的注意一下:启用某个垃圾收集器、开启GC日志、G1相关的、然后就是一些相对通用的如：新老比例、E和S的比例、晋升阈值、一些指定上下限的值…（还有一些常用的GC参数就是堆、栈相关的参数了）



## 一定需要知道的

堆上限 -Xmx 即 memory max  
堆下限 -Xms 即 memory size  
打印类加载信息 -XX:+TraceClassLoading  
并行GC线程数量 -XX:parallel GC Thread  
eden和survivor的比例： -XX：survivor ratio 如果是8代表eden占8份，两个survivor各占一份，survivor占1/10  
新老比例：-XX：new ratio ： 4代表，老占4，新占1。（老年代比较大）  
晋升老年代年龄：-XX:max tenuring threshold  
打印GC日志：-XX：+printGC（details） 或者 -verbose:gc  
G1 region大小： -XX：G1 heap region size  
G1 预期停顿时间 ：-XX:Max GC Pause Millis

-Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了 

-XX:PermSize：永久代大小    -XX:MaxPermSize：永久代最大大小 
如果是JDK 1.8以后的版本，那么这俩参数被替换为了-XX:MetaspaceSize和-XX:MaxMetaspaceSize

-Xss：每个线程的栈内存大小

么如果是在线上部署系统应该如何设置JVM参数呢？ 其实都很简单，比如说采用“java -jar”的方式启动一个jar包里的系统，那么就可以采用类似下面的格式： java -Xms512M -Xmx512M -Xmn256M -Xss1M -XX:PermSize=128M -XX:MaxPermSize=128M -jar App.jar 

如果是现在非常流行的那种启动Spring Boot开发的系统呢？
Spring Boot其实就是启动的时候可以加上JVM参数，Tomcat就是在bin目录下的catalina.sh中可以加入 JVM参数


## CMS和G1
https://blog.csdn.net/hhchhc_/article/details/120227211

为什么要分为Eden和Survivor?
1.如果没有Survivor的话每一次 Minor GC存活的对象就被送入老年代，那么老年代很快就被填满，从而触发Full GC，而一次FullGC的时间远大于 Minor GC，所以要划分Eden : from : to=8:1:1。

2.Survivor存在的意义就是减少被送到老年代的对象，进而减少Full GC只有经过16次的Minor GC的对象才能送到老年代。

为什么要设置两个Survivor区？
而设置两个Survivor区最大的好处就是解决了碎片化，当Eden区满后，进行 Minor GC，存活的对象就会被移动到第一块survivor from，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden区和survivor from中的存活对象又会被复制送入第二块survivor to。这种复制算法保证了to中来自from和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生。

一次完整的GC流程是怎样的？
当 Eden 区的空间满了， Java虚拟机会触发一次 Minor GC，以收集新生代的垃圾，存活下来的对象，被转移到 Survivor区此时年龄设为1。之后每经过一次Minor GC年龄就加1满15次还存活的对象就被送到老年代，当老年代满了无法再存对象时会触发Full GC，Full GC清理整个java堆。

大对象（需要大量连续内存空间的Java对象）直接进入老年代。

你知道哪几种垃圾收集器？有什么区别？
CMS收集器与G1收集器

区别：
CMS收集器是老年代的收集器，可以配合新生代的Serial和ParNew收集器一起使用；
G1收集器收集范围是老年代和新生代，不需要结合其他收集器使用；
CMS收集器以最小的停顿时间为目标的收集器；
G1收集器可预测垃圾回收的停顿时间
CMS收集器是使用“标记-清除”算法进行的垃圾回收，容易产生内存碎片
G1收集器使用的是“标记-整理”算法，进行了空间整合，降低了内存空间碎片。

### 自己整理的G1

  G1 收集器不采用传统的新生代和老年代物理隔离的布局方式，仅在逻辑上划分新生代和老年代，使用不同的Region来表示新生代和老年代。内存的回收是**以region作为基本单位**的。**Region之间是复制算法，但整体上实际可以看作是标记-压缩算法**。G1的垃圾回收算法可以**避免产生内存碎片**，因此G1下的堆内存比较规整，JVM通过**指针碰撞**分配空间，有利于程序的长时间运行，不会因为分配大对象时，找不到内存空间而提前触发GC，适合大内存堆

除了Eden，survivor和Old这三种内存区域，还额外增加了一种新的内存区域**humongous，主要用于存放大对象**。（如果超过1.5个region大小就放入H区）
>为什么设计humongous？  
>对于一个**短期存在的大对象**，如果直接分配到老年代就会对垃圾回收器造成负面影响。如果一个H区装不下（找不到连续区的话）那么G1会寻找连续的H区来存储，有时不得不启动full GC。

特点:
-   基于 “标记-整理” 算法，收集后不会产生内存碎片。
-   保持软实时与获得尽可能高的吞吐量

每次回收不需要回收整个区域，而是选择一个**区域集合collection set**（region集合，不像之前一整代回收，而是将若干个region组合回收，这些region都是G1分析得出的有价值的region）
G1 收集器**避免全区域垃圾收集**，它把堆内存划分为**大小固定的几个独立区域region**，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个**优先级列表**，**每次根据所允许的收集时间，优先回收垃圾最多的区域**。
>和前面的几款垃圾回收器不同，G1它是面向全堆的，不管是年轻代还是老年代都可以管理，因此回收集可以同时包含不同的分代

区域划分和优先级区域回收机制，确保 G1 收集器可以在**有限时间获得最高的垃圾收集效率**。

#### 跨代引用
一个region中的对象难以避免被其他region中的对象引用，G1同样也是基于记忆集避免全region扫描。其中**每个region都有一个对应的记忆集**。

每次reference类型数据写操作时，都会产生一个write barrier暂时中断操作，然后检查将要写入的引用指向的对象是否和该reference类型数据在不同的region（检查是否跨region修改引用，同一个region就没必要记录了，因为本身就会扫描）。如果不同，通过卡表把相关引用信息记录到引用指向对象（被跨代引用对象）的所在region对应的remember set中。当进行垃圾收集时，**在GC根结点的枚举范围包括记忆集**，就可以保证不进行全局扫描，也不会漏扫描。

#### 垃圾回收

G1的垃圾回收主要为以下三个环节  
【1】年轻代GC  
【2】老年代并发标记过程（一般会伴随年轻代GC）  
【3】混合回收（标记和回收是两个独立的过程）  
在一定情况下还会触发**单线程**、**独占式（STW**的full GC，这是一种强力回收的保护机制。G1垃圾回收的目的是尽可能的避免full GC

>G1是面向全堆的，所以它同时具有年轻代GC和老年代GC，同时还能够在一定条件下触发mixed GC或者full GC。

其中年轻代GC和其他年轻代垃圾回收产品的过程很像，是多个GC线程和全程STW的。  
全局并发标记主要为mixed GC服务，属于老年代并发标记过程（**老年代并发标记结束后，马上开始混合回收过程**）。它标记出来老年代region垃圾数量，使得mixed GC可以创建适合的回收集，在可预测的停顿时间下，优先回收“回收价值”大的垃圾。  
因此**G1的老年代回收器不需要整个老年代被回收，一次只需要回收一小部分老年代的region就可以了**。mixedGC，老年代和年轻代region是一起被回收的（不是基于generation而是基于回收集）。

##### young GC
应用程序分配内存，当**年轻代的Eden区用尽（Eden对应region块没有空闲内存）时开始年轻代回收过程。G1的年轻代收集阶段是一个并行的独占式收集器**——年轻代GC，用户线程是STW的，多个GC线程并行清理。（和之前几款年轻代垃圾收集器的流程很像如parNew）
>（默认新生代占比region60%时，触发年轻代GC，标记复制算法，STW）  
JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，**当Eden耗尽时，G1会启动一次年轻代垃圾回收过程**。（只有Eden满才可以触发）

在年轻代回收期，会暂停所有的应用程序线程，启动多线程GC进行年轻代回收。然后从年轻代区间移动存活对象到survivor区间或者老年代区间，也有可能是两个区间都会涉及。
>G1创建回收集（collection set），回收集是指需要被回收的内存分段的集合

**年轻代回收只回收Eden区和survivor区**

**回收完Eden区和survivor区，Eden剩余存活的对象会复制到新的survivor区，survivor区达到一定的阈值可以晋升为old区对象**  
【1】达到年龄阈值 【2】动态年龄判断，survivor区年龄1、2、3对应的对象存活率加起来达到50%了，那么年龄3以上的对象直接晋升如老年代。  
一般超过region大小一半的对象都使用humongous存放，甚至使用多个存放。**该区域的回收会在新生、老年代回收时捎带回收**。

>YGC 细节补充：  
【1】首先对Eden和survivor的region块构建回收集（一般YGC构建回收集包含所有的eden和survivorregion）  
【2】将根结点连通记忆集记录的内存作为扫描存活对象的入口  
【3】将脏页队列的待更新卡页全部更新到卡表（记忆集）中  
【4】扫描记忆集，识别老年代对象指向的年轻代对象，将这些对象看作可达对象  
【5】基于复制算法，将存活对象拷贝到一块空闲的 survivor region，并且清空原region的内容（survivor内存不够则放入humongous，达到年龄阈值则晋升）  
【6】以上处理的是强引用，接下来接着处理其他类型的引用，最终回收集的region被清空，YGC完毕

##### 老年代并发标记
当堆内存的使用达到一定值（默认45%）时，开始**老年代并发标记过程**。  
过程和CMS有一定相似之处，都是一定程度上和用户线程并发执行的。

>细节;  
【1】初始标记.（STW，CMS也存在这个过程，时间很短，**标记根节点可以直接达到的对象**）  
该阶段**一般都是和minor GC同步进行的**，因此和minor GC同时等待相同的停顿时间  
minor GC的STW和并发标记过程的初始标记STW相当于一起进行了  
【2】根区域扫描  
G1扫描**survivor区对象直接引用的老年代region中的对象**，并标记被引用的对象（minor GC之前完成，因为minor GC会使用复制算法对survivor进行GC）  
【3】并发标记。  
和应用程序并发执行，**对整个堆进行并发标记**，这个过程可能被minor GC中断。在并发标记阶段，**若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收**。  
并发标记的过程中，还会计算每个区域的**对象活性（区域中存活对象的比例）**  
【4】再次标记/最终标记（STW回收 ,**修正并发标记的结果**，但是比CMS的增量更新快）采用了**STAB原始快照算法**。清空SATB缓冲区，跟踪未被访问的存活对象，并执行引用处理  
【5】独占清理(STW)  
该阶段不会进行实际上的垃圾收集，**会计算各个region的回收价值和成本，并进行排序**，**识别可以混合回收的区域**，根据用户期望的停顿时间制定回收计划。（为了达到预测时间，只会回收部分region）  
【6】并发清理阶段：识别并清理完全空闲的区域


###### 解决漏标的两种方法
[(76条消息) JVM的三色标记法&漏标解决方案：增量更新|原始快照_复利人生的博客-CSDN博客_jvm增量更新](https://blog.csdn.net/u013039395/article/details/118058522)
[一篇文章搞懂G1收集器 - 简书 (jianshu.com)](https://www.jianshu.com/p/d3ef24ec9b30)
[(76条消息) G1 垃圾收集器原理详解_张维鹏的博客-CSDN博客_g1垃圾回收器详解](https://blog.csdn.net/a745233700/article/details/121724998)

https://blog.csdn.net/weixin_51626435/article/details/123057455


方案一：增量更新：Incremental Update

增量更新破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用时，就将这个新加入的引用记录下来，待并发标记完成后，重新对这种新增的引用记录进行扫描；

可以简单理解为,当一个黑色对象增加了对白色对象的引用,那么这个黑色对象就被变灰

**这样有一个缺点,就是会重新扫描这个黑色对象的所有引用,比较浪费时间**

原始快照：Snapshot At The Beginning，SATB

原始快照破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，也是将这个记录下来，并发标记完成后，对该记录进行重新扫描,并将重新扫描到的白色对象直接标记为黑色，不用一层层遍历；

可以简单理解为,当一个灰色对象取消了对白色对象的引用,那么这个白色对象被变灰

**这样做的缺点就是,这个白色对象有可能并没有黑色对象去引用它,但是它还是被变灰了,就会导致它和它的引用,本来应该被垃圾回收掉,但是此次GC存活了下来,就是所谓的浮动垃圾.其实这样是比较可以忍受的,只是让它多存活了一次GC而已,浪费一点点空间,但是会比增量更新更省时间.**



由于G1写屏障的复杂操作要比CMS消耗更多的运算资源，CMS的写屏障实现是直接的同步操作，而G1必须把它实现为类似消息队列的架构，即把写前屏障和写后屏障要做的事都放到队列里，然后异步处理。

##### mixed GC
当越来越多对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾回收器——mixed GC（通常在老年代并发标记后紧接着执行mixed GC）。该算法会**回收整个young region和部分 old region**，这里是mixed GC而不是full GC  
根据停顿时间的目标，优先选择垃圾最多的old region进行

>混合回收细节：  
【1】并发标记结束后，老年region中百分比为垃圾的内存分段被回收了，**还有一部分老年代region只有部分是垃圾**。默认情况下这些老年代的内存分段**分为8次被回收**。（该老年代region被分为8个内存分段）  
【2】混合回收的回收集，包括八分之一的老年代内存小段、Eden region和survivor region。**混合回收和年轻代回收的算法完全一致**，**只是包含了一部分老年代内存分段**。  
【3】对老年代内存分段的8次回收，G1优先收集垃圾多的小段，并有一个阈值会决定内存分段是否被回收  
【4】混合回收并不一定要进行8次。有一个阈值**-XX:G1HeapWastePercent**，默认值为10%，意思是**允许整个堆内存中有10%的空间被浪费**，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。


个人理解：引入mixed GC的目的更多是为了避免full GC，因为G1是面向整个堆的，同时支持年轻代GC和老年代GC，而G1的年轻代GC和老年代GC总是根据**内存使用量阈值触发**的，而如果内存仍然不够使用，就需要执行一次大型的GC去试图拿到更多内存，而mixed GC可以看作更轻量的full GC，是支持并行的、渐进式回收的，而full GC则是STW。


##### Full GC
G1设计的初衷就是避免full GC  
导致G1 full GC原因和CMS的concurrent mode failure类似。  
**回收阶段没有足够的to-space来存放晋升的对象**、**并发处理过程完成之前空间已经耗尽（垃圾产生速度大于回收速度，内存耗尽）**。如：堆内存太小，G1复制存活对象的时候没有空的内存分段可用，会回退到类似serial/serial old，这种情况下可以通过增大内存解决。

FullGC时，G1会停止执行应用程序，使用单线程的内存回收算法进行垃圾回收

##### G1聊天
G1是面向全堆的垃圾回收器，是官方推荐并且JDK9默认的垃圾回收器，它的主要特点就是保证软实时，可以指定一个期望的停顿时间。G1保留了分代的思想，但是将整个内存都划分为大小相同的若干个region，这个思想类似操作系统的内存分页管理的思想。并且每次不是选取某个区进行GC，而是生成一个由region组成的回收集。G1还会跟踪每个region的回收价值，为他们在后台维护一个优先级列表，每次优先回收价值最大的垃圾，这是G1实现软实时的基础，也是garbage first名字的由来。  
region之间存在跨度引用问题，需要为每个region维护一个卡表，这个卡表指向存在指向当前region指针所在的内存区域。  
G1是面向全堆的，可以分为三个阶段：年轻代GC、老年代并发标记清除以及mixed GC，在某些情况下还会引发full GC。G1设计的初衷就是避免full GC，因为full GC阶段会退化为单线程GC，停顿时间大大增加。  
其中年轻代GC类似于其他年轻代GC产品，是STW独占式回收的，每个region都是基于标记复制算法，整体上看是标记整理算法，当eden区的region耗尽后就会触发YGC，G1会创建回收集，并将eden和survivor region中有价值的垃圾作为回收集的一部分。回收完Eden区和survivor区，Eden剩余存活的对象会复制到新的survivor区，survivor区达到一定的阈值可以晋升为old区对象。  
老年代并发标记过程为mixed GC服务，算法类似CMS，可以分为初始标记、并发标记、修正标记和并发清理。当有不断地年轻代向老年代晋升就会触发mixed GC，mixed GC的内容是年轻代与部分老年代，而且根据暂停目标，优先选择垃圾最多的老年代region进行。



## Tomcat类加载器

Tomcat 为何要打破双亲委派机制，正如上文提到，双亲委派机制的好处有防止类重复加载，保证类的唯一性，然而 Tomcat 的 webapps 下可以部署多个应用，若多个应用中具有同名类（包结构也一致），但实现方式不同，只加载一份会导致异常，因此需要打破双亲委派机制。

只要加载类的时候不是 应用类加载器->扩展类加载器->启动类加载器这个顺序找就是打破了双亲委派机制。

1.  自定义加载器，需要继承 `ClassLoader` 。因为加载class核心的方法在`LoaderClass`类的`loadClass`方法上，如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass方法`即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass方法`。
    
2.  线程上下文类加载器`Thread Context ClassLoader`。这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。
    
    这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。
    

> tomcat破坏了双亲委派机制

在初学时部署项目，我们是把war包放到tomcat的webapp下，这意味着一个tomcat可以运行多个Web应用程序。

那假设我现在有两个Web应用程序，它们都有一个类，叫做User，并且它们的类全限定名都一样，比如都是com.yyy.User。但是他们的具体实现是不一样的。

Tomcat给每个 Web 应用创建一个类加载器实例（WebAppClassLoader），该加载器重写了loadClass方法，优先加载当前应用目录下的类，如果当前找不到了，才一层一层往上找，那这样就做到了Web应用层级的隔离。

并不是Web应用程序下的所有依赖都需要隔离的，比如Redis就可以Web应用程序之间共享（如果有需要的话），因为如果版本相同，没必要每个Web应用程序都独自加载一份啊。

做法也很简单，Tomcat就在WebAppClassLoader上加了个父类加载器（SharedClassLoader），如果WebAppClassLoader自身没有加载到某个类，那就委托SharedClassLoader去加载。无非就是把需要应用程序之间需要共享的类放到一个共享目录下嘛。

为了隔绝Web应用程序与Tomcat本身的类，又有类加载器(CatalinaClassLoader)来装载Tomcat本身的依赖。

如果Tomcat本身的依赖和Web应用还需要共享，那么还有类加载器(CommonClassLoader)来装载进而达到共享


# 体系回答
```markdown
判断对象存活有两种: 1引用计数法 2.可达性分析算法
- 首先是进行一个根节点枚举(如何确保一致性快照,如何快速完成根节点枚举)
使用可达性分析算法时,这个操作必须要在一个能保证一致性的快照中进行,否则无法保证结果的准确性,因此需要**stop the world**，停止所有的用户线程工作，使得GC线程可以在一个一致性快照中进行垃圾回收工作

由于程序执行过程中并不是在任意位置都能够停下来,得到达"安全点"才行
主流JVM采用主动式中断,垃圾收集器需要中断线程时,在安全点以及所有创建对象和其他需要在堆上分配内存的地方设置了中断标志,各个线程在运行过程中不停地主动轮询这个标志,若为真则在最近的安全点主动挂起

但是对于处于阻塞或等待状态的线程，就无法执行中断操作，因为它们此时无法进入运行状态，这时需要引入安全区域。（如果一个线程长期sleep，那么GC将暂时无法回收该线程在堆中产生的垃圾）
安全区域可以看作安全点的拉伸，线程要么冻结在安全点的位置，要么冻结在安全区域的范围。


用户线程到达安全点后,更新自己的oopMap

- oopMap
**oop (ordinary object pointer) 普通对象指针，oopmap就是存放这些指针的map,OopMap 用于枚举 GC Roots，记录栈中引用数据类型的位置**,类加载动作完成后HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来收集器扫描时可以

一个线程为一个栈，一个栈由多个栈桢组成，一个栈桢对应一个方法，一个方法有多个安全点。GC发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的OopMap，记录栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈桢的OopMap ，通过栈中记录的被引用的对象内存地址，即可找到这些对象（GC Roots）




从这些节点开始往下遍历其引用关系,这里就涉及到三色标记法(黑,白,灰),遍历完成后,就只剩下两类对象,分别是白和黑

- 由于并发标记阶段用户线程并未停止，仍然在改变对象的引用关系,所以就可能导致:
1.黑色对象通过灰色对象引用了白色对象,但该灰色对象在这之后取消了对白色对象的引用
2.黑色对象不再被引用

第一种情况若发生,将会导致空指针,使得虚拟机崩溃,若以下两个条件同时发生将会导致该情况出现:
1.黑色对象直接引用了白色对象
2.灰色对象删除了对白色对象的引用

为了破坏这两个条件,引入了:
1.强三色不变式:保证永远不会存在黑色对象到白色对象的引用
2.弱三色不变式:所有被黑色对象引用的白色对象都处于灰色保护状态，即直接或间接从灰色对象可达

CMS收集器采用增量更新（incremental update）写屏障实现强三色不变式

解决方案  
【1】**增量更新——记录新增加引用**，这也是CMS的解决方案  
黑色对象一旦插入新的指向白色对象的引用时，就记录这个引用，之后再以这些引用中的黑色对象为根再次扫描一次——**黑色对象一旦插入了指向白色对象的引用之后，就变成了灰色对象**  
【2】**原始快照——记录被删除的引用**，这是G1的解决方案  
灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些**记录过的引用关系中的灰色对象为根，重新扫描一次**——无论引用关系删除与否，都会**按照刚刚开始扫描那一刻的对象图快照进行扫描**

第二种是浮动垃圾,等待下一次GC即可



标记修正


并发清除
```


```markdown

1. 标记复制算法
将内存划分为大小相等的两块,每次只使用其中一个,当这块内存用完了就将还存活的对象复制到另一块内存中,再把使用过的内存空间进行一次清理

这种算法更适合新生代的垃圾收集,因为新生代都是朝生夕灭,一个 young GC后仅有少部分对象存活

优化的模型是将新生代分为一个Eden区和两个Survivor区,默认比例为8:1:1
1.若一个survovor区容纳不下当前轮次存活的对象,需要依赖老年代进行分配担保,也就是大对象直接放入老年代
2.每一次GC后存活的对象的对象头中的age都会加1,默认情况达到15就晋升老年代

复制算法最大特点是不产生内存碎片,可用**碰撞指针**方式分配内存
缺点就是复制耗时,且一般存在10%的空间没有被利用

2. 标记清除算法
标出所有可达对象,回收所有不可达对象
不需要额外空间,但会产生内存碎片,JVM需要维护空闲列表去分配对象的内存,把需要清除的对象的内存地址放入空闲列表,视为逻辑上的清除

不适合新生代，因为新生代对象大多朝升息灭，要标记的对象太多，而且会在新生代产生大量碎片，为之后的对象创建制造困扰。

3. 标记整理算法
标记后不是清理对象,而是将存活对象移向内存的一端,然后清除端边界外的对象
这种对象移动操作必须暂停用户程序((STW))
该算法没有内存碎片，但是移动对象的成本很多，而且移动对象必须STW，将造成停顿时间上升，但是程序吞吐量更好，parallel scavenger就是基于标记整理算法的

老年代一般是将标记清除和标记整理混合使用的，例如，CMS虽然是基于标记清除算法，但是如果内存碎片过多导致无法分配对象，则会使用基于标记整理的serial old垃圾回收器进行一次基于标记整理的GC。


弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。
跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。

现代虚拟机根据强分代假说采用分代收集算法,根据对象的生存周期将内存分为几块,不同块采用不同的收集算法

一般分为新生代和老年代,但这样一来就出现跨代引用的问题
- 跨代引用
老年代对象可能存在对新生代的对象的引用,那么每一次扫描一个新生代对象,我们都得去扫描一遍老年代,那么结果就是效率过低

基于跨带引用假说,我们只需要在新生代建立一个全局的数据结构-记忆集

**记忆集**相当于一个映射数据结构,将老年代内存块划分为若干个小块,每一个单位与一个小块的内存空间产生映射,相当于bitMap
记忆集可以记录哪些内存块存在引用了新生代对象的老年代对象，我们在minorGC的时候不需要遍历老年代，只需要遍历**年轻代+记忆集**即可
卡精度：每个记录精确到一块内存区域，该区域内有对象，其中对象存在跨带指针。  

**卡表就是基于“卡精度”实现记忆集。**


基于卡表（Card Table）的设计，**通常将堆空间划分为一系列2次幂大小的卡页（Card Page）**。

HotSpot JVM的卡页（Card Page）大小为512字节，卡表（Card Table）被实现为一个简单的字节数组，即卡表的每个标记项为1个字节。

当对一个对象引用进行写操作时（对象引用改变），**写屏障**逻辑将会标记对象所在的卡页为dirty。

将地址除以512得到对应的卡表项的索引下标

卡表就是对一块块内存地址的映射，每一块称为一个**卡页**。只要一个卡页内的对象存在一个或者多个跨带引用指针，则**将该位置的卡表数组元素置为脏**。GC的时候将GC root连同脏卡表映射的地址一起扫描。

**卡页变脏的动作**原则上发生在引用类型字段赋值的那一刻，实现上，维护卡表状态的动作被放到了引用类型字段赋值的时候。（只要对引用类型进行更新都会产生额外的开销，不管是否是跨代引用） 
**当更新（引用类型）指针的时候，标记（卡表中的卡）card为dirty，将card存于dirty card queue


引入写屏障和卡表带来的问题
1.无条件写屏障带来的性能开销
2.高并发下虚共享带来的性能开销

```




## 四大引用和引用对象





# 待整理

```markdown
[jvm 可达性分析算法是怎么实现的？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/170211190)
如果在GC时先暂停了用户线程再开始逐个枚举GCRoots对象，肯定需要花费很多时间。有什么方法能够快速枚举GCRoots对象呢？jvm采用OopMap这个数据结构来保存GCRoots对象，在GC时直接通过OopMap就可以得到GCRoots对象了。

那么在什么时候保存GCRoots对象到OopMap呢？jvm引入了安全点概念。当线程运行到安全点时，会保存GCRoots对象到OopMap。进行GC时，GC线程会等所有的用户线程都到达最近的安全点后，再开始进行GC回收，因为只有线程到达安全点，才能保证OopMap是最新的，不会出错。

[(51条消息) GC（1.安全点的相关知识）_随心的专栏-CSDN博客_gc 安全点](https://blog.csdn.net/youyou1543724847/article/details/52728148)

[java 对象存活分析——引用计数法&可达性分析 - 简书 (jianshu.com)](https://www.jianshu.com/p/b5ba9a65ee98?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)
```


### 安全点
[jvm大局观之内存管理篇: 理解jvm安全点,写出更高效的代码 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/286110609)
有了安全点的设定，也就决定了**用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集**，而是强制要求**必须执行到达安全点后才能够暂停**。
因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。

安全点位置的选取基本上是以“是否具有让程序长时间执行的特征”为标准 进行选定的

HotSpot会在所有方法的临返回之前，以及所有非counted loop的循环的回跳之前放置安全点。

“长时间执行”的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。

**为什么把这些位置设置为jvm的安全点呢**

主要**目的**就是**避免程序长时间无法进入safepoint**,比如JVM在做GC之前要等所有的应用线程进入到安全点后VM线程才能分派GC任务 ,如果有线程一直没有进入到安全点,就会导致GC时JVM停顿时间延长,比如文章开头提到的类似问题.

**_主动式中断_**（Voluntary Suspension）和 **_抢先式中断_** （Preemptive Suspension）

  

**主动式中断**

**_主动式中断_**的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地**设置一 个标志位**，**各个线程执行过程时**会不停地**主动去轮询这个标志**，一旦**发现中断标志为真**时就自己**在最近的安全点上主动中断挂起**。轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他 需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新 对象。

**抢先式中断**

**而_抢先式中断_**不需要线程的执行代码 主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。**现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应GC事件**。





# JVM优化
[jvm 优化篇-（5）-线程局部缓存TLAB 指针碰撞、Eden区分配 -XX:+UseTLAB -XX:+PrintTLAB -XX:TLABWasteTargetPercent - 简书 (jianshu.com)](https://www.jianshu.com/p/a7414c0ebb17)
[(58条消息) Java基础知识点总结系列（九）—— 指针碰撞与TALB_别急，还差一行代码的博客-CSDN博客_java指针碰撞](https://blog.csdn.net/qq_41613281/article/details/110001144?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-5-110001144.pc_agg_new_rank&utm_term=TLAB%E5%92%8C%E6%8C%87%E9%92%88%E7%A2%B0%E6%92%9E+jvm&spm=1000.2123.3001.4430)



#### 场景

一个支付系统内存设置过小，然后突发巨大的流量压力，突发的性能抖动，最后导致很多对象长期在新生代被人引用，无法被回收，最后持续进入老年代，最后触发老年代内存都频繁占满，然后老年代都频繁被垃圾回收。


##### 从 0 开始带你成为JVM实战高手
18：
实际上为了避免动态年龄判定规则把Survivor区中的对象直接升入老年代，在这里如果新生代内存有限，那么可以调整"- XX:SurvivorRatio=8"这个参数，默认是说Eden区比例为80%，也可以降低Eden区的比例，给两块Survivor区更多的内存空间，然后 让每次Minor GC后的对象进入Survivor区中，还可以避免动态年龄判定规则直接把他们升入老年代。

#### 只做young GC
“一个面试题，parnew+cms的gc，如何保证只做ygc，jvm参数如何配置？

我的回答（这里指该同学回答）: 加大分代年龄，比如默认15加到30; 修改新生代老年代比例，比如新生代老年代比例改成2:1 修改e区和s区比例，比如改成6:2:2

#### 为什么新生代GC比老年代GC快这么多
因为新生代存活对象少，而老年代大多都是存活对象



#### G1
G1最大的一个特点，就是可以让我们设置一个垃圾回收的预期停顿时间 也就是说比如我们可以指定：希望G1同志在垃圾回收的时候，可以保证，在1小时内由G1垃圾回收导致的“Stop the World”时间， 也就是系统停顿的时间，不能超过1分钟。 这个就很厉害了，大家如果看明白了之前我们的很多JVM优化的思路，都明白一点，其实我们对内存合理分配，优化一些参数，就是为 了尽可能减少Minor GC和Full GC，尽量减少GC带来的系统停顿，避免影响系统处理请求。 但是现在我们直接可以给G1指定，在一个时间内，垃圾回收导致的系统停顿时间不能超过多久，G1全权给你负责，保证达到这个目 标。 这样相当于我们就可以直接控制垃圾回收对系统性能的影响了。

简单来说，G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以 回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时 间内尽量回收尽可能多的垃圾对象。

其实在G1对应的内存模型中，Region随时会属于新生代也会属于老年代，所以没有所谓新生代给多少内存，老年代给多少内存这 一说了 实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制
触发垃圾回收的时候，可以根据设定的预期系统停顿时间，来选择最少回收时间和最多回收对象的Region进行垃圾回收，保证GC 对系统停顿的影响在可控范围内，同时还能尽可能回收最多的对象。


新生代最多占据堆的60% ,老年代最多40

在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对 象超过了1MB，就会被放入大对象专门的Region中

**其实新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回 收的策略。**

什么时候触发新生代+老年代的混合垃圾回收？
G1有一个参数，是“-XX:InitiatingHeapOccupancyPercent”，他的默认值是45%
意思就是说，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

G1回收过程:
首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC Roots直接能引用的对象， 这个过程速度是很快的。
接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象
但是这个阶段是可以跟系统程序并发运行的，所以对系统程序的影响不太大。

接着是下一个阶段，最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的 那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象

最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回 收的预期性能和效率。 
接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我 们指定的范围内。

有一些参数可以控制这个，比如“-XX:G1MixedGCCountTarget”参数，就是在**一次混合回收的过程中，最后一个阶段执行几次混合 回收**，默认值是8次
意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反 复8次。


那么为什么要反复回收多次呢？ 
因为你停止系统一会儿，回收掉一些Region，再让系统运行一会儿，然后再次停止系统一会儿，再次回收掉一些Region，这样可以尽 可能让系统不要停顿时间过长，可以在多次回收的间隙，也运行一下。

还有一个参数，就是“-XX:G1HeapWastePercent”，默认值是5% 
他的意思就是说，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉
这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，意 味着本次混合回收就结束了。 而且从这里也能看出来G1整体是基于复制算法进行Region垃圾回收的，不会出现内存碎片的问题，不需要像CMS那样标记-清理之 后，再进行内存碎片的整理

还有一个参数，“-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，意思就是确定要回收的Region的时候，必须是存 活对象低于85%的Region才可以进行回收 否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region，这个成本是很高的


回收失败时的Full GC 
如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region 里去 此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。 **一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region**，这个过程是极慢极慢 的。


该合理设置“-XX:MaxGCPauseMills”参数
如果这个参数设置的小了，那么说明每次gc停顿时间可能特别短，此时G1一旦发现你对几十个Region占满了就立即触 发新生代gc，然后gc频率特别频繁，虽然每次gc时间很短
如果这个参数设置大了呢？ 那么可能G1会允许你不停的在新生代理分配新的对象，然后积累了很多对象了，再一次性回收几百个Region 此时可能一次GC停顿时间就会达到几百毫秒，但是GC的频率很低。比如说30分钟才触发一次新生代GC，但是每次停 顿500毫秒


那么G1里面跟之前的ParNew+CMS的组合是不同的，我们到底应该如何来优化参数呢？ 
其实核心的点，还是“-XX:MaxGCPauseMills”这个参数。 大家可以想一下，假设你“-XX:MaxGCPauseMills”参数设置的值很大，导致系统运行很久，新生代可能都占用了堆 内存的60%了，此时才触发新生代gc。 那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进入老年代中。 或者是你新生代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定规则，达到了Survivor 区域的50%，也会快速导致一些对象进入老年代中。
所以这里核心还是在于调节“-XX:MaxGCPauseMills”这个参数的值，在保证他的新生代gc别太频繁的同时，还得考 虑每次gc过后的存活对象有多少，避免存活对象太多快速进入老年代，频繁触发mixed gc。