# Java对象内存组成
每个java对象在内存布局中由三部分组成：**对象头**、**实例数据**和**填充数据/对齐填充**。

其中对象头又可以分为两部分：**标记字段 mark word** 和 **类型指针**
## Java对象头

32位虚拟机

```markdown
普通对象
|--------------------------------------------------------------|
|                  Object Header (64 bits)                     |
|------------------------------------|-------------------------|
| Mark Word (32 bits)                | Klass Word (32 bits)    |
|------------------------------------|-------------------------|




数组对象
|---------------------------------------------------------------------------------|
|                             Object Header (96 bits)                             |
|--------------------------------|-----------------------|------------------------|
| Mark Word(32bits)              | Klass Word(32bits)    | array length(32bits)   |
|--------------------------------|-----------------------|------------------------|

Mark Word 结构
|-------------------------------------------------------|--------------------|
|                  Mark Word (32 bits)                  | State              |
|-------------------------------------------------------|--------------------|
| hashcode:25 | age:4 | biased_lock:0              | 01 | Normal             |
|-------------------------------------------------------|--------------------|
| thread:23 | epoch:2 | age:4 | biased_lock:1      | 01 | Biased             |
|-------------------------------------------------------|--------------------|
| ptr_to_lock_record:30                            | 00 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
| ptr_to_heavyweight_monitor:30                    | 10 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                                  | 11 | Marked for GC      |
|-------------------------------------------------------|--------------------|

```
![[Pasted image 20220211141514.png]]

# 基础知识
## Monitor
 Monitor被翻译为监视器或管程
每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针
![[Pasted image 20220211153227.png]]

synchronized 字节码层面是 首先拿到引用地址,复制一份存储到一个临时变量(slot 1) , 将 lock对象的 MarkWord 置为 Monitor指针

操作完后 aload_1 拿到lock引用 , monitorexit 将lock对象的MarkWord重置,唤醒EntryList

如果在同步代码块出现异常, 也是会释放锁的(拿到引用地址,重置,唤醒,抛出异常)



synchronized包裹的内容可以是字符串、class对象、this（synchronized实例方法包裹的是this，而synchronized类方法包裹的是class对象）等。不管它包裹的什么，那一定是一个对象。

包裹对象,方法,同步代码块

monitor在底层，对应C++定义的objectMonitor。

**synchronized关联的是monitor结构，而monitor和Object对象绑定**

![img](file://D:\java-daily\JAVA%E5%9F%BA%E7%A1%80\images\JUC\20200608145148.png?lastModify=1644678223)

-   当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)**是否绑定了Monitor**。
    
    -   如果**没有绑定**，则会先去去与Monitor绑定，并且将Owner设为当前线程。
        
    -   如果已经绑定，则会去查询该Monitor是否已经有了Owner
        
        -   如果没有，则Owner与将当前线程绑定
            
        -   如果有，则放入EntryList，进入阻塞状态(blocked)
            
        
        > 在并发情况下,线程执行到临界区代码时,会尝试一次CAS使自己成为 Owner,如果第一次CAS失败则说明抢占失败, 接着会尝试自适应自旋,在自旋期间如果成功就将Owner修改为自己,并且将count加一。执行完毕将count减一，复位owner，并且唤起entryList阻塞的线程（实现上通常唤醒队头线程，不过如果没抢到还会进入entryList队尾，通常流动性很大，不会出现饥饿）。 如果失败就进入Monitor的EntryList同步队列,并且 调用park()阻塞当前线程,底层对应系统调用**将当前线程对象映射到的操作系统线程挂起，并让出CPU**
        > 
        > owner线程调用wait，则进入waitSet并阻塞（同样对应park调用），同时让出CPU。只有其他线程调用notify它才会被唤醒，而且唤醒后进入entryList，当owner被复位后，同entryList其他线程进行竞争，当成为owner将从原执行位置继续向下执行。
        

-   当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于**阻塞**状态的线程会被**叫醒并竞争**，此时的竞争是**非公平的**
    
-   **注意**：
    
    -   对象在使用了synchronized后与Monitor绑定时，会将对象头中的**Mark Word**置为Monitor指针。
        
    -   每个对象都会绑定一个**唯一的Monitor**，如果synchronized中所指定的对象(obj)**不同**，则会绑定**不同**的Monitor

## Lock Record
锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word