
## 性能优化原则

1. 问题导向
    不要过早进行优化，避免增加系统复杂度，同时浪费研发人力

2. 遵循二八原则
   抓住主要矛盾，优先优化主要的性能瓶颈

3. 优化需要有数据支撑
   能时刻了解到你的优化让**响应时间减少了多少，提升了多少吞吐量，可以使用平均值，极值，分位值**作为统计的特征值


## 高可用设计

### 系统设计
具体优化方法：故障转移，超时控制，降级，限流

#### 故障转移
活动的服务出现问题，应能快速启用备份的服务器接替他们工作。

分为两类：对等节点可直接转移；主备节点则需要进行主备切换



什么时候进行主备切换？如何进行切换？
```markdown

一般采用某种故障检测机制，比如心跳机制，备份节点定期发送心跳包，当多数节点未收到主节点的心跳包，表示主节点故障，需要进行切换。


一般采用paxos、raft等分布式一致性算法，在多个备份节点中选出新主节点。
```


#### 超时控制
在分布式环境下，服务器响应慢可能比宕机危害更大。失败只是瞬时的，而调用延迟会导致占用的资源得不到释放，在高并发情况下会导致整个系统崩溃

如何设置合理的超时时间？
收集系统之间的调用日志，统计比如说 99% 的响应时间是怎样的，然后依据这个时间来指定超时时间。

#### 降级
关闭整个流程中非核心部分，保证主流程能稳定执行

#### 限流
限制单位时间内的请求量，超过的部分直接返回错误


### 系统运维

#### 灰度发布
灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。

灰度期：灰度发布开始到结束期间的这一段时间，称为灰度期。

通过线上流量观察代码变更带来的影响


#### 故障演练
对系统中的部分节点/组件人为破坏，模拟故障，观察系统的表现。为了避免对生产系统造成影响，可以先部署另外一套与线上环境一摸一样的系统，在这上面进行故障演练

## 高扩展设计

### 存储层
分库分表，按业务和数据纬度对库表进行水平/垂直拆分，突破单机限制。有以下两点需要注意：

1.  最好一次性确定好节点/分表数量，避免频繁迁移数据
2.  拆分后尽量避免使用事务，分布式事务需要协调各个模块的资源，容易出问题

### 业务层
按业务纬度，接口重要性纬度和请求来源等多个维度对服务进行拆分和隔离

## 数据库高可用设计

两大优化方向：

1. 提升读写性能
2. 增强存储扩展能力（还是跑到分库分表）
[「存储知识小讲堂系列」为什么横向扩展很重要 (baidu.com)](https://baijiahao.baidu.com/s?id=1688373293594087019&wfr=spider&for=pc)


### 池化技术
池化是一种空间换时间的思路。预先创建好多个对象，重复使用，避免频繁创建销毁对象造成的开销 


#### 如何设计一个数据库连接池
维护池中连接数量和保证连接可用性是连接池管理的两个关键点。

**_请求获取连接流程_**

初始化连接池时，需要指定最大连接数和最小连接数

1.  _连接池当前连接数 < 最小连接数_: 创建新链接处理数据库请求
2.  _最小连接数 < 连接池当前连接数 < 最大连接数_: 优先复用空闲连接，否则创建新连接处理请求
3.  _连接池连接数 > 最大连接数_: 等待一段时间(自旋/线程休眠)，超时还没有连接可以直接抛错

**_保证连接可用性_**

1.  心跳机制，定期检查连接是否可用
2.  每次使用连接前，先检验下连接是否可用，再进行SQL请求

#### 如何设计一个线程池

指定一个最大线程数量，并利用一个有限大小的任务队列，当池中线程数量较少时，直接创建新线程去处理任务，当池中线程达到设置的最大线程数量后，可以将任务放入任务队列中，等待空闲线程执行。

-   合理设置最大线程数量
    
    > CPU密集型任务，保持与CPU核数相当的线程就可以了，避免过多的上下文切换，降低执行效率
    > 
    > IO密集型，可以适当放开数量，因为在执行IO时线程阻塞，CPU空闲下来可以去执行其他线程的任务
    
-   等待队列必须有界，若不限制大小可能会导致队列任务数量过多，触发Full GC，直接导致服务不可用
-   必须监控等待队列中的任务数，避免最大线程数设置不合理导致大量任务留在等待队列中得不到执行


### 主从读写分离

### 分库分表


#### 水平拆分

#### 垂直拆分


#### 如何保证ID全局唯一


## 缓存

### 缓存与数据库一致性保证


### 缓存高可用设计

#### 客户端方案

-   数据分片，将数据分散到多个缓存节点，一般有hash取模和一致性hash两种分片算法。

> _hash取模_：读写时，客户端对key进行hash计算，并对缓存节点数取余，计算出数据所在的节点。该算法实现简单；但当缓存节点个数变化时，容易导致大批量缓存失效。
> 
> _一致性hash算法_：一个有2^32个槽的hash环，使用一定的hash函数，以服务器的IP或主机名作为键进行哈希，这样每台服务器就能确定其在哈希环上的位置；读写时，使用相同的hash函数对key进行hash，得到哈希环上的一个位置，顺时针查找到的第一个服务器，就是该key所在的缓存节点。
> 
> 1.  节点数量变化时，只有少量的key会漂移到其他节点上，不会导致大批量失效
> 2.  某个节点故障时，该节点上的缓存会全部压到后一个节点上，如果后一个节点承受不了，会继续引发故障，如此下去，最后造成整体系统的雪崩。可通过虚拟节点解决
> 3.  在集群中有两个节点 A 和 B，客户端初始写入一个 Key 为 k，值为 3 的缓存数据到 Cache A 中。这时如果要更新 k 的值为 4，但是缓存 A 恰好和客户端连接出现了问题，那这次写入请求会写入到 Cache B 中。接下来缓存 A 和客户端的连接恢复，当客户端要获取 k 的值时，就会获取到存在 Cache A 中的脏数据 3，而不是 Cache B 中的 4。所以必须设置缓存的过期时间

-   缓存节点设置主从机制，在主节点故障时客户端能自动切换
-   在客户端本地缓存少量热点数据，减少对缓存节点的压力


#### 中间代理层方案
对缓存的所有读写请求都通过代理层完成，代理层提供路由功能，内置了高可用相关逻辑，保证底层缓存节点的可用


#### 服务端方案
参考redis的哨兵+cluster实现

## 消息队列

### 作用
-   异步处理  
    将请求先放入队列中，快速响应用户，之后异步通知用户处理结果
-   削峰填谷  
    避免高峰写时导致请求处理的延迟
-   解耦系统模块  
    多个模块之间解耦开来，通过发布订阅消息队列通信。各自系统的变更不会影响到另外一个

### 使用时注意事项

**_避免消息队列数据堆积_**

-   添加对应监控
    
    > 启动一个监控程序，定时将监控消息写入消息队列中，在消费端检查消费时与生产时间的时间间隔，达到阈值后发告警  
    > 通过消息队列提供的工具对队列内数据量进行监控
    
-   减少消息延迟
    
    > 优化消费代码  
    > 增加消费并发度
    

**_避免消息丢失（以kafka举例）_**

-   生产端
    
    > 失败重试  
    > ack设置为all，保证所有的ISR都写入成功
    
-   消息队列服务端
    
    > 保证副本数量和ISR数量
    
-   消费端
    
    > 确保消费后再提交消费进度
    

**_避免消息生产/消费重复（以kafka举例）_**

-   生产端
    
    > 更新kafka版本，利用kafka的幂等机制和事务机制保证消息不重复
    
-   消费端
    
    > 消息id+业务幂等判断
    

**_其他tips_**

使用poll方式消费时需注意当无新消息时消费进程空转占用cpu，拉取不到消息可以等待一段时间再来拉取，等待的时间不宜过长，否则会增加消息的延迟。

一般建议固定的 10ms~100ms，也可以按照一定步长递增，比如第一次拉取不到消息等待 10ms，第二次 20ms，最长可以到100ms，直到拉取到消息再回到 10ms。

## 分布式事务

### 一体化架构的痛点
1.  数据库会成为性能瓶颈，MySQL客户端并发数量有限制
2.  增加研发沟通的成本，抑制了研发效率的提升。
3.  降低系统运维效率，随着系统代码量增多，一次构建的过程，花费的时间可能达到十几分钟；而且一次小改动可能会影响系统的其他模块


### 服务拆分原则

### 微服务化后引入额外的复杂度


### rpc选型考虑

