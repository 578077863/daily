
## redis是什么
高性能非关系型的键值对数据库，redis的全部数据都是存在于内存中，读写速度快，适用于缓存方面

## redis优缺点
**优点**：
1. 高可用
2. 读写速度快

```markdown
1.**基于内存操作**，内存读写速度快。
2.Redis是**单线程**的，避免线程切换开销及多线程的竞争问题。单线程是指网络请求使用一个线程来处理，即一个线程处理所有网络请求，Redis 运行时不止有一个线程，比如数据持久化的过程会另起线程。
3.**支持多种数据类型**，包括String、Hash、List、Set、ZSet等。
4.**支持持久化**。Redis支持RDB和AOF两种持久化机制，持久化功能可以有效地避免数据丢失问题。
5.**支持主从复制**。主节点会自动将数据同步到从节点，可以进行读写分离。
6.丰富的特性，key可以设置过期时间，
```


**缺点**：
1. 数据库容量受物理内存限制
2. 残缺的事务


## redis单线程还快的原因 || 为什么选择单线程
```markdown
Redis 是单线程，**主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程**。 但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

redis在数据读写这一个功能下，是不需要I/O的，如果用多线程，涉及到线程切换和线程调度，并没有提高效率，反而造成额外的性能开销。（eg：系统中通常会存在被多线程同时访问的 共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，**为了保证共享资源的正确性**，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销，**如锁的开销，上下文切换的开销**。）



虽然多线程模型执行读写事件能够提升并发性能，但是引入了多线程会**使得程序的执行具有不确定性，还会造成额外的切换开销**

```

### Redis6.0为何引入多线程
```markdown
仅针对处理网络请求的过程采用了多线程，而数据的读写命令仍然采用单线程进行处理。这里使用多线程IO的原因是在等待网络IO的时候最大化利用CPU资源。

多路复用的IO模型，处理网络请求的时候，select()调用是阻塞的。如果并发量很高的情况下，可能成为瓶颈。多线程可以利用CPU多核的优势，使得多个线程并行。当select()调用返回的时候，请求依次交给多个线程去处理，充分利用CPU多核的优势。
```


## redis为什么快

```markdown
**先来一发单线程的原因**：

看上面

**除了单线程能提速外，快的原因还有redis大部分操作都是在内存上完成，IO多路复用机制，高效的数据结构**

```



## redis高可用

#### 数据尽量少丢失

```markdown
从持久化入手：
AOF
RDB
```


#### 服务尽量少中断
```markdown
主从集群，哨兵，切片集群
```


## redis对象
```markdown

string，list，hash，set，zet

SDS,dict,skipList,zipList,整数集合

```



## 过期健删除策略和内存淘汰策略，缓存污染

```markdown
惰性删除，定期删除


内存有限，来一发内存淘汰策略

淘汰策略的选择
```

## 缓存异常，一致性

```markdown
缓存穿透，击穿，雪崩

先删还是后删，强一致性还是弱一致性，要不要双删

```

## pub/sub机制和stream

```markdown

两者都可以当做消息队列来使用，但前者非数据结构，只在缓冲区中，不持久化，有丢失风险，后者是数据结构，没问题

```

## redis变慢大分析
