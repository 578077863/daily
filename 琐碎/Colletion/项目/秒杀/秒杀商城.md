
### 实体
 vo是不同的表里面的字段

model是映射一张表的字段 

概念：   
VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。

model：持久对象,可以看成是与数据库中的表相映射

数据库为什么要将密码给单独拆出来呢，因为密码用到的频率少，竖直分的思想？


model:用于接收数据库中的数据，通过mybatis 的ORM对象关系映射来获取数据

service主要是来处理业务逻辑，返回数据（数据的返回不会做如何处理，只是将model中的数据进行整合然后保证返回的数据完整性，比如在service中返回一个user model 和一个 role model, 会提供一个UserROleBO来接收user 和 role的数据）

dto: dto主要是用来作为传输数据，在我们的项目中是用来接收远程调用接收响应的对象

vo：主要是我们本地调用的对象， 用来向用户显示（BO中的user和role只需要显示userName和roleName,会通过VO来进行显示）

在实际的开发中，VO对应页面上需要显示的数据，DO对应于数据库中储存的数据（表列，也就是model）,DTO对应于除二者之外需要传递的数据。 DTO(data transfer object):数据传输对象，以前被称为值对象(VO,value object)，作用仅在于在应用程序的各个子系统间传输数据，在表现层展示。与POJO对应一个数据库实体不同，DTO并不对应一个实体，可能仅存储实体的部分属性或加入符合传输需求的其他的属性。


### UserController
获取用户信息 getUser

Service层拿到UserDo和UserPasswordDO组成UserModel返回给Controller层

Controller对拿到的userModel做判空，若为null，抛异常
否则转为userVO，放到通用对象中，传给前端

为什么要有个通用对象，从其结构来看，分为 status和data，前端可根据status选择不同的处理方案，这也跟我们写RPC框架的协议一个思路吧

//若status=success,则data内返回前端需要的json数据  
//若status=fail，则data内使用通用的错误码格式

抛异常的逻辑：java写程序第一步，先做个规定嗷，定义一个接口
public int getErrCode();  
public String getErrMsg();  
public CommonError setErrMsg(String errMsg);

创建异常枚举类，关键两个属性，错误码和错误消息

错误码分类，通用错误1开头，用户信息错误2开头，交易信息错误3开头

这里有个优点：
通用错误类型， msg我们可以根据不同场景去修改，更为灵活
PARAMETER_VALIDATION_ERROR(10001,"参数不合法"),


包装器业务异常实现类
内部有一个CommonError，1是直接传参就行，2是传参后调用setMsg改写下msg，区别就是传入的参数有无Msg了





短信服务

HttpServlet是单例那为什么能多个线程用来session存储，因为它内部是threadlOcal，不同线程的Map不同

@RequestMapping(value = "/getotp",method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})

consumes对应着content-type: eg：text/html; charset=utf-8




**用户注册**
注册流程：

if(!com.alibaba.druid.util.StringUtils.equals(otpCode,inSessionOtpCode)){  
    throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,"短信验证码不符合");  
}

判空处理

调用insertSelective 而不是 insert的原因是，前者若当前的DO对应的属性不存在，则依赖于数据库的默认值，后者是直接为null覆盖了

插入的是两张表，引入 Transactional事务注解

DAO层拿着 UserModel去使用
![[Pasted image 20220420175158.png]]
![[Pasted image 20220420175119.png]]

跨域操作 session无法共享



密码加密流程


mybatis，insertSelective  方法 需要指定数据库 keyProperty = id，useGeneratedKeys = “true”
通过这样将自增id取出来后赋值给对应的


注册手机号唯一怎么做，通过建立唯一索引，通过catch DuplicateKeyException 捕捉 key重复的异常